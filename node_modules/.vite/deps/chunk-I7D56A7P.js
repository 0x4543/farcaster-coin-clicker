import {
  Chi,
  HashMD,
  Maj
} from "./chunk-URUUDYQZ.js";
import {
  BaseError,
  LruMap,
  concat,
  defineFormatter,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString,
  fromString2,
  hexToNumber,
  keccak_256,
  numberToHex,
  padLeft,
  padRight,
  size
} from "./chunk-JKEYR2OQ.js";
import {
  clean,
  createHasher,
  rotl
} from "./chunk-5GTPK223.js";
import {
  ApiController,
  BalanceUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  MELD_PUBLIC_KEY,
  ModalController,
  NumberUtil,
  ONRAMP_PROVIDERS,
  OptionsController,
  RouterController,
  SnackController,
  StorageUtil,
  SwapApiUtil,
  W3mFrameRpcConstants,
  getActiveCaipNetwork,
  getActiveNetworkTokenAddress,
  getPreferredAccountType,
  proxy,
  ref,
  subscribe,
  subscribeKey,
  withErrorBoundary
} from "./chunk-UQBMRNYB.js";
import {
  esm_exports,
  require_blakejs,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_events,
  require_quick_format_unescaped
} from "./chunk-T6HKKWQ2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OS7ZSSJM.js";

// node_modules/@reown/appkit-controllers/node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/@reown/appkit-controllers/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k2) {
          return k2 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback2) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
      wrap2(opts, logger, level);
    }
    function wrap2(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i2 = 0; i2 < args.length; i2++) args[i2] = arguments[i2];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o2 = {};
      if (ts) {
        o2.time = ts;
      }
      o2.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o2, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o2.msg = msg;
      return o2;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i2 in args) {
        if (stdErrSerialize && args[i2] instanceof Error) {
          args[i2] = pino.stdSerializers.err(args[i2]);
        } else if (typeof args[i2] === "object" && !Array.isArray(args[i2])) {
          for (const k2 in args[i2]) {
            if (serialize && serialize.indexOf(k2) > -1 && k2 in serializers) {
              args[i2][k2] = serializers[k2](args[i2][k2]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i2 = 1; i2 < args.length; i2++) {
          args[i2] = arguments[i2 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o2) {
        return typeof o2 !== "undefined" && o2;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SwapCalculationUtil.js
var SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.times(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).times(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).times(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).div(inputValue).times(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).div(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).times(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    var _a4, _b2;
    const sourceTokenBalance = (_b2 = (_a4 = balance == null ? void 0 : balance.find((token) => token.address === sourceTokenAddress)) == null ? void 0 : _a4.quantity) == null ? void 0 : _b2.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").lt(sourceTokenAmount);
    return isInSufficientBalance;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js
var state = proxy({
  message: "",
  variant: "info",
  open: false
});
var controller = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  open(message, variant) {
    const { debug } = OptionsController.state;
    const { code, displayMessage, debugMessage } = message;
    if (displayMessage && debug) {
      state.message = displayMessage;
      state.variant = variant;
      state.open = true;
    }
    if (debugMessage) {
      console.error(typeof debugMessage === "function" ? debugMessage() : debugMessage, code ? { code } : void 0);
    }
  },
  warn(title, description, code) {
    state.open = true;
    state.message = title;
    state.variant = "warning";
    if (description) {
      console.warn(description, code);
    }
  },
  close() {
    state.open = false;
    state.message = "";
    state.variant = "info";
  }
};
var AlertController = withErrorBoundary(controller);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SwapController.js
var INITIAL_GAS_LIMIT = 15e4;
var TO_AMOUNT_DECIMALS = 6;
var initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Control states
  switchingTokens: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
var state2 = proxy({ ...initialState });
var controller2 = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  getParams() {
    var _a4, _b2, _c, _d, _e2, _f2, _g, _h, _i2;
    const namespace = ChainController.state.activeChain;
    const caipAddress = ((_a4 = ChainController.getAccountData(namespace)) == null ? void 0 : _a4.caipAddress) ?? ChainController.state.activeCaipAddress;
    const address = CoreHelperUtil.getPlainAddress(caipAddress);
    const networkAddress = getActiveNetworkTokenAddress();
    const connectorId = ConnectorController.getConnectorId(ChainController.state.activeChain);
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const invalidToToken = !((_b2 = state2.toToken) == null ? void 0 : _b2.address) || !((_c = state2.toToken) == null ? void 0 : _c.decimals);
    const invalidSourceToken = !((_d = state2.sourceToken) == null ? void 0 : _d.address) || !((_e2 = state2.sourceToken) == null ? void 0 : _e2.decimals) || !NumberUtil.bigNumber(state2.sourceTokenAmount).gt(0);
    const invalidSourceTokenAmount = !state2.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: caipAddress,
      sourceTokenAddress: (_f2 = state2.sourceToken) == null ? void 0 : _f2.address,
      toTokenAddress: (_g = state2.toToken) == null ? void 0 : _g.address,
      toTokenAmount: state2.toTokenAmount,
      toTokenDecimals: (_h = state2.toToken) == null ? void 0 : _h.decimals,
      sourceTokenAmount: state2.sourceTokenAmount,
      sourceTokenDecimals: (_i2 = state2.sourceToken) == null ? void 0 : _i2.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,
      isAuthConnector: connectorId === ConstantsUtil.CONNECTOR_ID.AUTH
    };
  },
  async setSourceToken(sourceToken) {
    if (!sourceToken) {
      state2.sourceToken = sourceToken;
      state2.sourceTokenAmount = "";
      state2.sourceTokenPriceInUSD = 0;
      return;
    }
    state2.sourceToken = sourceToken;
    await SwapController.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state2.sourceTokenAmount = amount;
  },
  async setToToken(toToken) {
    if (!toToken) {
      state2.toToken = toToken;
      state2.toTokenAmount = "";
      state2.toTokenPriceInUSD = 0;
      return;
    }
    state2.toToken = toToken;
    await SwapController.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state2.toTokenAmount = amount ? NumberUtil.toFixed(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    let price = state2.tokensPriceMap[address] || 0;
    if (!price) {
      state2.loadingPrices = true;
      price = await SwapController.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state2.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state2.toTokenPriceInUSD = price;
    }
    if (state2.loadingPrices) {
      state2.loadingPrices = false;
    }
    if (SwapController.getParams().availableToSwap && !state2.switchingTokens) {
      SwapController.swapTokens();
    }
  },
  async switchTokens() {
    if (state2.initializing || !state2.initialized || state2.switchingTokens) {
      return;
    }
    state2.switchingTokens = true;
    try {
      const newSourceToken = state2.toToken ? { ...state2.toToken } : void 0;
      const newToToken = state2.sourceToken ? { ...state2.sourceToken } : void 0;
      const newSourceTokenAmount = newSourceToken && state2.toTokenAmount === "" ? "1" : state2.toTokenAmount;
      SwapController.setSourceTokenAmount(newSourceTokenAmount);
      SwapController.setToTokenAmount("");
      await SwapController.setSourceToken(newSourceToken);
      await SwapController.setToToken(newToToken);
      state2.switchingTokens = false;
      SwapController.swapTokens();
    } catch (error) {
      state2.switchingTokens = false;
      throw error;
    }
  },
  resetState() {
    state2.myTokensWithBalance = initialState.myTokensWithBalance;
    state2.tokensPriceMap = initialState.tokensPriceMap;
    state2.initialized = initialState.initialized;
    state2.initializing = initialState.initializing;
    state2.switchingTokens = initialState.switchingTokens;
    state2.sourceToken = initialState.sourceToken;
    state2.sourceTokenAmount = initialState.sourceTokenAmount;
    state2.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state2.toToken = initialState.toToken;
    state2.toTokenAmount = initialState.toTokenAmount;
    state2.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state2.networkPrice = initialState.networkPrice;
    state2.networkTokenSymbol = initialState.networkTokenSymbol;
    state2.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state2.inputError = initialState.inputError;
  },
  resetValues() {
    var _a4;
    const { networkAddress } = SwapController.getParams();
    const networkToken = (_a4 = state2.tokens) == null ? void 0 : _a4.find((token) => token.address === networkAddress);
    SwapController.setSourceToken(networkToken);
    SwapController.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state2.loadingApprovalTransaction;
  },
  clearError() {
    state2.transactionError = void 0;
  },
  async initializeState() {
    if (state2.initializing) {
      return;
    }
    state2.initializing = true;
    if (!state2.initialized) {
      try {
        await SwapController.fetchTokens();
        state2.initialized = true;
      } catch (error) {
        state2.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state2.initializing = false;
  },
  async fetchTokens() {
    var _a4;
    const { networkAddress } = SwapController.getParams();
    await SwapController.getNetworkTokenPrice();
    await SwapController.getMyTokensWithBalance();
    const networkToken = (_a4 = state2.myTokensWithBalance) == null ? void 0 : _a4.find((token) => token.address === networkAddress);
    if (networkToken) {
      state2.networkTokenSymbol = networkToken.symbol;
      SwapController.setSourceToken(networkToken);
      SwapController.setSourceTokenAmount("0");
    }
  },
  async getTokenList() {
    var _a4;
    const activeCaipNetworkId = (_a4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a4.caipNetworkId;
    if (state2.caipNetworkId === activeCaipNetworkId && state2.tokens) {
      return;
    }
    try {
      state2.tokensLoading = true;
      const tokens2 = await SwapApiUtil.getTokenList(activeCaipNetworkId);
      state2.tokens = tokens2;
      state2.caipNetworkId = activeCaipNetworkId;
      state2.popularTokens = tokens2.sort((aTokenInfo, bTokenInfo) => {
        if (aTokenInfo.symbol < bTokenInfo.symbol) {
          return -1;
        }
        if (aTokenInfo.symbol > bTokenInfo.symbol) {
          return 1;
        }
        return 0;
      });
      state2.suggestedTokens = tokens2.filter((token) => {
        if (ConstantsUtil2.SWAP_SUGGESTED_TOKENS.includes(token.symbol)) {
          return true;
        }
        return false;
      });
    } catch (error) {
      state2.tokens = [];
      state2.popularTokens = [];
      state2.suggestedTokens = [];
    } finally {
      state2.tokensLoading = false;
    }
  },
  async getAddressPrice(address) {
    var _a4, _b2;
    const existPrice = state2.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [address]
    });
    const fungibles = (response == null ? void 0 : response.fungibles) || [];
    const allTokens = [...state2.tokens || [], ...state2.myTokensWithBalance || []];
    const symbol = (_a4 = allTokens == null ? void 0 : allTokens.find((token) => token.address === address)) == null ? void 0 : _a4.symbol;
    const price = ((_b2 = fungibles.find((p) => p.symbol.toLowerCase() === (symbol == null ? void 0 : symbol.toLowerCase()))) == null ? void 0 : _b2.price) || 0;
    const priceAsFloat = parseFloat(price.toString());
    state2.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    var _a4;
    const { networkAddress } = SwapController.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [networkAddress]
    }).catch(() => {
      SnackController.showError("Failed to fetch network token price");
      return { fungibles: [] };
    });
    const token = (_a4 = response.fungibles) == null ? void 0 : _a4[0];
    const price = (token == null ? void 0 : token.price.toString()) || "0";
    state2.tokensPriceMap[networkAddress] = parseFloat(price);
    state2.networkTokenSymbol = (token == null ? void 0 : token.symbol) || "";
    state2.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await BalanceUtil.getMyTokensWithBalance(forceUpdate);
    const swapBalances = SwapApiUtil.mapBalancesToSwapTokens(balances);
    if (!swapBalances) {
      return;
    }
    await SwapController.getInitialGasPrice();
    SwapController.setBalances(swapBalances);
  },
  setBalances(balances) {
    const { networkAddress } = SwapController.getParams();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token) => token.address === networkAddress);
    balances.forEach((token) => {
      state2.tokensPriceMap[token.address] = token.price || 0;
    });
    state2.myTokensWithBalance = balances.filter((token) => token.address.startsWith(caipNetwork.caipNetworkId));
    state2.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    var _a4, _b2;
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUSD: null };
    }
    switch ((_b2 = (_a4 = ChainController.state) == null ? void 0 : _a4.activeCaipNetwork) == null ? void 0 : _b2.chainNamespace) {
      case ConstantsUtil.CHAIN.SOLANA:
        state2.gasFee = res.standard ?? "0";
        state2.gasPriceInUSD = NumberUtil.multiply(res.standard, state2.networkPrice).div(1e9).toNumber();
        return {
          gasPrice: BigInt(state2.gasFee),
          gasPriceInUSD: Number(state2.gasPriceInUSD)
        };
      case ConstantsUtil.CHAIN.EVM:
      default:
        const value = res.standard ?? "0";
        const gasFee = BigInt(value);
        const gasLimit = BigInt(INITIAL_GAS_LIMIT);
        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, gasLimit, gasFee);
        state2.gasFee = value;
        state2.gasPriceInUSD = gasPrice;
        return { gasPrice: gasFee, gasPriceInUSD: gasPrice };
    }
  },
  // -- Swap -------------------------------------- //
  async swapTokens() {
    var _a4, _b2, _c;
    const address = (_a4 = ChainController.getAccountData()) == null ? void 0 : _a4.address;
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state2.sourceTokenAmount).gt(0);
    if (!haveSourceTokenAmount) {
      SwapController.setToTokenAmount("");
    }
    if (!toToken || !sourceToken || state2.loadingPrices || !haveSourceTokenAmount || !address) {
      return;
    }
    state2.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state2.sourceTokenAmount).times(10 ** sourceToken.decimals).round(0);
    try {
      const quoteResponse = await BlockchainApiController.fetchSwapQuote({
        userAddress: address,
        from: sourceToken.address,
        to: toToken.address,
        gasPrice: state2.gasFee,
        amount: amountDecimal.toString()
      });
      state2.loadingQuote = false;
      const quoteToAmount = (_c = (_b2 = quoteResponse == null ? void 0 : quoteResponse.quotes) == null ? void 0 : _b2[0]) == null ? void 0 : _c.toAmount;
      if (!quoteToAmount) {
        AlertController.open({
          displayMessage: "Incorrect amount",
          debugMessage: "Please enter a valid amount"
        }, "error");
        return;
      }
      const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).div(10 ** toToken.decimals).toString();
      SwapController.setToTokenAmount(toTokenAmount);
      const isInsufficientToken = SwapController.hasInsufficientToken(state2.sourceTokenAmount, sourceToken.address);
      if (isInsufficientToken) {
        state2.inputError = "Insufficient balance";
      } else {
        state2.inputError = void 0;
        SwapController.setTransactionDetails();
      }
    } catch (error) {
      const response = await SwapApiUtil.handleSwapError(error);
      state2.loadingQuote = false;
      state2.inputError = response || "Insufficient balance";
    }
  },
  // -- Create Transactions -------------------------------------- //
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = SwapController.getParams();
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state2.loadingQuote) {
      return void 0;
    }
    try {
      state2.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state2.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await SwapController.createSwapTransaction();
      } else {
        transaction = await SwapController.createAllowanceTransaction();
      }
      state2.loadingBuildTransaction = false;
      state2.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state2.loadingBuildTransaction = false;
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, sourceTokenAddress, toTokenAddress } = SwapController.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error("createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const address = CoreHelperUtil.getPlainAddress(response.tx.from);
      if (!address) {
        throw new Error("SwapController:createAllowanceTransaction - address is required");
      }
      const transaction = {
        data: response.tx.data,
        to: address,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state2.toTokenAmount
      };
      state2.swapTransaction = void 0;
      state2.approvalTransaction = {
        data: transaction.data,
        to: transaction.to,
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
      return {
        data: transaction.data,
        to: transaction.to,
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    var _a4;
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = SwapController.getParams();
    const sourceToken = state2.sourceToken;
    const toToken = state2.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = (_a4 = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals)) == null ? void 0 : _a4.toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount,
        disableEstimate: true
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const address = CoreHelperUtil.getPlainAddress(response.tx.to);
      if (!address) {
        throw new Error("SwapController:createSwapTransaction - address is required");
      }
      const transaction = {
        data: response.tx.data,
        to: address,
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount ?? "0") : BigInt("0"),
        toAmount: state2.toTokenAmount
      };
      state2.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, gas, gasPrice);
      state2.approvalTransaction = void 0;
      state2.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state2.approvalTransaction = void 0;
      state2.swapTransaction = void 0;
      state2.fetchError = true;
      return void 0;
    }
  },
  onEmbeddedWalletApprovalSuccess() {
    SnackController.showLoading("Approve limit increase in your wallet");
    RouterController.replace("SwapPreview");
  },
  // -- Send Transactions --------------------------------- //
  async sendTransactionForApproval(data) {
    var _a4, _b2, _c;
    const { fromAddress, isAuthConnector } = SwapController.getParams();
    state2.loadingApprovalTransaction = true;
    const approveLimitMessage = `Approve limit increase in your wallet`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        onSuccess: SwapController.onEmbeddedWalletApprovalSuccess
      });
    } else {
      SnackController.showLoading(approveLimitMessage);
    }
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        value: data.value,
        chainNamespace: ConstantsUtil.CHAIN.EVM
      });
      await SwapController.swapTokens();
      await SwapController.getTransaction();
      state2.approvalTransaction = void 0;
      state2.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state2.transactionError = error == null ? void 0 : error.displayMessage;
      state2.loadingApprovalTransaction = false;
      SnackController.showError((error == null ? void 0 : error.displayMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_APPROVAL_ERROR",
        properties: {
          message: (error == null ? void 0 : error.displayMessage) || (error == null ? void 0 : error.message) || "Unknown",
          network: ((_a4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a4.caipNetworkId) || "",
          swapFromToken: ((_b2 = SwapController.state.sourceToken) == null ? void 0 : _b2.symbol) || "",
          swapToToken: ((_c = SwapController.state.toToken) == null ? void 0 : _c.symbol) || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
    }
  },
  async sendTransactionForSwap(data) {
    var _a4, _b2, _c, _d, _e2, _f2, _g, _h, _i2, _j, _k, _l;
    if (!data) {
      return void 0;
    }
    const { fromAddress, toTokenAmount, isAuthConnector } = SwapController.getParams();
    state2.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${(_a4 = state2.sourceToken) == null ? void 0 : _a4.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_b2 = state2.toToken) == null ? void 0 : _b2.symbol}`;
    const snackbarSuccessMessage = `Swapped ${(_c = state2.sourceToken) == null ? void 0 : _c.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_d = state2.toToken) == null ? void 0 : _d.symbol}`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        onSuccess() {
          RouterController.replace("Account");
          SnackController.showLoading(snackbarPendingMessage);
          controller2.resetState();
        }
      });
    } else {
      SnackController.showLoading("Confirm transaction in your wallet");
    }
    try {
      const forceUpdateAddresses = [(_e2 = state2.sourceToken) == null ? void 0 : _e2.address, (_f2 = state2.toToken) == null ? void 0 : _f2.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data.to,
        data: data.data,
        value: data.value,
        chainNamespace: ConstantsUtil.CHAIN.EVM
      });
      state2.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: ((_g = ChainController.state.activeCaipNetwork) == null ? void 0 : _g.caipNetworkId) || "",
          swapFromToken: ((_h = SwapController.state.sourceToken) == null ? void 0 : _h.symbol) || "",
          swapToToken: ((_i2 = SwapController.state.toToken) == null ? void 0 : _i2.symbol) || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      controller2.resetState();
      if (!isAuthConnector) {
        RouterController.replace("Account");
      }
      controller2.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state2.transactionError = error == null ? void 0 : error.displayMessage;
      state2.loadingTransaction = false;
      SnackController.showError((error == null ? void 0 : error.displayMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          message: (error == null ? void 0 : error.displayMessage) || (error == null ? void 0 : error.message) || "Unknown",
          network: ((_j = ChainController.state.activeCaipNetwork) == null ? void 0 : _j.caipNetworkId) || "",
          swapFromToken: ((_k = SwapController.state.sourceToken) == null ? void 0 : _k.symbol) || "",
          swapToToken: ((_l = SwapController.state.toToken) == null ? void 0 : _l.symbol) || "",
          swapFromAmount: SwapController.state.sourceTokenAmount || "",
          swapToAmount: SwapController.state.toTokenAmount || "",
          isSmartAccount: getPreferredAccountType(ConstantsUtil.CHAIN.EVM) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  // -- Checks -------------------------------------------- //
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state2.myTokensWithBalance);
    return isInsufficientSourceTokenForSwap;
  },
  // -- Calculations -------------------------------------- //
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = SwapController.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state2.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state2.networkPrice, BigInt(state2.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state2.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state2.sourceTokenAmount,
      sourceTokenPriceInUSD: state2.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state2.toTokenPriceInUSD,
      toTokenAmount: state2.toTokenAmount
    });
    state2.maxSlippage = SwapCalculationUtil.getMaxSlippage(state2.slippage, state2.toTokenAmount);
    state2.providerFee = SwapCalculationUtil.getProviderFee(state2.sourceTokenAmount);
  }
};
var SwapController = withErrorBoundary(controller2);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@reown/appkit-controllers/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i2;
  function t() {
  }
  i2 = t, i2.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i2.prototype.setItem = function(e, n2) {
    this[e] = String(n2);
  }, i2.prototype.removeItem = function(e) {
    delete this[e];
  }, i2.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n2) {
      e[n2] = void 0, delete e[n2];
    });
  }, i2.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i2.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser());
var import_pino2 = __toESM(require_browser());
var l2 = 1e3 * 1024;

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@reown/appkit-controllers/node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: A3, B, C: C4, D, E: E2 } = this;
    return [A3, B, C4, D, E2];
  }
  set(A3, B, C4, D, E2) {
    this.A = A3 | 0;
    this.B = B | 0;
    this.C = C4 | 0;
    this.D = D | 0;
    this.E = E2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A: A3, B, C: C4, D, E: E2 } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F, K3;
      if (i2 < 20) {
        F = Chi(B, C4, D);
        K3 = 1518500249;
      } else if (i2 < 40) {
        F = B ^ C4 ^ D;
        K3 = 1859775393;
      } else if (i2 < 60) {
        F = Maj(B, C4, D);
        K3 = 2400959708;
      } else {
        F = B ^ C4 ^ D;
        K3 = 3395469782;
      }
      const T2 = rotl(A3, 5) + F + E2 + K3 + SHA1_W[i2] | 0;
      E2 = D;
      D = C4;
      C4 = rotl(B, 30);
      B = A3;
      A3 = T2;
    }
    A3 = A3 + this.A | 0;
    B = B + this.B | 0;
    C4 = C4 + this.C | 0;
    D = D + this.D | 0;
    E2 = E2 + this.E | 0;
    this.set(A3, B, C4, D, E2);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A: A3, B, C: C4, D } = this;
    return [A3, B, C4, D];
  }
  set(A3, B, C4, D) {
    this.A = A3 | 0;
    this.B = B | 0;
    this.C = C4 | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      MD5_W[i2] = view.getUint32(offset, true);
    let { A: A3, B, C: C4, D } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      let F, g, s2;
      if (i2 < 16) {
        F = Chi(B, C4, D);
        g = i2;
        s2 = [7, 12, 17, 22];
      } else if (i2 < 32) {
        F = Chi(D, B, C4);
        g = (5 * i2 + 1) % 16;
        s2 = [5, 9, 14, 20];
      } else if (i2 < 48) {
        F = B ^ C4 ^ D;
        g = (3 * i2 + 5) % 16;
        s2 = [4, 11, 16, 23];
      } else {
        F = C4 ^ (B | ~D);
        g = 7 * i2 % 16;
        s2 = [6, 10, 15, 21];
      }
      F = F + A3 + K[i2] + MD5_W[g];
      A3 = D;
      D = C4;
      C4 = B;
      B = B + rotl(F, s2[i2 % 4]);
    }
    A3 = A3 + this.A | 0;
    B = B + this.B | 0;
    C4 = C4 + this.C | 0;
    D = D + this.D | 0;
    this.set(A3, B, C4, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i2) => i2)))();
var Pi160 = (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R2 = [Pi160];
  const res = [L, R2];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k2) => Rho160[k2]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y3, z2) {
  if (group === 0)
    return x ^ y3 ^ z2;
  if (group === 1)
    return x & y3 | ~x & z2;
  if (group === 2)
    return (x | ~y3) ^ z2;
  if (group === 3)
    return x & z2 | y3 & ~z2;
  return x ^ (y3 | ~z2);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4 } = this;
    return [h0, h1, h22, h32, h4];
  }
  set(h0, h1, h22, h32, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br3 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er2 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar2 + ripemd_f(rGroup, br3, cr2, dr2) + BUF_160[rr3[i2]] + hbr, sr[i2]) + er2 | 0;
        ar2 = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br3, br3 = tr;
      }
    }
    this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er2 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br3 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hash[i2 >> 1] >> 4 >= 8 && characters[i2]) {
      characters[i2] = characters[i2].toUpperCase();
    }
    if ((hash[i2 >> 1] & 15) >= 8 && characters[i2 + 1]) {
      characters[i2 + 1] = characters[i2 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit-controllers/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i2 = 0; i2 < types.length; i2++) {
    const type = types[i2];
    const value = values[i2];
    data.push(encodePacked2.encode(type, value));
  }
  return concat(...data);
}
(function(encodePacked3) {
  function encode5(type, value, isArray2 = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray2 ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray2 ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits, 10) / 8;
      return fromNumber(value, {
        size: isArray2 ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4, 10) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4, 10),
          value
        });
      return padRight(value, isArray2 ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i2 = 0; i2 < value.length; i2++) {
        data.push(encode5(childType, value[i2], true));
      }
      if (data.length === 0)
        return "0x";
      return concat(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode5;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var Oe = BigInt(2 ** 32 - 1);
var Nr = BigInt(32);
function Ur(t, e = false) {
  return e ? { h: Number(t & Oe), l: Number(t >> Nr & Oe) } : { h: Number(t >> Nr & Oe) | 0, l: Number(t & Oe) | 0 };
}
function _r(t, e = false) {
  const n2 = t.length;
  let r2 = new Uint32Array(n2), o2 = new Uint32Array(n2);
  for (let s2 = 0; s2 < n2; s2++) {
    const { h: i2, l: c2 } = Ur(t[s2], e);
    [r2[s2], o2[s2]] = [i2, c2];
  }
  return [r2, o2];
}
var Rr = (t, e, n2) => t >>> n2;
var $r = (t, e, n2) => t << 32 - n2 | e >>> n2;
var St = (t, e, n2) => t >>> n2 | e << 32 - n2;
var Ot = (t, e, n2) => t << 32 - n2 | e >>> n2;
var de = (t, e, n2) => t << 64 - n2 | e >>> n2 - 32;
var he = (t, e, n2) => t >>> n2 - 32 | e << 64 - n2;
var Li = (t, e) => e;
var ki = (t, e) => t;
var Pi = (t, e, n2) => t << n2 | e >>> 32 - n2;
var Hi = (t, e, n2) => e << n2 | t >>> 32 - n2;
var Di = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var Vi = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
function dt(t, e, n2, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n2 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var fn = (t, e, n2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0);
var an = (t, e, n2, r2) => e + n2 + r2 + (t / 2 ** 32 | 0) | 0;
var Mi = (t, e, n2, r2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0);
var Ki = (t, e, n2, r2, o2) => e + n2 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var qi = (t, e, n2, r2, o2) => (t >>> 0) + (e >>> 0) + (n2 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Fi = (t, e, n2, r2, o2, s2) => e + n2 + r2 + o2 + s2 + (t / 2 ** 32 | 0) | 0;
var Xt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ne(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ht(t, ...e) {
  if (!Ne(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ue(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function un(t, e) {
  ht(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function pe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function lt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function ln(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function bt(t, e) {
  return t << 32 - e | t >>> e;
}
var Tr = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Cr(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt = Tr ? (t) => t : (t) => Cr(t);
function Zi(t) {
  for (let e = 0; e < t.length; e++) t[e] = Cr(t[e]);
  return t;
}
var Ut = Tr ? (t) => t : Zi;
var jr = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Gi = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Jt(t) {
  if (ht(t), jr) return t.toHex();
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Gi[t[n2]];
  return e;
}
var vt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Lr(t) {
  if (t >= vt._0 && t <= vt._9) return t - vt._0;
  if (t >= vt.A && t <= vt.F) return t - (vt.A - 10);
  if (t >= vt.a && t <= vt.f) return t - (vt.a - 10);
}
function _e(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (jr) return Uint8Array.fromHex(t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o2 = 0, s2 = 0; o2 < n2; o2++, s2 += 2) {
    const i2 = Lr(t.charCodeAt(s2)), c2 = Lr(t.charCodeAt(s2 + 1));
    if (i2 === void 0 || c2 === void 0) {
      const f4 = t[s2] + t[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + f4 + '" at index ' + s2);
    }
    r2[o2] = i2 * 16 + c2;
  }
  return r2;
}
function kr(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function pt(t) {
  return typeof t == "string" && (t = kr(t)), ht(t), t;
}
function _t(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    ht(o2), e += o2.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s2 = t[r2];
    n2.set(s2, o2), o2 += s2.length;
  }
  return n2;
}
var Re = class {
};
function ge(t) {
  const e = (r2) => t().update(pt(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function zi(t) {
  const e = (r2, o2) => t(o2).update(pt(r2)).digest(), n2 = t({});
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
function Mt(t = 32) {
  if (Xt && typeof Xt.getRandomValues == "function") return Xt.getRandomValues(new Uint8Array(t));
  if (Xt && typeof Xt.randomBytes == "function") return Uint8Array.from(Xt.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var Yi = BigInt(0);
var be = BigInt(1);
var Wi = BigInt(2);
var Xi = BigInt(7);
var Ji = BigInt(256);
var Qi = BigInt(113);
var Pr = [];
var Hr = [];
var Dr = [];
for (let t = 0, e = be, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], Pr.push(2 * (5 * r2 + n2)), Hr.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Yi;
  for (let s2 = 0; s2 < 7; s2++) e = (e << be ^ (e >> Xi) * Qi) % Ji, e & Wi && (o2 ^= be << (be << BigInt(s2)) - be);
  Dr.push(o2);
}
var Vr = _r(Dr, true);
var tc = Vr[0];
var ec = Vr[1];
var Mr = (t, e, n2) => n2 > 32 ? Di(t, e, n2) : Pi(t, e, n2);
var Kr = (t, e, n2) => n2 > 32 ? Vi(t, e, n2) : Hi(t, e, n2);
function nc(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let i2 = 0; i2 < 10; i2++) n2[i2] = t[i2] ^ t[i2 + 10] ^ t[i2 + 20] ^ t[i2 + 30] ^ t[i2 + 40];
    for (let i2 = 0; i2 < 10; i2 += 2) {
      const c2 = (i2 + 8) % 10, f4 = (i2 + 2) % 10, u = n2[f4], a = n2[f4 + 1], l4 = Mr(u, a, 1) ^ n2[c2], d3 = Kr(u, a, 1) ^ n2[c2 + 1];
      for (let h4 = 0; h4 < 50; h4 += 10) t[i2 + h4] ^= l4, t[i2 + h4 + 1] ^= d3;
    }
    let o2 = t[2], s2 = t[3];
    for (let i2 = 0; i2 < 24; i2++) {
      const c2 = Hr[i2], f4 = Mr(o2, s2, c2), u = Kr(o2, s2, c2), a = Pr[i2];
      o2 = t[a], s2 = t[a + 1], t[a] = f4, t[a + 1] = u;
    }
    for (let i2 = 0; i2 < 50; i2 += 10) {
      for (let c2 = 0; c2 < 10; c2++) n2[c2] = t[i2 + c2];
      for (let c2 = 0; c2 < 10; c2++) t[i2 + c2] ^= ~n2[(c2 + 2) % 10] & n2[(c2 + 4) % 10];
    }
    t[0] ^= tc[r2], t[1] ^= ec[r2];
  }
  lt(n2);
}
var Jn = class _Jn extends Re {
  constructor(e, n2, r2, o2 = false, s2 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o2, this.rounds = s2, mt(r2), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = pe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ut(this.state32), nc(this.state32, this.rounds), Ut(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n2, state: r2 } = this, o2 = e.length;
    for (let s2 = 0; s2 < o2; ) {
      const i2 = Math.min(n2 - this.pos, o2 - s2);
      for (let c2 = 0; c2 < i2; c2++) r2[this.pos++] ^= e[s2++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Nt(this, false), ht(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s2 = e.length; o2 < s2; ) {
      this.posOut >= r2 && this.keccak();
      const i2 = Math.min(r2 - this.posOut, s2 - o2);
      e.set(n2.subarray(this.posOut, this.posOut + i2), o2), this.posOut += i2, o2 += i2;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (un(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, lt(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o2, rounds: s2, enableXOF: i2 } = this;
    return e || (e = new _Jn(n2, r2, o2, i2, s2)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s2, e.suffix = r2, e.outputLen = o2, e.enableXOF = i2, e.destroyed = this.destroyed, e;
  }
};
var rc = (t, e, n2) => ge(() => new Jn(e, t, n2));
var oc = rc(1, 136, 256 / 8);
function sc(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s2 = BigInt(4294967295), i2 = Number(n2 >> o2 & s2), c2 = Number(n2 & s2), f4 = r2 ? 4 : 0, u = r2 ? 0 : 4;
  t.setUint32(e + f4, i2, r2), t.setUint32(e + u, c2, r2);
}
function ic(t, e, n2) {
  return t & e ^ ~t & n2;
}
function cc(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var qr = class extends Re {
  constructor(e, n2, r2, o2) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o2, this.buffer = new Uint8Array(e), this.view = ln(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { view: n2, buffer: r2, blockLen: o2 } = this, s2 = e.length;
    for (let i2 = 0; i2 < s2; ) {
      const c2 = Math.min(o2 - this.pos, s2 - i2);
      if (c2 === o2) {
        const f4 = ln(e);
        for (; o2 <= s2 - i2; i2 += o2) this.process(f4, i2);
        continue;
      }
      r2.set(e.subarray(i2, i2 + c2), this.pos), this.pos += c2, i2 += c2, this.pos === o2 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Nt(this), un(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o2, isLE: s2 } = this;
    let { pos: i2 } = this;
    n2[i2++] = 128, lt(this.buffer.subarray(i2)), this.padOffset > o2 - i2 && (this.process(r2, 0), i2 = 0);
    for (let l4 = i2; l4 < o2; l4++) n2[l4] = 0;
    sc(r2, o2 - 8, BigInt(this.length * 8), s2), this.process(r2, 0);
    const c2 = ln(e), f4 = this.outputLen;
    if (f4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = f4 / 4, a = this.get();
    if (u > a.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l4 = 0; l4 < u; l4++) c2.setUint32(4 * l4, a[l4], s2);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o2, finished: s2, destroyed: i2, pos: c2 } = this;
    return e.destroyed = i2, e.finished = s2, e.length = o2, e.pos = c2, o2 % n2 && e.buffer.set(r2), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Rt = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var X = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var J = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var fc = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var $t = new Uint32Array(64);
var ac = class extends qr {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Rt[0] | 0, this.B = Rt[1] | 0, this.C = Rt[2] | 0, this.D = Rt[3] | 0, this.E = Rt[4] | 0, this.F = Rt[5] | 0, this.G = Rt[6] | 0, this.H = Rt[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o2, E: s2, F: i2, G: c2, H: f4 } = this;
    return [e, n2, r2, o2, s2, i2, c2, f4];
  }
  set(e, n2, r2, o2, s2, i2, c2, f4) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s2 | 0, this.F = i2 | 0, this.G = c2 | 0, this.H = f4 | 0;
  }
  process(e, n2) {
    for (let l4 = 0; l4 < 16; l4++, n2 += 4) $t[l4] = e.getUint32(n2, false);
    for (let l4 = 16; l4 < 64; l4++) {
      const d3 = $t[l4 - 15], h4 = $t[l4 - 2], y3 = bt(d3, 7) ^ bt(d3, 18) ^ d3 >>> 3, m2 = bt(h4, 17) ^ bt(h4, 19) ^ h4 >>> 10;
      $t[l4] = m2 + $t[l4 - 7] + y3 + $t[l4 - 16] | 0;
    }
    let { A: r2, B: o2, C: s2, D: i2, E: c2, F: f4, G: u, H: a } = this;
    for (let l4 = 0; l4 < 64; l4++) {
      const d3 = bt(c2, 6) ^ bt(c2, 11) ^ bt(c2, 25), h4 = a + d3 + ic(c2, f4, u) + fc[l4] + $t[l4] | 0, m2 = (bt(r2, 2) ^ bt(r2, 13) ^ bt(r2, 22)) + cc(r2, o2, s2) | 0;
      a = u, u = f4, f4 = c2, c2 = i2 + h4 | 0, i2 = s2, s2 = o2, o2 = r2, r2 = h4 + m2 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s2 = s2 + this.C | 0, i2 = i2 + this.D | 0, c2 = c2 + this.E | 0, f4 = f4 + this.F | 0, u = u + this.G | 0, a = a + this.H | 0, this.set(r2, o2, s2, i2, c2, f4, u, a);
  }
  roundClean() {
    lt($t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), lt(this.buffer);
  }
};
var Fr = _r(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var uc = Fr[0];
var lc = Fr[1];
var Tt = new Uint32Array(80);
var Ct = new Uint32Array(80);
var dn = class extends qr {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = J[0] | 0, this.Al = J[1] | 0, this.Bh = J[2] | 0, this.Bl = J[3] | 0, this.Ch = J[4] | 0, this.Cl = J[5] | 0, this.Dh = J[6] | 0, this.Dl = J[7] | 0, this.Eh = J[8] | 0, this.El = J[9] | 0, this.Fh = J[10] | 0, this.Fl = J[11] | 0, this.Gh = J[12] | 0, this.Gl = J[13] | 0, this.Hh = J[14] | 0, this.Hl = J[15] | 0;
  }
  get() {
    const { Ah: e, Al: n2, Bh: r2, Bl: o2, Ch: s2, Cl: i2, Dh: c2, Dl: f4, Eh: u, El: a, Fh: l4, Fl: d3, Gh: h4, Gl: y3, Hh: m2, Hl: v } = this;
    return [e, n2, r2, o2, s2, i2, c2, f4, u, a, l4, d3, h4, y3, m2, v];
  }
  set(e, n2, r2, o2, s2, i2, c2, f4, u, a, l4, d3, h4, y3, m2, v) {
    this.Ah = e | 0, this.Al = n2 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s2 | 0, this.Cl = i2 | 0, this.Dh = c2 | 0, this.Dl = f4 | 0, this.Eh = u | 0, this.El = a | 0, this.Fh = l4 | 0, this.Fl = d3 | 0, this.Gh = h4 | 0, this.Gl = y3 | 0, this.Hh = m2 | 0, this.Hl = v | 0;
  }
  process(e, n2) {
    for (let R2 = 0; R2 < 16; R2++, n2 += 4) Tt[R2] = e.getUint32(n2), Ct[R2] = e.getUint32(n2 += 4);
    for (let R2 = 16; R2 < 80; R2++) {
      const Z = Tt[R2 - 15] | 0, H = Ct[R2 - 15] | 0, j = St(Z, H, 1) ^ St(Z, H, 8) ^ Rr(Z, H, 7), L = Ot(Z, H, 1) ^ Ot(Z, H, 8) ^ $r(Z, H, 7), k2 = Tt[R2 - 2] | 0, O2 = Ct[R2 - 2] | 0, T2 = St(k2, O2, 19) ^ de(k2, O2, 61) ^ Rr(k2, O2, 6), C4 = Ot(k2, O2, 19) ^ he(k2, O2, 61) ^ $r(k2, O2, 6), _ = Mi(L, C4, Ct[R2 - 7], Ct[R2 - 16]), p = Ki(_, j, T2, Tt[R2 - 7], Tt[R2 - 16]);
      Tt[R2] = p | 0, Ct[R2] = _ | 0;
    }
    let { Ah: r2, Al: o2, Bh: s2, Bl: i2, Ch: c2, Cl: f4, Dh: u, Dl: a, Eh: l4, El: d3, Fh: h4, Fl: y3, Gh: m2, Gl: v, Hh: U2, Hl: F } = this;
    for (let R2 = 0; R2 < 80; R2++) {
      const Z = St(l4, d3, 14) ^ St(l4, d3, 18) ^ de(l4, d3, 41), H = Ot(l4, d3, 14) ^ Ot(l4, d3, 18) ^ he(l4, d3, 41), j = l4 & h4 ^ ~l4 & m2, L = d3 & y3 ^ ~d3 & v, k2 = qi(F, H, L, lc[R2], Ct[R2]), O2 = Fi(k2, U2, Z, j, uc[R2], Tt[R2]), T2 = k2 | 0, C4 = St(r2, o2, 28) ^ de(r2, o2, 34) ^ de(r2, o2, 39), _ = Ot(r2, o2, 28) ^ he(r2, o2, 34) ^ he(r2, o2, 39), p = r2 & s2 ^ r2 & c2 ^ s2 & c2, b = o2 & i2 ^ o2 & f4 ^ i2 & f4;
      U2 = m2 | 0, F = v | 0, m2 = h4 | 0, v = y3 | 0, h4 = l4 | 0, y3 = d3 | 0, { h: l4, l: d3 } = dt(u | 0, a | 0, O2 | 0, T2 | 0), u = c2 | 0, a = f4 | 0, c2 = s2 | 0, f4 = i2 | 0, s2 = r2 | 0, i2 = o2 | 0;
      const g = fn(T2, _, b);
      r2 = an(g, O2, C4, p), o2 = g | 0;
    }
    ({ h: r2, l: o2 } = dt(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s2, l: i2 } = dt(this.Bh | 0, this.Bl | 0, s2 | 0, i2 | 0), { h: c2, l: f4 } = dt(this.Ch | 0, this.Cl | 0, c2 | 0, f4 | 0), { h: u, l: a } = dt(this.Dh | 0, this.Dl | 0, u | 0, a | 0), { h: l4, l: d3 } = dt(this.Eh | 0, this.El | 0, l4 | 0, d3 | 0), { h: h4, l: y3 } = dt(this.Fh | 0, this.Fl | 0, h4 | 0, y3 | 0), { h: m2, l: v } = dt(this.Gh | 0, this.Gl | 0, m2 | 0, v | 0), { h: U2, l: F } = dt(this.Hh | 0, this.Hl | 0, U2 | 0, F | 0), this.set(r2, o2, s2, i2, c2, f4, u, a, l4, d3, h4, y3, m2, v, U2, F);
  }
  roundClean() {
    lt(Tt, Ct);
  }
  destroy() {
    lt(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var dc = class extends dn {
  constructor() {
    super(48), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Q = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var hc = class extends dn {
  constructor() {
    super(32), this.Ah = Q[0] | 0, this.Al = Q[1] | 0, this.Bh = Q[2] | 0, this.Bl = Q[3] | 0, this.Ch = Q[4] | 0, this.Cl = Q[5] | 0, this.Dh = Q[6] | 0, this.Dl = Q[7] | 0, this.Eh = Q[8] | 0, this.El = Q[9] | 0, this.Fh = Q[10] | 0, this.Fl = Q[11] | 0, this.Gh = Q[12] | 0, this.Gl = Q[13] | 0, this.Hh = Q[14] | 0, this.Hl = Q[15] | 0;
  }
};
var $e = ge(() => new ac());
var pc = ge(() => new dn());
var gc = ge(() => new dc());
var bc = ge(() => new hc());
var yc = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var z = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var S = new Uint32Array(32);
function jt(t, e, n2, r2, o2, s2) {
  const i2 = o2[s2], c2 = o2[s2 + 1];
  let f4 = S[2 * t], u = S[2 * t + 1], a = S[2 * e], l4 = S[2 * e + 1], d3 = S[2 * n2], h4 = S[2 * n2 + 1], y3 = S[2 * r2], m2 = S[2 * r2 + 1], v = fn(f4, a, i2);
  u = an(v, u, l4, c2), f4 = v | 0, { Dh: m2, Dl: y3 } = { Dh: m2 ^ u, Dl: y3 ^ f4 }, { Dh: m2, Dl: y3 } = { Dh: Li(m2, y3), Dl: ki(m2) }, { h: h4, l: d3 } = dt(h4, d3, m2, y3), { Bh: l4, Bl: a } = { Bh: l4 ^ h4, Bl: a ^ d3 }, { Bh: l4, Bl: a } = { Bh: St(l4, a, 24), Bl: Ot(l4, a, 24) }, S[2 * t] = f4, S[2 * t + 1] = u, S[2 * e] = a, S[2 * e + 1] = l4, S[2 * n2] = d3, S[2 * n2 + 1] = h4, S[2 * r2] = y3, S[2 * r2 + 1] = m2;
}
function Lt(t, e, n2, r2, o2, s2) {
  const i2 = o2[s2], c2 = o2[s2 + 1];
  let f4 = S[2 * t], u = S[2 * t + 1], a = S[2 * e], l4 = S[2 * e + 1], d3 = S[2 * n2], h4 = S[2 * n2 + 1], y3 = S[2 * r2], m2 = S[2 * r2 + 1], v = fn(f4, a, i2);
  u = an(v, u, l4, c2), f4 = v | 0, { Dh: m2, Dl: y3 } = { Dh: m2 ^ u, Dl: y3 ^ f4 }, { Dh: m2, Dl: y3 } = { Dh: St(m2, y3, 16), Dl: Ot(m2, y3, 16) }, { h: h4, l: d3 } = dt(h4, d3, m2, y3), { Bh: l4, Bl: a } = { Bh: l4 ^ h4, Bl: a ^ d3 }, { Bh: l4, Bl: a } = { Bh: de(l4, a, 63), Bl: he(l4, a, 63) }, S[2 * t] = f4, S[2 * t + 1] = u, S[2 * e] = a, S[2 * e + 1] = l4, S[2 * n2] = d3, S[2 * n2 + 1] = h4, S[2 * r2] = y3, S[2 * r2 + 1] = m2;
}
function mc(t, e = {}, n2, r2, o2) {
  if (mt(n2), t < 0 || t > n2) throw new Error("outputLen bigger than keyLen");
  const { key: s2, salt: i2, personalization: c2 } = e;
  if (s2 !== void 0 && (s2.length < 1 || s2.length > n2)) throw new Error("key length must be undefined or 1.." + n2);
  if (i2 !== void 0 && i2.length !== r2) throw new Error("salt must be undefined or " + r2);
  if (c2 !== void 0 && c2.length !== o2) throw new Error("personalization must be undefined or " + o2);
}
var wc = class extends Re {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e), mt(n2), this.blockLen = e, this.outputLen = n2, this.buffer = new Uint8Array(e), this.buffer32 = pe(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n2, buffer: r2, buffer32: o2 } = this, s2 = e.length, i2 = e.byteOffset, c2 = e.buffer;
    for (let f4 = 0; f4 < s2; ) {
      this.pos === n2 && (Ut(o2), this.compress(o2, 0, false), Ut(o2), this.pos = 0);
      const u = Math.min(n2 - this.pos, s2 - f4), a = i2 + f4;
      if (u === n2 && !(a % 4) && f4 + u < s2) {
        const l4 = new Uint32Array(c2, a, Math.floor((s2 - f4) / 4));
        Ut(l4);
        for (let d3 = 0; f4 + n2 < s2; d3 += o2.length, f4 += n2) this.length += n2, this.compress(l4, d3, false);
        Ut(l4);
        continue;
      }
      r2.set(e.subarray(f4, f4 + u), this.pos), this.pos += u, this.length += u, f4 += u;
    }
    return this;
  }
  digestInto(e) {
    Nt(this), un(e, this);
    const { pos: n2, buffer32: r2 } = this;
    this.finished = true, lt(this.buffer.subarray(n2)), Ut(r2), this.compress(r2, 0, true), Ut(r2);
    const o2 = pe(e);
    this.get().forEach((s2, i2) => o2[i2] = wt(s2));
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    const { buffer: n2, length: r2, finished: o2, destroyed: s2, outputLen: i2, pos: c2 } = this;
    return e || (e = new this.constructor({ dkLen: i2 })), e.set(...this.get()), e.buffer.set(n2), e.destroyed = s2, e.finished = o2, e.length = r2, e.pos = c2, e.outputLen = i2, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var vc = class extends wc {
  constructor(e = {}) {
    const n2 = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n2), this.v0l = z[0] | 0, this.v0h = z[1] | 0, this.v1l = z[2] | 0, this.v1h = z[3] | 0, this.v2l = z[4] | 0, this.v2h = z[5] | 0, this.v3l = z[6] | 0, this.v3h = z[7] | 0, this.v4l = z[8] | 0, this.v4h = z[9] | 0, this.v5l = z[10] | 0, this.v5h = z[11] | 0, this.v6l = z[12] | 0, this.v6h = z[13] | 0, this.v7l = z[14] | 0, this.v7h = z[15] | 0, mc(n2, e, 64, 16, 16);
    let { key: r2, personalization: o2, salt: s2 } = e, i2 = 0;
    if (r2 !== void 0 && (r2 = pt(r2), i2 = r2.length), this.v0l ^= this.outputLen | i2 << 8 | 65536 | 1 << 24, s2 !== void 0) {
      s2 = pt(s2);
      const c2 = pe(s2);
      this.v4l ^= wt(c2[0]), this.v4h ^= wt(c2[1]), this.v5l ^= wt(c2[2]), this.v5h ^= wt(c2[3]);
    }
    if (o2 !== void 0) {
      o2 = pt(o2);
      const c2 = pe(o2);
      this.v6l ^= wt(c2[0]), this.v6h ^= wt(c2[1]), this.v7l ^= wt(c2[2]), this.v7h ^= wt(c2[3]);
    }
    if (r2 !== void 0) {
      const c2 = new Uint8Array(this.blockLen);
      c2.set(r2), this.update(c2);
    }
  }
  get() {
    let { v0l: e, v0h: n2, v1l: r2, v1h: o2, v2l: s2, v2h: i2, v3l: c2, v3h: f4, v4l: u, v4h: a, v5l: l4, v5h: d3, v6l: h4, v6h: y3, v7l: m2, v7h: v } = this;
    return [e, n2, r2, o2, s2, i2, c2, f4, u, a, l4, d3, h4, y3, m2, v];
  }
  set(e, n2, r2, o2, s2, i2, c2, f4, u, a, l4, d3, h4, y3, m2, v) {
    this.v0l = e | 0, this.v0h = n2 | 0, this.v1l = r2 | 0, this.v1h = o2 | 0, this.v2l = s2 | 0, this.v2h = i2 | 0, this.v3l = c2 | 0, this.v3h = f4 | 0, this.v4l = u | 0, this.v4h = a | 0, this.v5l = l4 | 0, this.v5h = d3 | 0, this.v6l = h4 | 0, this.v6h = y3 | 0, this.v7l = m2 | 0, this.v7h = v | 0;
  }
  compress(e, n2, r2) {
    this.get().forEach((f4, u) => S[u] = f4), S.set(z, 16);
    let { h: o2, l: s2 } = Ur(BigInt(this.length));
    S[24] = z[8] ^ s2, S[25] = z[9] ^ o2, r2 && (S[28] = ~S[28], S[29] = ~S[29]);
    let i2 = 0;
    const c2 = yc;
    for (let f4 = 0; f4 < 12; f4++) jt(0, 4, 8, 12, e, n2 + 2 * c2[i2++]), Lt(0, 4, 8, 12, e, n2 + 2 * c2[i2++]), jt(1, 5, 9, 13, e, n2 + 2 * c2[i2++]), Lt(1, 5, 9, 13, e, n2 + 2 * c2[i2++]), jt(2, 6, 10, 14, e, n2 + 2 * c2[i2++]), Lt(2, 6, 10, 14, e, n2 + 2 * c2[i2++]), jt(3, 7, 11, 15, e, n2 + 2 * c2[i2++]), Lt(3, 7, 11, 15, e, n2 + 2 * c2[i2++]), jt(0, 5, 10, 15, e, n2 + 2 * c2[i2++]), Lt(0, 5, 10, 15, e, n2 + 2 * c2[i2++]), jt(1, 6, 11, 12, e, n2 + 2 * c2[i2++]), Lt(1, 6, 11, 12, e, n2 + 2 * c2[i2++]), jt(2, 7, 8, 13, e, n2 + 2 * c2[i2++]), Lt(2, 7, 8, 13, e, n2 + 2 * c2[i2++]), jt(3, 4, 9, 14, e, n2 + 2 * c2[i2++]), Lt(3, 4, 9, 14, e, n2 + 2 * c2[i2++]);
    this.v0l ^= S[0] ^ S[16], this.v0h ^= S[1] ^ S[17], this.v1l ^= S[2] ^ S[18], this.v1h ^= S[3] ^ S[19], this.v2l ^= S[4] ^ S[20], this.v2h ^= S[5] ^ S[21], this.v3l ^= S[6] ^ S[22], this.v3h ^= S[7] ^ S[23], this.v4l ^= S[8] ^ S[24], this.v4h ^= S[9] ^ S[25], this.v5l ^= S[10] ^ S[26], this.v5h ^= S[11] ^ S[27], this.v6l ^= S[12] ^ S[28], this.v6h ^= S[13] ^ S[29], this.v7l ^= S[14] ^ S[30], this.v7h ^= S[15] ^ S[31], lt(S);
  }
  destroy() {
    this.destroyed = true, lt(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var xc = zi((t) => new vc(t));
function lo(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function vn(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function xn(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ot(t, ...e) {
  if (!lo(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function ho(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Fc(t, e) {
  ot(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function Pt(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Qt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function Zc(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Gc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function zc(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function En(t) {
  if (typeof t == "string") t = zc(t);
  else if (lo(t)) t = Bn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function Yc(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Wc(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Xc = (t, e) => {
  function n2(r2, ...o2) {
    if (ot(r2), !Gc) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const a = o2[0];
      if (!a) throw new Error("nonce / iv required");
      t.varSizeNonce ? ot(a) : ot(a, t.nonceLength);
    }
    const s2 = t.tagLength;
    s2 && o2[1] !== void 0 && ot(o2[1]);
    const i2 = e(r2, ...o2), c2 = (a, l4) => {
      if (l4 !== void 0) {
        if (a !== 2) throw new Error("cipher output not supported");
        ot(l4);
      }
    };
    let f4 = false;
    return { encrypt(a, l4) {
      if (f4) throw new Error("cannot encrypt() twice with same key + nonce");
      return f4 = true, ot(a), c2(i2.encrypt.length, l4), i2.encrypt(a, l4);
    }, decrypt(a, l4) {
      if (ot(a), s2 && a.length < s2) throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c2(i2.decrypt.length, l4), i2.decrypt(a, l4);
    } };
  }
  return Object.assign(n2, t), n2;
};
function po(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !Qc(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function go(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o2 = BigInt(32), s2 = BigInt(4294967295), i2 = Number(n2 >> o2 & s2), c2 = Number(n2 & s2), f4 = r2 ? 4 : 0, u = r2 ? 0 : 4;
  t.setUint32(e + f4, i2, r2), t.setUint32(e + u, c2, r2);
}
function Jc(t, e, n2) {
  vn(n2);
  const r2 = new Uint8Array(16), o2 = Zc(r2);
  return go(o2, 0, BigInt(e), n2), go(o2, 8, BigInt(t), n2), r2;
}
function Qc(t) {
  return t.byteOffset % 4 === 0;
}
function Bn(t) {
  return Uint8Array.from(t);
}
var bo = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var tf = bo("expand 16-byte k");
var ef = bo("expand 32-byte k");
var nf = Pt(tf);
var rf = Pt(ef);
function K2(t, e) {
  return t << e | t >>> 32 - e;
}
function An(t) {
  return t.byteOffset % 4 === 0;
}
var Le = 64;
var of = 16;
var yo = 2 ** 32 - 1;
var mo = new Uint32Array();
function sf(t, e, n2, r2, o2, s2, i2, c2) {
  const f4 = o2.length, u = new Uint8Array(Le), a = Pt(u), l4 = An(o2) && An(s2), d3 = l4 ? Pt(o2) : mo, h4 = l4 ? Pt(s2) : mo;
  for (let y3 = 0; y3 < f4; i2++) {
    if (t(e, n2, r2, a, i2, c2), i2 >= yo) throw new Error("arx: counter overflow");
    const m2 = Math.min(Le, f4 - y3);
    if (l4 && m2 === Le) {
      const v = y3 / 4;
      if (y3 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let U2 = 0, F; U2 < of; U2++) F = v + U2, h4[F] = d3[F] ^ a[U2];
      y3 += Le;
      continue;
    }
    for (let v = 0, U2; v < m2; v++) U2 = y3 + v, s2[U2] = o2[U2] ^ u[v];
    y3 += m2;
  }
}
function cf(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o2, counterRight: s2, rounds: i2 } = Yc({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return xn(o2), xn(i2), vn(s2), vn(n2), (c2, f4, u, a, l4 = 0) => {
    ot(c2), ot(f4), ot(u);
    const d3 = u.length;
    if (a === void 0 && (a = new Uint8Array(d3)), ot(a), xn(l4), l4 < 0 || l4 >= yo) throw new Error("arx: counter overflow");
    if (a.length < d3) throw new Error(`arx: output (${a.length}) is shorter than data (${d3})`);
    const h4 = [];
    let y3 = c2.length, m2, v;
    if (y3 === 32) h4.push(m2 = Bn(c2)), v = rf;
    else if (y3 === 16 && n2) m2 = new Uint8Array(32), m2.set(c2), m2.set(c2, 16), v = nf, h4.push(m2);
    else throw new Error(`arx: invalid 32-byte key, got length=${y3}`);
    An(f4) || h4.push(f4 = Bn(f4));
    const U2 = Pt(m2);
    if (r2) {
      if (f4.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(v, U2, Pt(f4.subarray(0, 16)), U2), f4 = f4.subarray(16);
    }
    const F = 16 - o2;
    if (F !== f4.length) throw new Error(`arx: nonce must be ${F} or 16 bytes`);
    if (F !== 12) {
      const Z = new Uint8Array(12);
      Z.set(f4, s2 ? 0 : 12 - f4.length), f4 = Z, h4.push(f4);
    }
    const R2 = Pt(f4);
    return sf(t, v, U2, R2, u, a, l4, i2), Qt(...h4), a;
  };
}
var W = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var ff = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = En(e), ot(e, 32);
    const n2 = W(e, 0), r2 = W(e, 2), o2 = W(e, 4), s2 = W(e, 6), i2 = W(e, 8), c2 = W(e, 10), f4 = W(e, 12), u = W(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i2 << 12) & 255, this.r[5] = i2 >>> 1 & 8190, this.r[6] = (i2 >>> 14 | c2 << 2) & 8191, this.r[7] = (c2 >>> 11 | f4 << 5) & 8065, this.r[8] = (f4 >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;
    for (let a = 0; a < 8; a++) this.pad[a] = W(e, 16 + 2 * a);
  }
  process(e, n2, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s2, r: i2 } = this, c2 = i2[0], f4 = i2[1], u = i2[2], a = i2[3], l4 = i2[4], d3 = i2[5], h4 = i2[6], y3 = i2[7], m2 = i2[8], v = i2[9], U2 = W(e, n2 + 0), F = W(e, n2 + 2), R2 = W(e, n2 + 4), Z = W(e, n2 + 6), H = W(e, n2 + 8), j = W(e, n2 + 10), L = W(e, n2 + 12), k2 = W(e, n2 + 14);
    let O2 = s2[0] + (U2 & 8191), T2 = s2[1] + ((U2 >>> 13 | F << 3) & 8191), C4 = s2[2] + ((F >>> 10 | R2 << 6) & 8191), _ = s2[3] + ((R2 >>> 7 | Z << 9) & 8191), p = s2[4] + ((Z >>> 4 | H << 12) & 8191), b = s2[5] + (H >>> 1 & 8191), g = s2[6] + ((H >>> 14 | j << 2) & 8191), x = s2[7] + ((j >>> 11 | L << 5) & 8191), E2 = s2[8] + ((L >>> 8 | k2 << 8) & 8191), A3 = s2[9] + (k2 >>> 5 | o2), w = 0, B = w + O2 * c2 + T2 * (5 * v) + C4 * (5 * m2) + _ * (5 * y3) + p * (5 * h4);
    w = B >>> 13, B &= 8191, B += b * (5 * d3) + g * (5 * l4) + x * (5 * a) + E2 * (5 * u) + A3 * (5 * f4), w += B >>> 13, B &= 8191;
    let I2 = w + O2 * f4 + T2 * c2 + C4 * (5 * v) + _ * (5 * m2) + p * (5 * y3);
    w = I2 >>> 13, I2 &= 8191, I2 += b * (5 * h4) + g * (5 * d3) + x * (5 * l4) + E2 * (5 * a) + A3 * (5 * u), w += I2 >>> 13, I2 &= 8191;
    let N2 = w + O2 * u + T2 * f4 + C4 * c2 + _ * (5 * v) + p * (5 * m2);
    w = N2 >>> 13, N2 &= 8191, N2 += b * (5 * y3) + g * (5 * h4) + x * (5 * d3) + E2 * (5 * l4) + A3 * (5 * a), w += N2 >>> 13, N2 &= 8191;
    let D = w + O2 * a + T2 * u + C4 * f4 + _ * c2 + p * (5 * v);
    w = D >>> 13, D &= 8191, D += b * (5 * m2) + g * (5 * y3) + x * (5 * h4) + E2 * (5 * d3) + A3 * (5 * l4), w += D >>> 13, D &= 8191;
    let P2 = w + O2 * l4 + T2 * a + C4 * u + _ * f4 + p * c2;
    w = P2 >>> 13, P2 &= 8191, P2 += b * (5 * v) + g * (5 * m2) + x * (5 * y3) + E2 * (5 * h4) + A3 * (5 * d3), w += P2 >>> 13, P2 &= 8191;
    let $3 = w + O2 * d3 + T2 * l4 + C4 * a + _ * u + p * f4;
    w = $3 >>> 13, $3 &= 8191, $3 += b * c2 + g * (5 * v) + x * (5 * m2) + E2 * (5 * y3) + A3 * (5 * h4), w += $3 >>> 13, $3 &= 8191;
    let V2 = w + O2 * h4 + T2 * d3 + C4 * l4 + _ * a + p * u;
    w = V2 >>> 13, V2 &= 8191, V2 += b * f4 + g * c2 + x * (5 * v) + E2 * (5 * m2) + A3 * (5 * y3), w += V2 >>> 13, V2 &= 8191;
    let q2 = w + O2 * y3 + T2 * h4 + C4 * d3 + _ * l4 + p * a;
    w = q2 >>> 13, q2 &= 8191, q2 += b * u + g * f4 + x * c2 + E2 * (5 * v) + A3 * (5 * m2), w += q2 >>> 13, q2 &= 8191;
    let G2 = w + O2 * m2 + T2 * y3 + C4 * h4 + _ * d3 + p * l4;
    w = G2 >>> 13, G2 &= 8191, G2 += b * a + g * u + x * f4 + E2 * c2 + A3 * (5 * v), w += G2 >>> 13, G2 &= 8191;
    let M2 = w + O2 * v + T2 * m2 + C4 * y3 + _ * h4 + p * d3;
    w = M2 >>> 13, M2 &= 8191, M2 += b * l4 + g * a + x * u + E2 * f4 + A3 * c2, w += M2 >>> 13, M2 &= 8191, w = (w << 2) + w | 0, w = w + B | 0, B = w & 8191, w = w >>> 13, I2 += w, s2[0] = B, s2[1] = I2, s2[2] = N2, s2[3] = D, s2[4] = P2, s2[5] = $3, s2[6] = V2, s2[7] = q2, s2[8] = G2, s2[9] = M2;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c2 = 2; c2 < 10; c2++) e[c2] += o2, o2 = e[c2] >>> 13, e[c2] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c2 = 1; c2 < 10; c2++) r2[c2] = e[c2] + o2, o2 = r2[c2] >>> 13, r2[c2] &= 8191;
    r2[9] -= 8192;
    let s2 = (o2 ^ 1) - 1;
    for (let c2 = 0; c2 < 10; c2++) r2[c2] &= s2;
    s2 = ~s2;
    for (let c2 = 0; c2 < 10; c2++) e[c2] = e[c2] & s2 | r2[c2];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let i2 = e[0] + n2[0];
    e[0] = i2 & 65535;
    for (let c2 = 1; c2 < 8; c2++) i2 = (e[c2] + n2[c2] | 0) + (i2 >>> 16) | 0, e[c2] = i2 & 65535;
    Qt(r2);
  }
  update(e) {
    ho(this), e = En(e), ot(e);
    const { buffer: n2, blockLen: r2 } = this, o2 = e.length;
    for (let s2 = 0; s2 < o2; ) {
      const i2 = Math.min(r2 - this.pos, o2 - s2);
      if (i2 === r2) {
        for (; r2 <= o2 - s2; s2 += r2) this.process(e, s2);
        continue;
      }
      n2.set(e.subarray(s2, s2 + i2), this.pos), this.pos += i2, s2 += i2, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Qt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    ho(this), Fc(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n2[o2++] = 1; o2 < 16; o2++) n2[o2] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i2 = 0; i2 < 8; i2++) e[s2++] = r2[i2] >>> 0, e[s2++] = r2[i2] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function af(t) {
  const e = (r2, o2) => t(o2).update(En(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var uf = af((t) => new ff(t));
function lf(t, e, n2, r2, o2, s2 = 20) {
  let i2 = t[0], c2 = t[1], f4 = t[2], u = t[3], a = e[0], l4 = e[1], d3 = e[2], h4 = e[3], y3 = e[4], m2 = e[5], v = e[6], U2 = e[7], F = o2, R2 = n2[0], Z = n2[1], H = n2[2], j = i2, L = c2, k2 = f4, O2 = u, T2 = a, C4 = l4, _ = d3, p = h4, b = y3, g = m2, x = v, E2 = U2, A3 = F, w = R2, B = Z, I2 = H;
  for (let D = 0; D < s2; D += 2) j = j + T2 | 0, A3 = K2(A3 ^ j, 16), b = b + A3 | 0, T2 = K2(T2 ^ b, 12), j = j + T2 | 0, A3 = K2(A3 ^ j, 8), b = b + A3 | 0, T2 = K2(T2 ^ b, 7), L = L + C4 | 0, w = K2(w ^ L, 16), g = g + w | 0, C4 = K2(C4 ^ g, 12), L = L + C4 | 0, w = K2(w ^ L, 8), g = g + w | 0, C4 = K2(C4 ^ g, 7), k2 = k2 + _ | 0, B = K2(B ^ k2, 16), x = x + B | 0, _ = K2(_ ^ x, 12), k2 = k2 + _ | 0, B = K2(B ^ k2, 8), x = x + B | 0, _ = K2(_ ^ x, 7), O2 = O2 + p | 0, I2 = K2(I2 ^ O2, 16), E2 = E2 + I2 | 0, p = K2(p ^ E2, 12), O2 = O2 + p | 0, I2 = K2(I2 ^ O2, 8), E2 = E2 + I2 | 0, p = K2(p ^ E2, 7), j = j + C4 | 0, I2 = K2(I2 ^ j, 16), x = x + I2 | 0, C4 = K2(C4 ^ x, 12), j = j + C4 | 0, I2 = K2(I2 ^ j, 8), x = x + I2 | 0, C4 = K2(C4 ^ x, 7), L = L + _ | 0, A3 = K2(A3 ^ L, 16), E2 = E2 + A3 | 0, _ = K2(_ ^ E2, 12), L = L + _ | 0, A3 = K2(A3 ^ L, 8), E2 = E2 + A3 | 0, _ = K2(_ ^ E2, 7), k2 = k2 + p | 0, w = K2(w ^ k2, 16), b = b + w | 0, p = K2(p ^ b, 12), k2 = k2 + p | 0, w = K2(w ^ k2, 8), b = b + w | 0, p = K2(p ^ b, 7), O2 = O2 + T2 | 0, B = K2(B ^ O2, 16), g = g + B | 0, T2 = K2(T2 ^ g, 12), O2 = O2 + T2 | 0, B = K2(B ^ O2, 8), g = g + B | 0, T2 = K2(T2 ^ g, 7);
  let N2 = 0;
  r2[N2++] = i2 + j | 0, r2[N2++] = c2 + L | 0, r2[N2++] = f4 + k2 | 0, r2[N2++] = u + O2 | 0, r2[N2++] = a + T2 | 0, r2[N2++] = l4 + C4 | 0, r2[N2++] = d3 + _ | 0, r2[N2++] = h4 + p | 0, r2[N2++] = y3 + b | 0, r2[N2++] = m2 + g | 0, r2[N2++] = v + x | 0, r2[N2++] = U2 + E2 | 0, r2[N2++] = F + A3 | 0, r2[N2++] = R2 + w | 0, r2[N2++] = Z + B | 0, r2[N2++] = H + I2 | 0;
}
var df = cf(lf, { counterRight: false, counterLength: 4, allowShortKeys: false });
var hf = new Uint8Array(16);
var wo = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(hf.subarray(n2));
};
var pf = new Uint8Array(32);
function vo(t, e, n2, r2, o2) {
  const s2 = t(e, n2, pf), i2 = uf.create(s2);
  o2 && wo(i2, o2), wo(i2, r2);
  const c2 = Jc(r2.length, o2 ? o2.length : 0, true);
  i2.update(c2);
  const f4 = i2.digest();
  return Qt(s2, c2), f4;
}
var gf = (t) => (e, n2, r2) => ({ encrypt(s2, i2) {
  const c2 = s2.length;
  i2 = po(c2 + 16, i2, false), i2.set(s2);
  const f4 = i2.subarray(0, -16);
  t(e, n2, f4, f4, 1);
  const u = vo(t, e, n2, f4, r2);
  return i2.set(u, c2), Qt(u), i2;
}, decrypt(s2, i2) {
  i2 = po(s2.length - 16, i2, false);
  const c2 = s2.subarray(0, -16), f4 = s2.subarray(-16), u = vo(t, e, n2, c2, r2);
  if (!Wc(f4, u)) throw new Error("invalid tag");
  return i2.set(s2.subarray(0, -16)), t(e, n2, i2, i2, 1), Qt(u), i2;
} });
var xo = Xc({ blockSize: 64, nonceLength: 12, tagLength: 16 }, gf(df));
var Eo = class extends Re {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, Ue(e);
    const r2 = pt(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s2 = new Uint8Array(o2);
    s2.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let i2 = 0; i2 < s2.length; i2++) s2[i2] ^= 54;
    this.iHash.update(s2), this.oHash = e.create();
    for (let i2 = 0; i2 < s2.length; i2++) s2[i2] ^= 106;
    this.oHash.update(s2), lt(s2);
  }
  update(e) {
    return Nt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Nt(this), ht(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o2, destroyed: s2, blockLen: i2, outputLen: c2 } = this;
    return e = e, e.finished = o2, e.destroyed = s2, e.blockLen = i2, e.outputLen = c2, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ke = (t, e, n2) => new Eo(t, e).update(n2).digest();
ke.create = (t, e) => new Eo(t, e);
var In = Uint8Array.from([0]);
var Bo = Uint8Array.of();
var Sn = BigInt(0);
var On = BigInt(1);
function He(t, e = "") {
  if (typeof t != "boolean") {
    const n2 = e && `"${e}"`;
    throw new Error(n2 + "expected boolean, got type=" + typeof t);
  }
  return t;
}
function Kt(t, e, n2 = "") {
  const r2 = Ne(t), o2 = t == null ? void 0 : t.length, s2 = e !== void 0;
  if (!r2 || s2 && o2 !== e) {
    const i2 = n2 && `"${n2}" `, c2 = s2 ? ` of length ${e}` : "", f4 = r2 ? `length=${o2}` : `type=${typeof t}`;
    throw new Error(i2 + "expected Uint8Array" + c2 + ", got " + f4);
  }
  return t;
}
function De(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Ao(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Sn : BigInt("0x" + t);
}
function Ve(t) {
  return Ao(Jt(t));
}
function Me(t) {
  return ht(t), Ao(Jt(Uint8Array.from(t).reverse()));
}
function Nn(t, e) {
  return _e(t.toString(16).padStart(e * 2, "0"));
}
function Un(t, e) {
  return Nn(t, e).reverse();
}
function tt(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = _e(e);
  } catch (s2) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (Ne(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n2 == "number" && o2 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o2);
  return r2;
}
var _n = (t) => typeof t == "bigint" && Sn <= t;
function wf(t, e, n2) {
  return _n(t) && _n(e) && _n(n2) && e <= t && t < n2;
}
function Rn(t, e, n2, r2) {
  if (!wf(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function Io(t) {
  let e;
  for (e = 0; t > Sn; t >>= On, e += 1) ;
  return e;
}
var ye = (t) => (On << BigInt(t)) - On;
function vf(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  const r2 = (h4) => new Uint8Array(h4), o2 = (h4) => Uint8Array.of(h4);
  let s2 = r2(t), i2 = r2(t), c2 = 0;
  const f4 = () => {
    s2.fill(1), i2.fill(0), c2 = 0;
  }, u = (...h4) => n2(i2, s2, ...h4), a = (h4 = r2(0)) => {
    i2 = u(o2(0), h4), s2 = u(), h4.length !== 0 && (i2 = u(o2(1), h4), s2 = u());
  }, l4 = () => {
    if (c2++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let h4 = 0;
    const y3 = [];
    for (; h4 < e; ) {
      s2 = u();
      const m2 = s2.slice();
      y3.push(m2), h4 += s2.length;
    }
    return _t(...y3);
  };
  return (h4, y3) => {
    f4(), a(h4);
    let m2;
    for (; !(m2 = y3(l4())); ) a();
    return f4(), m2;
  };
}
function Ke(t, e, n2 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r2(o2, s2, i2) {
    const c2 = t[o2];
    if (i2 && c2 === void 0) return;
    const f4 = typeof c2;
    if (f4 !== s2 || c2 === null) throw new Error(`param "${o2}" is invalid: expected ${s2}, got ${f4}`);
  }
  Object.entries(e).forEach(([o2, s2]) => r2(o2, s2, false)), Object.entries(n2).forEach(([o2, s2]) => r2(o2, s2, true));
}
function So(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o2 = e.get(n2);
    if (o2 !== void 0) return o2;
    const s2 = t(n2, ...r2);
    return e.set(n2, s2), s2;
  };
}
var st = BigInt(0);
var nt = BigInt(1);
var qt = BigInt(2);
var Oo = BigInt(3);
var No = BigInt(4);
var Uo = BigInt(5);
var xf = BigInt(7);
var _o = BigInt(8);
var Ef = BigInt(9);
var Ro = BigInt(16);
function ct(t, e) {
  const n2 = t % e;
  return n2 >= st ? n2 : e + n2;
}
function gt(t, e, n2) {
  let r2 = t;
  for (; e-- > st; ) r2 *= r2, r2 %= n2;
  return r2;
}
function $o(t, e) {
  if (t === st) throw new Error("invert: expected non-zero number");
  if (e <= st) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = ct(t, e), r2 = e, o2 = st, s2 = nt;
  for (; n2 !== st; ) {
    const c2 = r2 / n2, f4 = r2 % n2, u = o2 - s2 * c2;
    r2 = n2, n2 = f4, o2 = s2, s2 = u;
  }
  if (r2 !== nt) throw new Error("invert: does not exist");
  return ct(o2, e);
}
function $n(t, e, n2) {
  if (!t.eql(t.sqr(e), n2)) throw new Error("Cannot find square root");
}
function To(t, e) {
  const n2 = (t.ORDER + nt) / No, r2 = t.pow(e, n2);
  return $n(t, r2, e), r2;
}
function Bf(t, e) {
  const n2 = (t.ORDER - Uo) / _o, r2 = t.mul(e, qt), o2 = t.pow(r2, n2), s2 = t.mul(e, o2), i2 = t.mul(t.mul(s2, qt), o2), c2 = t.mul(s2, t.sub(i2, t.ONE));
  return $n(t, c2, e), c2;
}
function Af(t) {
  const e = Ht(t), n2 = Co(t), r2 = n2(e, e.neg(e.ONE)), o2 = n2(e, r2), s2 = n2(e, e.neg(r2)), i2 = (t + xf) / Ro;
  return (c2, f4) => {
    let u = c2.pow(f4, i2), a = c2.mul(u, r2);
    const l4 = c2.mul(u, o2), d3 = c2.mul(u, s2), h4 = c2.eql(c2.sqr(a), f4), y3 = c2.eql(c2.sqr(l4), f4);
    u = c2.cmov(u, a, h4), a = c2.cmov(d3, l4, y3);
    const m2 = c2.eql(c2.sqr(a), f4), v = c2.cmov(u, a, m2);
    return $n(c2, v, f4), v;
  };
}
function Co(t) {
  if (t < Oo) throw new Error("sqrt is not defined for small field");
  let e = t - nt, n2 = 0;
  for (; e % qt === st; ) e /= qt, n2++;
  let r2 = qt;
  const o2 = Ht(t);
  for (; Lo(o2, r2) === 1; ) if (r2++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n2 === 1) return To;
  let s2 = o2.pow(r2, e);
  const i2 = (e + nt) / qt;
  return function(f4, u) {
    if (f4.is0(u)) return u;
    if (Lo(f4, u) !== 1) throw new Error("Cannot find square root");
    let a = n2, l4 = f4.mul(f4.ONE, s2), d3 = f4.pow(u, e), h4 = f4.pow(u, i2);
    for (; !f4.eql(d3, f4.ONE); ) {
      if (f4.is0(d3)) return f4.ZERO;
      let y3 = 1, m2 = f4.sqr(d3);
      for (; !f4.eql(m2, f4.ONE); ) if (y3++, m2 = f4.sqr(m2), y3 === a) throw new Error("Cannot find square root");
      const v = nt << BigInt(a - y3 - 1), U2 = f4.pow(l4, v);
      a = y3, l4 = f4.sqr(U2), d3 = f4.mul(d3, l4), h4 = f4.mul(h4, U2);
    }
    return h4;
  };
}
function If(t) {
  return t % No === Oo ? To : t % _o === Uo ? Bf : t % Ro === Ef ? Af(t) : Co(t);
}
var Sf = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Of(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n2 = Sf.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Ke(t, n2), t;
}
function Nf(t, e, n2) {
  if (n2 < st) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === st) return t.ONE;
  if (n2 === nt) return e;
  let r2 = t.ONE, o2 = e;
  for (; n2 > st; ) n2 & nt && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n2 >>= nt;
  return r2;
}
function jo(t, e, n2 = false) {
  const r2 = new Array(e.length).fill(n2 ? t.ZERO : void 0), o2 = e.reduce((i2, c2, f4) => t.is0(c2) ? i2 : (r2[f4] = i2, t.mul(i2, c2)), t.ONE), s2 = t.inv(o2);
  return e.reduceRight((i2, c2, f4) => t.is0(c2) ? i2 : (r2[f4] = t.mul(i2, r2[f4]), t.mul(i2, c2)), s2), r2;
}
function Lo(t, e) {
  const n2 = (t.ORDER - nt) / qt, r2 = t.pow(e, n2), o2 = t.eql(r2, t.ONE), s2 = t.eql(r2, t.ZERO), i2 = t.eql(r2, t.neg(t.ONE));
  if (!o2 && !s2 && !i2) throw new Error("invalid Legendre symbol result");
  return o2 ? 1 : s2 ? 0 : -1;
}
function ko(t, e) {
  e !== void 0 && mt(e);
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Ht(t, e, n2 = false, r2 = {}) {
  if (t <= st) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o2, s2, i2 = false, c2;
  if (typeof e == "object" && e != null) {
    if (r2.sqrt || n2) throw new Error("cannot specify opts in two arguments");
    const d3 = e;
    d3.BITS && (o2 = d3.BITS), d3.sqrt && (s2 = d3.sqrt), typeof d3.isLE == "boolean" && (n2 = d3.isLE), typeof d3.modFromBytes == "boolean" && (i2 = d3.modFromBytes), c2 = d3.allowedLengths;
  } else typeof e == "number" && (o2 = e), r2.sqrt && (s2 = r2.sqrt);
  const { nBitLength: f4, nByteLength: u } = ko(t, o2);
  if (u > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a;
  const l4 = Object.freeze({ ORDER: t, isLE: n2, BITS: f4, BYTES: u, MASK: ye(f4), ZERO: st, ONE: nt, allowedLengths: c2, create: (d3) => ct(d3, t), isValid: (d3) => {
    if (typeof d3 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof d3);
    return st <= d3 && d3 < t;
  }, is0: (d3) => d3 === st, isValidNot0: (d3) => !l4.is0(d3) && l4.isValid(d3), isOdd: (d3) => (d3 & nt) === nt, neg: (d3) => ct(-d3, t), eql: (d3, h4) => d3 === h4, sqr: (d3) => ct(d3 * d3, t), add: (d3, h4) => ct(d3 + h4, t), sub: (d3, h4) => ct(d3 - h4, t), mul: (d3, h4) => ct(d3 * h4, t), pow: (d3, h4) => Nf(l4, d3, h4), div: (d3, h4) => ct(d3 * $o(h4, t), t), sqrN: (d3) => d3 * d3, addN: (d3, h4) => d3 + h4, subN: (d3, h4) => d3 - h4, mulN: (d3, h4) => d3 * h4, inv: (d3) => $o(d3, t), sqrt: s2 || ((d3) => (a || (a = If(t)), a(l4, d3))), toBytes: (d3) => n2 ? Un(d3, u) : Nn(d3, u), fromBytes: (d3, h4 = true) => {
    if (c2) {
      if (!c2.includes(d3.length) || d3.length > u) throw new Error("Field.fromBytes: expected " + c2 + " bytes, got " + d3.length);
      const m2 = new Uint8Array(u);
      m2.set(d3, n2 ? 0 : m2.length - d3.length), d3 = m2;
    }
    if (d3.length !== u) throw new Error("Field.fromBytes: expected " + u + " bytes, got " + d3.length);
    let y3 = n2 ? Me(d3) : Ve(d3);
    if (i2 && (y3 = ct(y3, t)), !h4 && !l4.isValid(y3)) throw new Error("invalid field element: outside of range 0..ORDER");
    return y3;
  }, invertBatch: (d3) => jo(l4, d3), cmov: (d3, h4, y3) => y3 ? h4 : d3 });
  return Object.freeze(l4);
}
function Po(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Ho(t) {
  const e = Po(t);
  return e + Math.ceil(e / 2);
}
function Uf(t, e, n2 = false) {
  const r2 = t.length, o2 = Po(e), s2 = Ho(e);
  if (r2 < 16 || r2 < s2 || r2 > 1024) throw new Error("expected " + s2 + "-1024 bytes of input, got " + r2);
  const i2 = n2 ? Me(t) : Ve(t), c2 = ct(i2, e - nt) + nt;
  return n2 ? Un(c2, o2) : Nn(c2, o2);
}
var te = BigInt(0);
var Ft = BigInt(1);
function qe(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function Tn(t, e) {
  const n2 = jo(t.Fp, e.map((r2) => r2.Z));
  return e.map((r2, o2) => t.fromAffine(r2.toAffine(n2[o2])));
}
function Do(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Cn(t, e) {
  Do(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1), o2 = 2 ** t, s2 = ye(t), i2 = BigInt(t);
  return { windows: n2, windowSize: r2, mask: s2, maxNumber: o2, shiftBy: i2 };
}
function Vo(t, e, n2) {
  const { windowSize: r2, mask: o2, maxNumber: s2, shiftBy: i2 } = n2;
  let c2 = Number(t & o2), f4 = t >> i2;
  c2 > r2 && (c2 -= s2, f4 += Ft);
  const u = e * r2, a = u + Math.abs(c2) - 1, l4 = c2 === 0, d3 = c2 < 0, h4 = e % 2 !== 0;
  return { nextN: f4, offset: a, isZero: l4, isNeg: d3, isNegF: h4, offsetF: u };
}
function _f(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function Rf(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var jn = /* @__PURE__ */ new WeakMap();
var Mo = /* @__PURE__ */ new WeakMap();
function Ln(t) {
  return Mo.get(t) || 1;
}
function Ko(t) {
  if (t !== te) throw new Error("invalid wNAF");
}
var $f = class {
  constructor(e, n2) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = n2;
  }
  _unsafeLadder(e, n2, r2 = this.ZERO) {
    let o2 = e;
    for (; n2 > te; ) n2 & Ft && (r2 = r2.add(o2)), o2 = o2.double(), n2 >>= Ft;
    return r2;
  }
  precomputeWindow(e, n2) {
    const { windows: r2, windowSize: o2 } = Cn(n2, this.bits), s2 = [];
    let i2 = e, c2 = i2;
    for (let f4 = 0; f4 < r2; f4++) {
      c2 = i2, s2.push(c2);
      for (let u = 1; u < o2; u++) c2 = c2.add(i2), s2.push(c2);
      i2 = c2.double();
    }
    return s2;
  }
  wNAF(e, n2, r2) {
    if (!this.Fn.isValid(r2)) throw new Error("invalid scalar");
    let o2 = this.ZERO, s2 = this.BASE;
    const i2 = Cn(e, this.bits);
    for (let c2 = 0; c2 < i2.windows; c2++) {
      const { nextN: f4, offset: u, isZero: a, isNeg: l4, isNegF: d3, offsetF: h4 } = Vo(r2, c2, i2);
      r2 = f4, a ? s2 = s2.add(qe(d3, n2[h4])) : o2 = o2.add(qe(l4, n2[u]));
    }
    return Ko(r2), { p: o2, f: s2 };
  }
  wNAFUnsafe(e, n2, r2, o2 = this.ZERO) {
    const s2 = Cn(e, this.bits);
    for (let i2 = 0; i2 < s2.windows && r2 !== te; i2++) {
      const { nextN: c2, offset: f4, isZero: u, isNeg: a } = Vo(r2, i2, s2);
      if (r2 = c2, !u) {
        const l4 = n2[f4];
        o2 = o2.add(a ? l4.negate() : l4);
      }
    }
    return Ko(r2), o2;
  }
  getPrecomputes(e, n2, r2) {
    let o2 = jn.get(n2);
    return o2 || (o2 = this.precomputeWindow(n2, e), e !== 1 && (typeof r2 == "function" && (o2 = r2(o2)), jn.set(n2, o2))), o2;
  }
  cached(e, n2, r2) {
    const o2 = Ln(e);
    return this.wNAF(o2, this.getPrecomputes(o2, e, r2), n2);
  }
  unsafe(e, n2, r2, o2) {
    const s2 = Ln(e);
    return s2 === 1 ? this._unsafeLadder(e, n2, o2) : this.wNAFUnsafe(s2, this.getPrecomputes(s2, e, r2), n2, o2);
  }
  createCache(e, n2) {
    Do(n2, this.bits), Mo.set(e, n2), jn.delete(e);
  }
  hasCache(e) {
    return Ln(e) !== 1;
  }
};
function Tf(t, e, n2, r2) {
  let o2 = e, s2 = t.ZERO, i2 = t.ZERO;
  for (; n2 > te || r2 > te; ) n2 & Ft && (s2 = s2.add(o2)), r2 & Ft && (i2 = i2.add(o2)), o2 = o2.double(), n2 >>= Ft, r2 >>= Ft;
  return { p1: s2, p2: i2 };
}
function Cf(t, e, n2, r2) {
  _f(n2, t), Rf(r2, e);
  const o2 = n2.length, s2 = r2.length;
  if (o2 !== s2) throw new Error("arrays of points and scalars must have equal length");
  const i2 = t.ZERO, c2 = Io(BigInt(o2));
  let f4 = 1;
  c2 > 12 ? f4 = c2 - 3 : c2 > 4 ? f4 = c2 - 2 : c2 > 0 && (f4 = 2);
  const u = ye(f4), a = new Array(Number(u) + 1).fill(i2), l4 = Math.floor((e.BITS - 1) / f4) * f4;
  let d3 = i2;
  for (let h4 = l4; h4 >= 0; h4 -= f4) {
    a.fill(i2);
    for (let m2 = 0; m2 < s2; m2++) {
      const v = r2[m2], U2 = Number(v >> BigInt(h4) & u);
      a[U2] = a[U2].add(n2[m2]);
    }
    let y3 = i2;
    for (let m2 = a.length - 1, v = i2; m2 > 0; m2--) v = v.add(a[m2]), y3 = y3.add(v);
    if (d3 = d3.add(y3), h4 !== 0) for (let m2 = 0; m2 < f4; m2++) d3 = d3.double();
  }
  return d3;
}
function qo(t, e, n2) {
  if (e) {
    if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Of(e), e;
  } else return Ht(t, { isLE: n2 });
}
function jf(t, e, n2 = {}, r2) {
  if (r2 === void 0 && (r2 = t === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f4 of ["p", "n", "h"]) {
    const u = e[f4];
    if (!(typeof u == "bigint" && u > te)) throw new Error(`CURVE.${f4} must be positive bigint`);
  }
  const o2 = qo(e.p, n2.Fp, r2), s2 = qo(e.n, n2.Fn, r2), c2 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f4 of c2) if (!o2.isValid(e[f4])) throw new Error(`CURVE.${f4} must be valid field element of CURVE.Fp`);
  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: o2, Fn: s2 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8), kr("HashToScalar-");
var me = BigInt(0);
var ee = BigInt(1);
var Fe = BigInt(2);
function Lf(t) {
  return Ke(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function kf(t) {
  const e = Lf(t), { P: n2, type: r2, adjustScalarBytes: o2, powPminus2: s2, randomBytes: i2 } = e, c2 = r2 === "x25519";
  if (!c2 && r2 !== "x448") throw new Error("invalid type");
  const f4 = i2 || Mt, u = c2 ? 255 : 448, a = c2 ? 32 : 56, l4 = BigInt(c2 ? 9 : 5), d3 = BigInt(c2 ? 121665 : 39081), h4 = c2 ? Fe ** BigInt(254) : Fe ** BigInt(447), y3 = c2 ? BigInt(8) * Fe ** BigInt(251) - ee : BigInt(4) * Fe ** BigInt(445) - ee, m2 = h4 + y3 + ee, v = (p) => ct(p, n2), U2 = F(l4);
  function F(p) {
    return Un(v(p), a);
  }
  function R2(p) {
    const b = tt("u coordinate", p, a);
    return c2 && (b[31] &= 127), v(Me(b));
  }
  function Z(p) {
    return Me(o2(tt("scalar", p, a)));
  }
  function H(p, b) {
    const g = k2(R2(b), Z(p));
    if (g === me) throw new Error("invalid private or public key received");
    return F(g);
  }
  function j(p) {
    return H(p, U2);
  }
  function L(p, b, g) {
    const x = v(p * (b - g));
    return b = v(b - x), g = v(g + x), { x_2: b, x_3: g };
  }
  function k2(p, b) {
    Rn("u", p, me, n2), Rn("scalar", b, h4, m2);
    const g = b, x = p;
    let E2 = ee, A3 = me, w = p, B = ee, I2 = me;
    for (let D = BigInt(u - 1); D >= me; D--) {
      const P2 = g >> D & ee;
      I2 ^= P2, { x_2: E2, x_3: w } = L(I2, E2, w), { x_2: A3, x_3: B } = L(I2, A3, B), I2 = P2;
      const $3 = E2 + A3, V2 = v($3 * $3), q2 = E2 - A3, G2 = v(q2 * q2), M2 = V2 - G2, Y2 = w + B, Yt = w - B, ce = v(Yt * $3), fe2 = v(Y2 * q2), Qn = ce + fe2, tr = ce - fe2;
      w = v(Qn * Qn), B = v(x * v(tr * tr)), E2 = v(V2 * G2), A3 = v(M2 * (V2 + v(d3 * M2)));
    }
    ({ x_2: E2, x_3: w } = L(I2, E2, w)), { x_2: A3, x_3: B } = L(I2, A3, B);
    const N2 = s2(A3);
    return v(E2 * N2);
  }
  const O2 = { secretKey: a, publicKey: a, seed: a }, T2 = (p = f4(a)) => (ht(p, O2.seed), p);
  function C4(p) {
    const b = T2(p);
    return { secretKey: b, publicKey: j(b) };
  }
  return { keygen: C4, getSharedSecret: (p, b) => H(p, b), getPublicKey: (p) => j(p), scalarMult: H, scalarMultBase: j, utils: { randomSecretKey: T2, randomPrivateKey: T2 }, GuBytes: U2.slice(), lengths: O2 };
}
var Pf = BigInt(1);
var Fo = BigInt(2);
var Hf = BigInt(3);
var Df = BigInt(5);
var Vf = BigInt(8);
var Zo = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var Mf = { p: Zo, n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Vf, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Kf(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s2 = Zo, c2 = t * t % s2 * t % s2, f4 = gt(c2, Fo, s2) * c2 % s2, u = gt(f4, Pf, s2) * t % s2, a = gt(u, Df, s2) * u % s2, l4 = gt(a, e, s2) * a % s2, d3 = gt(l4, n2, s2) * l4 % s2, h4 = gt(d3, r2, s2) * d3 % s2, y3 = gt(h4, o2, s2) * h4 % s2, m2 = gt(y3, o2, s2) * h4 % s2, v = gt(m2, e, s2) * a % s2;
  return { pow_p_5_8: gt(v, Fo, s2) * t % s2, b2: c2 };
}
function qf(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Ff = Ht(Mf.p, { isLE: true });
var kn = (() => {
  const t = Ff.ORDER;
  return kf({ P: t, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: n2, b2: r2 } = Kf(e);
    return ct(gt(n2, Hf, t) * r2, t);
  }, adjustScalarBytes: qf });
})();
var Go = (t, e) => (t + (t >= 0 ? e : -e) / zo) / e;
function Zf(t, e, n2) {
  const [[r2, o2], [s2, i2]] = e, c2 = Go(i2 * t, n2), f4 = Go(-o2 * t, n2);
  let u = t - c2 * r2 - f4 * s2, a = -c2 * o2 - f4 * i2;
  const l4 = u < Et, d3 = a < Et;
  l4 && (u = -u), d3 && (a = -a);
  const h4 = ye(Math.ceil(Io(n2) / 2)) + ne;
  if (u < Et || u >= h4 || a < Et || a >= h4) throw new Error("splitScalar (endomorphism): failed, k=" + t);
  return { k1neg: l4, k1: u, k2neg: d3, k2: a };
}
function Pn(t) {
  if (!["compact", "recovered", "der"].includes(t)) throw new Error('Signature format must be "compact", "recovered", or "der"');
  return t;
}
function Hn(t, e) {
  const n2 = {};
  for (let r2 of Object.keys(e)) n2[r2] = t[r2] === void 0 ? e[r2] : t[r2];
  return He(n2.lowS, "lowS"), He(n2.prehash, "prehash"), n2.format !== void 0 && Pn(n2.format), n2;
}
var Gf = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var xt = { Err: Gf, _tlv: { encode: (t, e) => {
  const { Err: n2 } = xt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = De(r2);
  if (o2.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const s2 = r2 > 127 ? De(o2.length / 2 | 128) : "";
  return De(t) + s2 + o2 + e;
}, decode(t, e) {
  const { Err: n2 } = xt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o2 = e[r2++], s2 = !!(o2 & 128);
  let i2 = 0;
  if (!s2) i2 = o2;
  else {
    const f4 = o2 & 127;
    if (!f4) throw new n2("tlv.decode(long): indefinite length not supported");
    if (f4 > 4) throw new n2("tlv.decode(long): byte length is too big");
    const u = e.subarray(r2, r2 + f4);
    if (u.length !== f4) throw new n2("tlv.decode: length bytes not complete");
    if (u[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const a of u) i2 = i2 << 8 | a;
    if (r2 += f4, i2 < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const c2 = e.subarray(r2, r2 + i2);
  if (c2.length !== i2) throw new n2("tlv.decode: wrong value length");
  return { v: c2, l: e.subarray(r2 + i2) };
} }, _int: { encode(t) {
  const { Err: e } = xt;
  if (t < Et) throw new e("integer: negative integers are not allowed");
  let n2 = De(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = xt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Ve(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = xt, o2 = tt("signature", t), { v: s2, l: i2 } = r2.decode(48, o2);
  if (i2.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c2, l: f4 } = r2.decode(2, s2), { v: u, l: a } = r2.decode(2, f4);
  if (a.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(c2), s: n2.decode(u) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = xt, r2 = e.encode(2, n2.encode(t.r)), o2 = e.encode(2, n2.encode(t.s)), s2 = r2 + o2;
  return e.encode(48, s2);
} };
var Et = BigInt(0);
var ne = BigInt(1);
var zo = BigInt(2);
var Ze = BigInt(3);
var zf = BigInt(4);
function re(t, e) {
  const { BYTES: n2 } = t;
  let r2;
  if (typeof e == "bigint") r2 = e;
  else {
    let o2 = tt("private key", e);
    try {
      r2 = t.fromBytes(o2);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${n2}, got ${typeof e}`);
    }
  }
  if (!t.isValidNot0(r2)) throw new Error("invalid private key: out of range [1..N-1]");
  return r2;
}
function Yf(t, e = {}) {
  const n2 = jf("weierstrass", t, e), { Fp: r2, Fn: o2 } = n2;
  let s2 = n2.CURVE;
  const { h: i2, n: c2 } = s2;
  Ke(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: f4 } = e;
  if (f4 && (!r2.is0(s2.a) || typeof f4.beta != "bigint" || !Array.isArray(f4.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u = Wo(r2, o2);
  function a() {
    if (!r2.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function l4(_, p, b) {
    const { x: g, y: x } = p.toAffine(), E2 = r2.toBytes(g);
    if (He(b, "isCompressed"), b) {
      a();
      const A3 = !r2.isOdd(x);
      return _t(Yo(A3), E2);
    } else return _t(Uint8Array.of(4), E2, r2.toBytes(x));
  }
  function d3(_) {
    Kt(_, void 0, "Point");
    const { publicKey: p, publicKeyUncompressed: b } = u, g = _.length, x = _[0], E2 = _.subarray(1);
    if (g === p && (x === 2 || x === 3)) {
      const A3 = r2.fromBytes(E2);
      if (!r2.isValid(A3)) throw new Error("bad point: is not on curve, wrong x");
      const w = m2(A3);
      let B;
      try {
        B = r2.sqrt(w);
      } catch (D) {
        const P2 = D instanceof Error ? ": " + D.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + P2);
      }
      a();
      const I2 = r2.isOdd(B);
      return (x & 1) === 1 !== I2 && (B = r2.neg(B)), { x: A3, y: B };
    } else if (g === b && x === 4) {
      const A3 = r2.BYTES, w = r2.fromBytes(E2.subarray(0, A3)), B = r2.fromBytes(E2.subarray(A3, A3 * 2));
      if (!v(w, B)) throw new Error("bad point: is not on curve");
      return { x: w, y: B };
    } else throw new Error(`bad point: got length ${g}, expected compressed=${p} or uncompressed=${b}`);
  }
  const h4 = e.toBytes || l4, y3 = e.fromBytes || d3;
  function m2(_) {
    const p = r2.sqr(_), b = r2.mul(p, _);
    return r2.add(r2.add(b, r2.mul(_, s2.a)), s2.b);
  }
  function v(_, p) {
    const b = r2.sqr(p), g = m2(_);
    return r2.eql(b, g);
  }
  if (!v(s2.Gx, s2.Gy)) throw new Error("bad curve params: generator point");
  const U2 = r2.mul(r2.pow(s2.a, Ze), zf), F = r2.mul(r2.sqr(s2.b), BigInt(27));
  if (r2.is0(r2.add(U2, F))) throw new Error("bad curve params: a or b");
  function R2(_, p, b = false) {
    if (!r2.isValid(p) || b && r2.is0(p)) throw new Error(`bad point coordinate ${_}`);
    return p;
  }
  function Z(_) {
    if (!(_ instanceof O2)) throw new Error("ProjectivePoint expected");
  }
  function H(_) {
    if (!f4 || !f4.basises) throw new Error("no endo");
    return Zf(_, f4.basises, o2.ORDER);
  }
  const j = So((_, p) => {
    const { X: b, Y: g, Z: x } = _;
    if (r2.eql(x, r2.ONE)) return { x: b, y: g };
    const E2 = _.is0();
    p == null && (p = E2 ? r2.ONE : r2.inv(x));
    const A3 = r2.mul(b, p), w = r2.mul(g, p), B = r2.mul(x, p);
    if (E2) return { x: r2.ZERO, y: r2.ZERO };
    if (!r2.eql(B, r2.ONE)) throw new Error("invZ was invalid");
    return { x: A3, y: w };
  }), L = So((_) => {
    if (_.is0()) {
      if (e.allowInfinityPoint && !r2.is0(_.Y)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: p, y: b } = _.toAffine();
    if (!r2.isValid(p) || !r2.isValid(b)) throw new Error("bad point: x or y not field elements");
    if (!v(p, b)) throw new Error("bad point: equation left != right");
    if (!_.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function k2(_, p, b, g, x) {
    return b = new O2(r2.mul(b.X, _), b.Y, b.Z), p = qe(g, p), b = qe(x, b), p.add(b);
  }
  class O2 {
    constructor(p, b, g) {
      this.X = R2("x", p), this.Y = R2("y", b, true), this.Z = R2("z", g), Object.freeze(this);
    }
    static CURVE() {
      return s2;
    }
    static fromAffine(p) {
      const { x: b, y: g } = p || {};
      if (!p || !r2.isValid(b) || !r2.isValid(g)) throw new Error("invalid affine point");
      if (p instanceof O2) throw new Error("projective point not allowed");
      return r2.is0(b) && r2.is0(g) ? O2.ZERO : new O2(b, g, r2.ONE);
    }
    static fromBytes(p) {
      const b = O2.fromAffine(y3(Kt(p, void 0, "point")));
      return b.assertValidity(), b;
    }
    static fromHex(p) {
      return O2.fromBytes(tt("pointHex", p));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(p = 8, b = true) {
      return C4.createCache(this, p), b || this.multiply(Ze), this;
    }
    assertValidity() {
      L(this);
    }
    hasEvenY() {
      const { y: p } = this.toAffine();
      if (!r2.isOdd) throw new Error("Field doesn't support isOdd");
      return !r2.isOdd(p);
    }
    equals(p) {
      Z(p);
      const { X: b, Y: g, Z: x } = this, { X: E2, Y: A3, Z: w } = p, B = r2.eql(r2.mul(b, w), r2.mul(E2, x)), I2 = r2.eql(r2.mul(g, w), r2.mul(A3, x));
      return B && I2;
    }
    negate() {
      return new O2(this.X, r2.neg(this.Y), this.Z);
    }
    double() {
      const { a: p, b } = s2, g = r2.mul(b, Ze), { X: x, Y: E2, Z: A3 } = this;
      let w = r2.ZERO, B = r2.ZERO, I2 = r2.ZERO, N2 = r2.mul(x, x), D = r2.mul(E2, E2), P2 = r2.mul(A3, A3), $3 = r2.mul(x, E2);
      return $3 = r2.add($3, $3), I2 = r2.mul(x, A3), I2 = r2.add(I2, I2), w = r2.mul(p, I2), B = r2.mul(g, P2), B = r2.add(w, B), w = r2.sub(D, B), B = r2.add(D, B), B = r2.mul(w, B), w = r2.mul($3, w), I2 = r2.mul(g, I2), P2 = r2.mul(p, P2), $3 = r2.sub(N2, P2), $3 = r2.mul(p, $3), $3 = r2.add($3, I2), I2 = r2.add(N2, N2), N2 = r2.add(I2, N2), N2 = r2.add(N2, P2), N2 = r2.mul(N2, $3), B = r2.add(B, N2), P2 = r2.mul(E2, A3), P2 = r2.add(P2, P2), N2 = r2.mul(P2, $3), w = r2.sub(w, N2), I2 = r2.mul(P2, D), I2 = r2.add(I2, I2), I2 = r2.add(I2, I2), new O2(w, B, I2);
    }
    add(p) {
      Z(p);
      const { X: b, Y: g, Z: x } = this, { X: E2, Y: A3, Z: w } = p;
      let B = r2.ZERO, I2 = r2.ZERO, N2 = r2.ZERO;
      const D = s2.a, P2 = r2.mul(s2.b, Ze);
      let $3 = r2.mul(b, E2), V2 = r2.mul(g, A3), q2 = r2.mul(x, w), G2 = r2.add(b, g), M2 = r2.add(E2, A3);
      G2 = r2.mul(G2, M2), M2 = r2.add($3, V2), G2 = r2.sub(G2, M2), M2 = r2.add(b, x);
      let Y2 = r2.add(E2, w);
      return M2 = r2.mul(M2, Y2), Y2 = r2.add($3, q2), M2 = r2.sub(M2, Y2), Y2 = r2.add(g, x), B = r2.add(A3, w), Y2 = r2.mul(Y2, B), B = r2.add(V2, q2), Y2 = r2.sub(Y2, B), N2 = r2.mul(D, M2), B = r2.mul(P2, q2), N2 = r2.add(B, N2), B = r2.sub(V2, N2), N2 = r2.add(V2, N2), I2 = r2.mul(B, N2), V2 = r2.add($3, $3), V2 = r2.add(V2, $3), q2 = r2.mul(D, q2), M2 = r2.mul(P2, M2), V2 = r2.add(V2, q2), q2 = r2.sub($3, q2), q2 = r2.mul(D, q2), M2 = r2.add(M2, q2), $3 = r2.mul(V2, M2), I2 = r2.add(I2, $3), $3 = r2.mul(Y2, M2), B = r2.mul(G2, B), B = r2.sub(B, $3), $3 = r2.mul(G2, V2), N2 = r2.mul(Y2, N2), N2 = r2.add(N2, $3), new O2(B, I2, N2);
    }
    subtract(p) {
      return this.add(p.negate());
    }
    is0() {
      return this.equals(O2.ZERO);
    }
    multiply(p) {
      const { endo: b } = e;
      if (!o2.isValidNot0(p)) throw new Error("invalid scalar: out of range");
      let g, x;
      const E2 = (A3) => C4.cached(this, A3, (w) => Tn(O2, w));
      if (b) {
        const { k1neg: A3, k1: w, k2neg: B, k2: I2 } = H(p), { p: N2, f: D } = E2(w), { p: P2, f: $3 } = E2(I2);
        x = D.add($3), g = k2(b.beta, N2, P2, A3, B);
      } else {
        const { p: A3, f: w } = E2(p);
        g = A3, x = w;
      }
      return Tn(O2, [g, x])[0];
    }
    multiplyUnsafe(p) {
      const { endo: b } = e, g = this;
      if (!o2.isValid(p)) throw new Error("invalid scalar: out of range");
      if (p === Et || g.is0()) return O2.ZERO;
      if (p === ne) return g;
      if (C4.hasCache(this)) return this.multiply(p);
      if (b) {
        const { k1neg: x, k1: E2, k2neg: A3, k2: w } = H(p), { p1: B, p2: I2 } = Tf(O2, g, E2, w);
        return k2(b.beta, B, I2, x, A3);
      } else return C4.unsafe(g, p);
    }
    multiplyAndAddUnsafe(p, b, g) {
      const x = this.multiplyUnsafe(b).add(p.multiplyUnsafe(g));
      return x.is0() ? void 0 : x;
    }
    toAffine(p) {
      return j(this, p);
    }
    isTorsionFree() {
      const { isTorsionFree: p } = e;
      return i2 === ne ? true : p ? p(O2, this) : C4.unsafe(this, c2).is0();
    }
    clearCofactor() {
      const { clearCofactor: p } = e;
      return i2 === ne ? this : p ? p(O2, this) : this.multiplyUnsafe(i2);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i2).is0();
    }
    toBytes(p = true) {
      return He(p, "isCompressed"), this.assertValidity(), h4(O2, this, p);
    }
    toHex(p = true) {
      return Jt(this.toBytes(p));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(p = true) {
      return this.toBytes(p);
    }
    _setWindowSize(p) {
      this.precompute(p);
    }
    static normalizeZ(p) {
      return Tn(O2, p);
    }
    static msm(p, b) {
      return Cf(O2, o2, p, b);
    }
    static fromPrivateKey(p) {
      return O2.BASE.multiply(re(o2, p));
    }
  }
  O2.BASE = new O2(s2.Gx, s2.Gy, r2.ONE), O2.ZERO = new O2(r2.ZERO, r2.ONE, r2.ZERO), O2.Fp = r2, O2.Fn = o2;
  const T2 = o2.BITS, C4 = new $f(O2, e.endo ? Math.ceil(T2 / 2) : T2);
  return O2.BASE.precompute(8), O2;
}
function Yo(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Wo(t, e) {
  return { secretKey: e.BYTES, publicKey: 1 + t.BYTES, publicKeyUncompressed: 1 + 2 * t.BYTES, publicKeyHasPrefix: true, signature: 2 * e.BYTES };
}
function Wf(t, e = {}) {
  const { Fn: n2 } = t, r2 = e.randomBytes || Mt, o2 = Object.assign(Wo(t.Fp, n2), { seed: Ho(n2.ORDER) });
  function s2(h4) {
    try {
      return !!re(n2, h4);
    } catch {
      return false;
    }
  }
  function i2(h4, y3) {
    const { publicKey: m2, publicKeyUncompressed: v } = o2;
    try {
      const U2 = h4.length;
      return y3 === true && U2 !== m2 || y3 === false && U2 !== v ? false : !!t.fromBytes(h4);
    } catch {
      return false;
    }
  }
  function c2(h4 = r2(o2.seed)) {
    return Uf(Kt(h4, o2.seed, "seed"), n2.ORDER);
  }
  function f4(h4, y3 = true) {
    return t.BASE.multiply(re(n2, h4)).toBytes(y3);
  }
  function u(h4) {
    const y3 = c2(h4);
    return { secretKey: y3, publicKey: f4(y3) };
  }
  function a(h4) {
    if (typeof h4 == "bigint") return false;
    if (h4 instanceof t) return true;
    const { secretKey: y3, publicKey: m2, publicKeyUncompressed: v } = o2;
    if (n2.allowedLengths || y3 === m2) return;
    const U2 = tt("key", h4).length;
    return U2 === m2 || U2 === v;
  }
  function l4(h4, y3, m2 = true) {
    if (a(h4) === true) throw new Error("first arg must be private key");
    if (a(y3) === false) throw new Error("second arg must be public key");
    const v = re(n2, h4);
    return t.fromHex(y3).multiply(v).toBytes(m2);
  }
  return Object.freeze({ getPublicKey: f4, getSharedSecret: l4, keygen: u, Point: t, utils: { isValidSecretKey: s2, isValidPublicKey: i2, randomSecretKey: c2, isValidPrivateKey: s2, randomPrivateKey: c2, normPrivateKeyToScalar: (h4) => re(n2, h4), precompute(h4 = 8, y3 = t.BASE) {
    return y3.precompute(h4, false);
  } }, lengths: o2 });
}
function Xf(t, e, n2 = {}) {
  Ue(e), Ke(n2, {}, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r2 = n2.randomBytes || Mt, o2 = n2.hmac || ((b, ...g) => ke(e, b, _t(...g))), { Fp: s2, Fn: i2 } = t, { ORDER: c2, BITS: f4 } = i2, { keygen: u, getPublicKey: a, getSharedSecret: l4, utils: d3, lengths: h4 } = Wf(t, n2), y3 = { prehash: false, lowS: typeof n2.lowS == "boolean" ? n2.lowS : false, format: void 0, extraEntropy: false }, m2 = "compact";
  function v(b) {
    const g = c2 >> ne;
    return b > g;
  }
  function U2(b, g) {
    if (!i2.isValidNot0(g)) throw new Error(`invalid signature ${b}: out of range 1..Point.Fn.ORDER`);
    return g;
  }
  function F(b, g) {
    Pn(g);
    const x = h4.signature, E2 = g === "compact" ? x : g === "recovered" ? x + 1 : void 0;
    return Kt(b, E2, `${g} signature`);
  }
  class R2 {
    constructor(g, x, E2) {
      this.r = U2("r", g), this.s = U2("s", x), E2 != null && (this.recovery = E2), Object.freeze(this);
    }
    static fromBytes(g, x = m2) {
      F(g, x);
      let E2;
      if (x === "der") {
        const { r: I2, s: N2 } = xt.toSig(Kt(g));
        return new R2(I2, N2);
      }
      x === "recovered" && (E2 = g[0], x = "compact", g = g.subarray(1));
      const A3 = i2.BYTES, w = g.subarray(0, A3), B = g.subarray(A3, A3 * 2);
      return new R2(i2.fromBytes(w), i2.fromBytes(B), E2);
    }
    static fromHex(g, x) {
      return this.fromBytes(_e(g), x);
    }
    addRecoveryBit(g) {
      return new R2(this.r, this.s, g);
    }
    recoverPublicKey(g) {
      const x = s2.ORDER, { r: E2, s: A3, recovery: w } = this;
      if (w == null || ![0, 1, 2, 3].includes(w)) throw new Error("recovery id invalid");
      if (c2 * zo < x && w > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const I2 = w === 2 || w === 3 ? E2 + c2 : E2;
      if (!s2.isValid(I2)) throw new Error("recovery id 2 or 3 invalid");
      const N2 = s2.toBytes(I2), D = t.fromBytes(_t(Yo((w & 1) === 0), N2)), P2 = i2.inv(I2), $3 = H(tt("msgHash", g)), V2 = i2.create(-$3 * P2), q2 = i2.create(A3 * P2), G2 = t.BASE.multiplyUnsafe(V2).add(D.multiplyUnsafe(q2));
      if (G2.is0()) throw new Error("point at infinify");
      return G2.assertValidity(), G2;
    }
    hasHighS() {
      return v(this.s);
    }
    toBytes(g = m2) {
      if (Pn(g), g === "der") return _e(xt.hexFromSig(this));
      const x = i2.toBytes(this.r), E2 = i2.toBytes(this.s);
      if (g === "recovered") {
        if (this.recovery == null) throw new Error("recovery bit must be present");
        return _t(Uint8Array.of(this.recovery), x, E2);
      }
      return _t(x, E2);
    }
    toHex(g) {
      return Jt(this.toBytes(g));
    }
    assertValidity() {
    }
    static fromCompact(g) {
      return R2.fromBytes(tt("sig", g), "compact");
    }
    static fromDER(g) {
      return R2.fromBytes(tt("sig", g), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new R2(this.r, i2.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Jt(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Jt(this.toBytes("compact"));
    }
  }
  const Z = n2.bits2int || function(g) {
    if (g.length > 8192) throw new Error("input is too large");
    const x = Ve(g), E2 = g.length * 8 - f4;
    return E2 > 0 ? x >> BigInt(E2) : x;
  }, H = n2.bits2int_modN || function(g) {
    return i2.create(Z(g));
  }, j = ye(f4);
  function L(b) {
    return Rn("num < 2^" + f4, b, Et, j), i2.toBytes(b);
  }
  function k2(b, g) {
    return Kt(b, void 0, "message"), g ? Kt(e(b), void 0, "prehashed message") : b;
  }
  function O2(b, g, x) {
    if (["recovered", "canonical"].some((V2) => V2 in x)) throw new Error("sign() legacy options not supported");
    const { lowS: E2, prehash: A3, extraEntropy: w } = Hn(x, y3);
    b = k2(b, A3);
    const B = H(b), I2 = re(i2, g), N2 = [L(I2), L(B)];
    if (w != null && w !== false) {
      const V2 = w === true ? r2(h4.secretKey) : w;
      N2.push(tt("extraEntropy", V2));
    }
    const D = _t(...N2), P2 = B;
    function $3(V2) {
      const q2 = Z(V2);
      if (!i2.isValidNot0(q2)) return;
      const G2 = i2.inv(q2), M2 = t.BASE.multiply(q2).toAffine(), Y2 = i2.create(M2.x);
      if (Y2 === Et) return;
      const Yt = i2.create(G2 * i2.create(P2 + Y2 * I2));
      if (Yt === Et) return;
      let ce = (M2.x === Y2 ? 0 : 2) | Number(M2.y & ne), fe2 = Yt;
      return E2 && v(Yt) && (fe2 = i2.neg(Yt), ce ^= 1), new R2(Y2, fe2, ce);
    }
    return { seed: D, k2sig: $3 };
  }
  function T2(b, g, x = {}) {
    b = tt("message", b);
    const { seed: E2, k2sig: A3 } = O2(b, g, x);
    return vf(e.outputLen, i2.BYTES, o2)(E2, A3);
  }
  function C4(b) {
    let g;
    const x = typeof b == "string" || Ne(b), E2 = !x && b !== null && typeof b == "object" && typeof b.r == "bigint" && typeof b.s == "bigint";
    if (!x && !E2) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (E2) g = new R2(b.r, b.s);
    else if (x) {
      try {
        g = R2.fromBytes(tt("sig", b), "der");
      } catch (A3) {
        if (!(A3 instanceof xt.Err)) throw A3;
      }
      if (!g) try {
        g = R2.fromBytes(tt("sig", b), "compact");
      } catch {
        return false;
      }
    }
    return g || false;
  }
  function _(b, g, x, E2 = {}) {
    const { lowS: A3, prehash: w, format: B } = Hn(E2, y3);
    if (x = tt("publicKey", x), g = k2(tt("message", g), w), "strict" in E2) throw new Error("options.strict was renamed to lowS");
    const I2 = B === void 0 ? C4(b) : R2.fromBytes(tt("sig", b), B);
    if (I2 === false) return false;
    try {
      const N2 = t.fromBytes(x);
      if (A3 && I2.hasHighS()) return false;
      const { r: D, s: P2 } = I2, $3 = H(g), V2 = i2.inv(P2), q2 = i2.create($3 * V2), G2 = i2.create(D * V2), M2 = t.BASE.multiplyUnsafe(q2).add(N2.multiplyUnsafe(G2));
      return M2.is0() ? false : i2.create(M2.x) === D;
    } catch {
      return false;
    }
  }
  function p(b, g, x = {}) {
    const { prehash: E2 } = Hn(x, y3);
    return g = k2(g, E2), R2.fromBytes(b, "recovered").recoverPublicKey(g).toBytes();
  }
  return Object.freeze({ keygen: u, getPublicKey: a, getSharedSecret: l4, utils: d3, lengths: h4, Point: t, sign: T2, verify: _, recoverPublicKey: p, Signature: R2, hash: e });
}
function Jf(t) {
  const e = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n2 = t.Fp;
  let r2 = t.allowedPrivateKeyLengths ? Array.from(new Set(t.allowedPrivateKeyLengths.map((i2) => Math.ceil(i2 / 2)))) : void 0;
  const o2 = Ht(e.n, { BITS: t.nBitLength, allowedLengths: r2, modFromBytes: t.wrapPrivateKey }), s2 = { Fp: n2, Fn: o2, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e, curveOpts: s2 };
}
function Qf(t) {
  const { CURVE: e, curveOpts: n2 } = Jf(t), r2 = { hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e, curveOpts: n2, hash: t.hash, ecdsaOpts: r2 };
}
function ta(t, e) {
  const n2 = e.Point;
  return Object.assign({}, e, { ProjectivePoint: n2, CURVE: Object.assign({}, t, ko(n2.Fn.ORDER, n2.Fn.BITS)) });
}
function ea(t) {
  const { CURVE: e, curveOpts: n2, hash: r2, ecdsaOpts: o2 } = Qf(t), s2 = Yf(e, n2), i2 = Xf(s2, r2, o2);
  return ta(t, i2);
}
function Dn(t, e) {
  const n2 = (r2) => ea({ ...t, hash: r2 });
  return { ...n2(e), create: n2 };
}
var Xo = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Jo = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Qo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var na = Ht(Xo.p);
var ra = Ht(Jo.p);
var oa = Ht(Qo.p);
var sa = Dn({ ...Xo, Fp: na, lowS: false }, $e);
Dn({ ...Jo, Fp: ra, lowS: false }, gc), Dn({ ...Qo, Fp: oa, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, pc);

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var Ue2 = "wc";
var pe2 = "core";
var W2 = `${Ue2}@2:${pe2}:`;
var Qs = import_time2.FIVE_SECONDS * 1e3;
var Jt2 = "https://verify.walletconnect.org";
var be2 = Jt2;
var Xt2 = `${be2}/v3`;
function cr(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i2 = 0; i2 < t.length; i2++) t[i2] = 255;
  for (var s2 = 0; s2 < r2.length; s2++) {
    var n2 = r2.charAt(s2), o2 = n2.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o2] = s2;
  }
  var a = r2.length, c2 = r2.charAt(0), h4 = Math.log(a) / Math.log(256), l4 = Math.log(256) / Math.log(a);
  function p(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u.length === 0) return "";
    for (var m2 = 0, D = 0, _ = 0, E2 = u.length; _ !== E2 && u[_] === 0; ) _++, m2++;
    for (var L = (E2 - _) * l4 + 1 >>> 0, I2 = new Uint8Array(L); _ !== E2; ) {
      for (var k2 = u[_], T2 = 0, S3 = L - 1; (k2 !== 0 || T2 < D) && S3 !== -1; S3--, T2++) k2 += 256 * I2[S3] >>> 0, I2[S3] = k2 % a >>> 0, k2 = k2 / a >>> 0;
      if (k2 !== 0) throw new Error("Non-zero carry");
      D = T2, _++;
    }
    for (var O2 = L - D; O2 !== L && I2[O2] === 0; ) O2++;
    for (var te2 = c2.repeat(m2); O2 < L; ++O2) te2 += r2.charAt(I2[O2]);
    return te2;
  }
  function y3(u) {
    if (typeof u != "string") throw new TypeError("Expected String");
    if (u.length === 0) return new Uint8Array();
    var m2 = 0;
    if (u[m2] !== " ") {
      for (var D = 0, _ = 0; u[m2] === c2; ) D++, m2++;
      for (var E2 = (u.length - m2) * h4 + 1 >>> 0, L = new Uint8Array(E2); u[m2]; ) {
        var I2 = t[u.charCodeAt(m2)];
        if (I2 === 255) return;
        for (var k2 = 0, T2 = E2 - 1; (I2 !== 0 || k2 < _) && T2 !== -1; T2--, k2++) I2 += a * L[T2] >>> 0, L[T2] = I2 % 256 >>> 0, I2 = I2 / 256 >>> 0;
        if (I2 !== 0) throw new Error("Non-zero carry");
        _ = k2, m2++;
      }
      if (u[m2] !== " ") {
        for (var S3 = E2 - _; S3 !== E2 && L[S3] === 0; ) S3++;
        for (var O2 = new Uint8Array(D + (E2 - S3)), te2 = D; S3 !== E2; ) O2[te2++] = L[S3++];
        return O2;
      }
    }
  }
  function w(u) {
    var m2 = y3(u);
    if (m2) return m2;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: y3, decode: w };
}
var hr = cr;
var lr = hr;
var ni = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur = (r2) => new TextEncoder().encode(r2);
var dr = (r2) => new TextDecoder().decode(r2);
var gr = class {
  constructor(e, t, i2) {
    this.name = e, this.prefix = t, this.baseEncode = i2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var pr = class {
  constructor(e, t, i2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oi(this, e);
  }
};
var yr = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oi(this, e);
  }
  decode(e) {
    const t = e[0], i2 = this.decoders[t];
    if (i2) return i2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var oi = (r2, e) => new yr({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br2 = class {
  constructor(e, t, i2, s2) {
    this.name = e, this.prefix = t, this.baseEncode = i2, this.baseDecode = s2, this.encoder = new gr(e, t, i2), this.decoder = new pr(e, t, s2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se = ({ name: r2, prefix: e, encode: t, decode: i2 }) => new br2(r2, e, t, i2);
var me2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i2, decode: s2 } = lr(t, e);
  return Se({ prefix: r2, name: e, encode: i2, decode: (n2) => ni(s2(n2)) });
};
var mr = (r2, e, t, i2) => {
  const s2 = {};
  for (let l4 = 0; l4 < e.length; ++l4) s2[e[l4]] = l4;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o2 = new Uint8Array(n2 * t / 8 | 0);
  let a = 0, c2 = 0, h4 = 0;
  for (let l4 = 0; l4 < n2; ++l4) {
    const p = s2[r2[l4]];
    if (p === void 0) throw new SyntaxError(`Non-${i2} character`);
    c2 = c2 << t | p, a += t, a >= 8 && (a -= 8, o2[h4++] = 255 & c2 >> a);
  }
  if (a >= t || 255 & c2 << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr = (r2, e, t) => {
  const i2 = e[e.length - 1] === "=", s2 = (1 << t) - 1;
  let n2 = "", o2 = 0, a = 0;
  for (let c2 = 0; c2 < r2.length; ++c2) for (a = a << 8 | r2[c2], o2 += 8; o2 > t; ) o2 -= t, n2 += e[s2 & a >> o2];
  if (o2 && (n2 += e[s2 & a << t - o2]), i2) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var A2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i2 }) => Se({ prefix: e, name: r2, encode(s2) {
  return fr(s2, i2, t);
}, decode(s2) {
  return mr(s2, i2, t, r2);
} });
var Dr2 = Se({ prefix: "\0", name: "identity", encode: (r2) => dr(r2), decode: (r2) => ur(r2) });
var vr = Object.freeze({ __proto__: null, identity: Dr2 });
var wr2 = A2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var _r2 = Object.freeze({ __proto__: null, base2: wr2 });
var Er = A2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir = Object.freeze({ __proto__: null, base8: Er });
var Tr2 = me2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr2 = Object.freeze({ __proto__: null, base10: Tr2 });
var Pr2 = A2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr = A2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or = Object.freeze({ __proto__: null, base16: Pr2, base16upper: Sr });
var Rr2 = A2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar = A2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr = A2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr2 = A2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r2 = A2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr = A2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr2 = A2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr2 = A2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr2 = A2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur2 = Object.freeze({ __proto__: null, base32: Rr2, base32upper: Ar, base32pad: xr, base32padupper: Nr2, base32hex: $r2, base32hexupper: zr, base32hexpad: Lr2, base32hexpadupper: kr2, base32z: jr2 });
var Fr2 = me2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr2 = me2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr2 = Object.freeze({ __proto__: null, base36: Fr2, base36upper: Mr2 });
var Br = me2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr2 = me2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr2 = Object.freeze({ __proto__: null, base58btc: Br, base58flickr: Vr2 });
var Gr = A2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr = A2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr2 = A2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr = A2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr = Object.freeze({ __proto__: null, base64: Gr, base64pad: Wr, base64url: Hr2, base64urlpad: Yr });
var ai2 = Array.from("");
var Xr = ai2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr = ai2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr(r2) {
  return r2.reduce((e, t) => (e += Xr[t], e), "");
}
function en(r2) {
  const e = [];
  for (const t of r2) {
    const i2 = Zr[t.codePointAt(0)];
    if (i2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i2);
  }
  return new Uint8Array(e);
}
var tn = Se({ prefix: "", name: "base256emoji", encode: Qr, decode: en });
var sn2 = Object.freeze({ __proto__: null, base256emoji: tn });
var rn2 = hi;
var ci2 = 128;
var nn = 127;
var on = ~nn;
var an2 = Math.pow(2, 31);
function hi(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i2 = t; r2 >= an2; ) e[t++] = r2 & 255 | ci2, r2 /= 128;
  for (; r2 & on; ) e[t++] = r2 & 255 | ci2, r2 >>>= 7;
  return e[t] = r2 | 0, hi.bytes = t - i2 + 1, e;
}
var cn = Ve2;
var hn = 128;
var li = 127;
function Ve2(r2, i2) {
  var t = 0, i2 = i2 || 0, s2 = 0, n2 = i2, o2, a = r2.length;
  do {
    if (n2 >= a) throw Ve2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n2++], t += s2 < 28 ? (o2 & li) << s2 : (o2 & li) * Math.pow(2, s2), s2 += 7;
  } while (o2 >= hn);
  return Ve2.bytes = n2 - i2, t;
}
var ln2 = Math.pow(2, 7);
var un2 = Math.pow(2, 14);
var dn2 = Math.pow(2, 21);
var gn = Math.pow(2, 28);
var pn = Math.pow(2, 35);
var yn = Math.pow(2, 42);
var bn = Math.pow(2, 49);
var mn = Math.pow(2, 56);
var fn2 = Math.pow(2, 63);
var Dn2 = function(r2) {
  return r2 < ln2 ? 1 : r2 < un2 ? 2 : r2 < dn2 ? 3 : r2 < gn ? 4 : r2 < pn ? 5 : r2 < yn ? 6 : r2 < bn ? 7 : r2 < mn ? 8 : r2 < fn2 ? 9 : 10;
};
var vn2 = { encode: rn2, decode: cn, encodingLength: Dn2 };
var ui = vn2;
var di2 = (r2, e, t = 0) => (ui.encode(r2, e, t), e);
var gi = (r2) => ui.encodingLength(r2);
var qe2 = (r2, e) => {
  const t = e.byteLength, i2 = gi(r2), s2 = i2 + gi(t), n2 = new Uint8Array(s2 + t);
  return di2(r2, n2, 0), di2(t, n2, i2), n2.set(e, s2), new wn(r2, t, e, n2);
};
var wn = class {
  constructor(e, t, i2, s2) {
    this.code = e, this.size = t, this.digest = i2, this.bytes = s2;
  }
};
var pi = ({ name: r2, code: e, encode: t }) => new _n2(r2, e, t);
var _n2 = class {
  constructor(e, t, i2) {
    this.name = e, this.code = t, this.encode = i2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe2(this.code, t) : t.then((i2) => qe2(this.code, i2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var yi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En2 = pi({ name: "sha2-256", code: 18, encode: yi2("SHA-256") });
var In2 = pi({ name: "sha2-512", code: 19, encode: yi2("SHA-512") });
var Tn2 = Object.freeze({ __proto__: null, sha256: En2, sha512: In2 });
var bi2 = 0;
var Cn2 = "identity";
var mi = ni;
var Pn2 = (r2) => qe2(bi2, mi(r2));
var Sn2 = { code: bi2, name: Cn2, encode: mi, digest: Pn2 };
var On2 = Object.freeze({ __proto__: null, identity: Sn2 });
new TextEncoder(), new TextDecoder();
var fi2 = { ...vr, ..._r2, ...Ir, ...Cr2, ...Or, ...Ur2, ...Kr2, ...qr2, ...Jr, ...sn2 };
({ ...Tn2, ...On2 });
function Di2(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Di2(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function vi(r2, e, t, i2) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i2 } };
}
var wi = vi("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge = vi("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An2 = { utf8: wi, "utf-8": wi, hex: fi2.base16, latin1: Ge, ascii: Ge, binary: Ge, ...fi2 };

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var Ve3 = "wc";
var ke2 = 2;
var De2 = "client";
var we2 = `${Ve3}@${ke2}:${De2}:`;
var _t2 = "wc";
var ft2 = "auth";
var le2 = `${_t2}@${1.5}:${ft2}:`;
var pe3 = `${le2}:PUB_KEY`;

// node_modules/@reown/appkit-controllers/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var He2 = "wc";
var Ue3 = "universal_provider";
var $2 = `${He2}@2:${Ue3}:`;
var T = "https://rpc.walletconnect.org/v1/";
var Be = `${T}bundler`;

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js
var addEmbeddedWalletSessionPromise = null;
var SIWXUtil = {
  getSIWX() {
    return OptionsController.state.siwx;
  },
  async initializeIfEnabled(caipAddress = ChainController.getActiveCaipAddress()) {
    var _a4, _b2, _c;
    const siwx = OptionsController.state.siwx;
    if (!(siwx && caipAddress)) {
      return;
    }
    const [namespace, chainId, address] = caipAddress.split(":");
    if (!ChainController.checkIfSupportedNetwork(namespace, `${namespace}:${chainId}`)) {
      return;
    }
    try {
      if ((_a4 = OptionsController.state.remoteFeatures) == null ? void 0 : _a4.emailCapture) {
        const user = (_b2 = ChainController.getAccountData(namespace)) == null ? void 0 : _b2.user;
        await ModalController.open({
          view: "DataCapture",
          data: {
            email: (user == null ? void 0 : user.email) ?? void 0
          }
        });
        return;
      }
      if (addEmbeddedWalletSessionPromise) {
        await addEmbeddedWalletSessionPromise;
      }
      const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address);
      if (sessions.length) {
        return;
      }
      await ModalController.open({
        view: "SIWXSignMessage"
      });
    } catch (error) {
      console.error("SIWXUtil:initializeIfEnabled", error);
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties(error)
      });
      await ((_c = ConnectionController._getClient()) == null ? void 0 : _c.disconnect().catch(console.error));
      RouterController.reset("Connect");
      SnackController.showError("A problem occurred while trying initialize authentication");
    }
  },
  async requestSignMessage() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = getActiveCaipNetwork();
    const client = ConnectionController._getClient();
    if (!siwx) {
      throw new Error("SIWX is not enabled");
    }
    if (!address) {
      throw new Error("No ActiveCaipAddress found");
    }
    if (!network) {
      throw new Error("No ActiveCaipNetwork or client found");
    }
    if (!client) {
      throw new Error("No ConnectionController client found");
    }
    try {
      const siwxMessage = await siwx.createMessage({
        chainId: network.caipNetworkId,
        accountAddress: address
      });
      const message = siwxMessage.toString();
      const connectorId = ConnectorController.getConnectorId(network.chainNamespace);
      if (connectorId === ConstantsUtil.CONNECTOR_ID.AUTH) {
        RouterController.pushTransactionStack({});
      }
      const signature = await client.signMessage(message);
      await siwx.addSession({
        data: siwxMessage,
        message,
        signature
      });
      ChainController.setLastConnectedSIWECaipNetwork(network);
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_SUCCESS",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      if (!ModalController.state.open || RouterController.state.view === "ApproveTransaction") {
        await ModalController.open({
          view: "SIWXSignMessage"
        });
      }
      SnackController.showError("Error signing message");
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties(error)
      });
      console.error("SWIXUtil:requestSignMessage", error);
    }
  },
  async cancelSignMessage() {
    var _a4;
    try {
      const siwx = this.getSIWX();
      const isRequired = (_a4 = siwx == null ? void 0 : siwx.getRequired) == null ? void 0 : _a4.call(siwx);
      if (isRequired) {
        const lastNetwork = ChainController.getLastConnectedSIWECaipNetwork();
        if (lastNetwork) {
          const sessions = await (siwx == null ? void 0 : siwx.getSessions(lastNetwork == null ? void 0 : lastNetwork.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || ""));
          if (sessions && sessions.length > 0) {
            await ChainController.switchActiveNetwork(lastNetwork);
          } else {
            await ConnectionController.disconnect();
          }
        } else {
          await ConnectionController.disconnect();
        }
      } else {
        ModalController.close();
      }
      ModalController.close();
      EventsController.sendEvent({
        event: "CLICK_CANCEL_SIWX",
        type: "track",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      console.error("SIWXUtil:cancelSignMessage", error);
    }
  },
  async getAllSessions() {
    const siwx = this.getSIWX();
    const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const sessions = [];
    await Promise.all(allRequestedCaipNetworks.map(async (caipNetwork) => {
      const session = await (siwx == null ? void 0 : siwx.getSessions(caipNetwork.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || ""));
      if (session) {
        sessions.push(...session);
      }
    }));
    return sessions;
  },
  async getSessions(args) {
    const siwx = OptionsController.state.siwx;
    let address = args == null ? void 0 : args.address;
    if (!address) {
      const activeCaipAddress = ChainController.getActiveCaipAddress();
      address = CoreHelperUtil.getPlainAddress(activeCaipAddress);
    }
    let network = args == null ? void 0 : args.caipNetworkId;
    if (!network) {
      const activeCaipNetwork = ChainController.getActiveCaipNetwork();
      network = activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId;
    }
    if (!(siwx && address && network)) {
      return [];
    }
    return siwx.getSessions(network, address);
  },
  async isSIWXCloseDisabled() {
    var _a4;
    const siwx = this.getSIWX();
    if (siwx) {
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isSiwxSignMessage = RouterController.state.view === "SIWXSignMessage";
      if (isApproveSignScreen || isSiwxSignMessage) {
        return ((_a4 = siwx.getRequired) == null ? void 0 : _a4.call(siwx)) && (await this.getSessions()).length === 0;
      }
    }
    return false;
  },
  async authConnectorAuthenticate({ authConnector, chainId, socialUri, preferredAccountType, chainNamespace }) {
    var _a4;
    const siwx = SIWXUtil.getSIWX();
    const network = getActiveCaipNetwork();
    if (!siwx || !chainNamespace.includes(ConstantsUtil.CHAIN.EVM) || // Request to input email and sign message when email capture is enabled
    ((_a4 = OptionsController.state.remoteFeatures) == null ? void 0 : _a4.emailCapture)) {
      const result2 = await authConnector.connect({
        chainId,
        socialUri,
        preferredAccountType
      });
      return {
        address: result2.address,
        chainId: result2.chainId,
        accounts: result2.accounts
      };
    }
    const caipNetwork = `${chainNamespace}:${chainId}`;
    const siwxMessage = await siwx.createMessage({
      chainId: caipNetwork,
      accountAddress: "<<AccountAddress>>"
    });
    const siwxMessageData = {
      accountAddress: siwxMessage.accountAddress,
      chainId: siwxMessage.chainId,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      version: siwxMessage.version,
      nonce: siwxMessage.nonce,
      notBefore: siwxMessage.notBefore,
      statement: siwxMessage.statement,
      resources: siwxMessage.resources,
      requestId: siwxMessage.requestId,
      issuedAt: siwxMessage.issuedAt,
      expirationTime: siwxMessage.expirationTime,
      serializedMessage: siwxMessage.toString()
    };
    const result = await authConnector.connect({
      chainId,
      socialUri,
      siwxMessage: siwxMessageData,
      preferredAccountType
    });
    siwxMessageData.accountAddress = result.address;
    siwxMessageData.serializedMessage = result.message || "";
    if (result.signature && result.message) {
      const promise = SIWXUtil.addEmbeddedWalletSession(siwxMessageData, result.message, result.signature);
      await promise;
    }
    ChainController.setLastConnectedSIWECaipNetwork(network);
    return {
      address: result.address,
      chainId: result.chainId,
      accounts: result.accounts
    };
  },
  async addEmbeddedWalletSession(siwxMessageData, message, signature) {
    if (addEmbeddedWalletSessionPromise) {
      return addEmbeddedWalletSessionPromise;
    }
    const siwx = SIWXUtil.getSIWX();
    if (!siwx) {
      return Promise.resolve();
    }
    addEmbeddedWalletSessionPromise = siwx.addSession({
      data: siwxMessageData,
      message,
      signature
    }).finally(() => {
      addEmbeddedWalletSessionPromise = null;
    });
    return addEmbeddedWalletSessionPromise;
  },
  async universalProviderAuthenticate({ universalProvider, chains, methods }) {
    var _a4, _b2, _c;
    const siwx = SIWXUtil.getSIWX();
    const network = getActiveCaipNetwork();
    const namespaces = new Set(chains.map((chain) => chain.split(":")[0]));
    if (!siwx || namespaces.size !== 1 || !namespaces.has("eip155")) {
      return false;
    }
    const siwxMessage = await siwx.createMessage({
      chainId: ((_a4 = getActiveCaipNetwork()) == null ? void 0 : _a4.caipNetworkId) || "",
      accountAddress: ""
    });
    const result = await universalProvider.authenticate({
      nonce: siwxMessage.nonce,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      exp: siwxMessage.expirationTime,
      iat: siwxMessage.issuedAt,
      nbf: siwxMessage.notBefore,
      requestId: siwxMessage.requestId,
      version: siwxMessage.version,
      resources: siwxMessage.resources,
      statement: siwxMessage.statement,
      chainId: siwxMessage.chainId,
      methods,
      // The first chainId is what is used for universal provider to build the message
      chains: [siwxMessage.chainId, ...chains.filter((chain) => chain !== siwxMessage.chainId)]
    });
    SnackController.showLoading("Authenticating...", { autoClose: false });
    const walletInfo = {
      ...result.session.peer.metadata,
      name: result.session.peer.metadata.name,
      icon: (_b2 = result.session.peer.metadata.icons) == null ? void 0 : _b2[0],
      type: "WALLET_CONNECT"
    };
    ChainController.setAccountProp("connectedWalletInfo", walletInfo, Array.from(namespaces)[0]);
    if ((_c = result == null ? void 0 : result.auths) == null ? void 0 : _c.length) {
      const sessions = result.auths.map((cacao) => {
        const message = universalProvider.client.formatAuthMessage({
          request: cacao.p,
          iss: cacao.p.iss
        });
        return {
          data: {
            ...cacao.p,
            accountAddress: cacao.p.iss.split(":").slice(-1).join(""),
            chainId: cacao.p.iss.split(":").slice(2, 4).join(":"),
            uri: cacao.p.aud,
            version: cacao.p.version || siwxMessage.version,
            expirationTime: cacao.p.exp,
            issuedAt: cacao.p.iat,
            notBefore: cacao.p.nbf
          },
          message,
          signature: cacao.s.s,
          cacao
        };
      });
      try {
        await siwx.setSessions(sessions);
        if (network) {
          ChainController.setLastConnectedSIWECaipNetwork(network);
        }
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_SUCCESS",
          properties: SIWXUtil.getSIWXEventProperties()
        });
      } catch (error) {
        console.error("SIWX:universalProviderAuth - failed to set sessions", error);
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: SIWXUtil.getSIWXEventProperties(error)
        });
        await universalProvider.disconnect().catch(console.error);
        throw error;
      } finally {
        SnackController.hide();
      }
    }
    return true;
  },
  getSIWXEventProperties(error) {
    var _a4;
    const namespace = ChainController.state.activeChain;
    if (!namespace) {
      throw new Error("SIWXUtil:getSIWXEventProperties - namespace is required");
    }
    return {
      network: ((_a4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a4.caipNetworkId) || "",
      isSmartAccount: getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
      message: error ? CoreHelperUtil.parseError(error) : void 0
    };
  },
  async clearSessions() {
    const siwx = this.getSIWX();
    if (siwx) {
      await siwx.setSessions([]);
    }
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ModalUtil.js
var ModalUtil = {
  isUnsupportedChainView() {
    return RouterController.state.view === "UnsupportedChain" || RouterController.state.view === "SwitchNetwork" && RouterController.state.history.includes("UnsupportedChain");
  },
  async safeClose() {
    if (this.isUnsupportedChainView()) {
      ModalController.shake();
      return;
    }
    const isSIWXCloseDisabled = await SIWXUtil.isSIWXCloseDisabled();
    if (isSIWXCloseDisabled) {
      ModalController.shake();
      return;
    }
    if (RouterController.state.view === "DataCapture" || RouterController.state.view === "DataCaptureOtpConfirm") {
      ConnectionController.disconnect();
    }
    ModalController.close();
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ProviderController.js
var CLEAN_PROVIDERS_STATE = {
  eip155: void 0,
  solana: void 0,
  polkadot: void 0,
  bip122: void 0,
  cosmos: void 0,
  sui: void 0,
  stacks: void 0
};
var state3 = proxy({
  providers: { ...CLEAN_PROVIDERS_STATE },
  providerIds: { ...CLEAN_PROVIDERS_STATE }
});
var ProviderController = {
  state: state3,
  subscribeKey(key, callback) {
    return subscribeKey(state3, key, callback);
  },
  subscribe(callback) {
    return subscribe(state3, () => {
      callback(state3);
    });
  },
  subscribeProviders(callback) {
    return subscribe(state3.providers, () => callback(state3.providers));
  },
  setProvider(chainNamespace, provider) {
    if (chainNamespace && provider) {
      state3.providers[chainNamespace] = ref(provider);
    }
  },
  getProvider(chainNamespace) {
    if (!chainNamespace) {
      return void 0;
    }
    return state3.providers[chainNamespace];
  },
  setProviderId(chainNamespace, providerId) {
    if (providerId) {
      state3.providerIds[chainNamespace] = providerId;
    }
  },
  getProviderId(chainNamespace) {
    if (!chainNamespace) {
      return void 0;
    }
    return state3.providerIds[chainNamespace];
  },
  reset() {
    state3.providers = { ...CLEAN_PROVIDERS_STATE };
    state3.providerIds = { ...CLEAN_PROVIDERS_STATE };
  },
  resetChain(chainNamespace) {
    state3.providers[chainNamespace] = void 0;
    state3.providerIds[chainNamespace] = void 0;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js
var USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
var USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
var defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
var state4 = proxy(defaultState);
var controller3 = {
  state: state4,
  subscribe(callback) {
    return subscribe(state4, () => callback(state4));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state4, key, callback);
  },
  setSelectedProvider(provider) {
    var _a4, _b2;
    if (provider && provider.name === "meld") {
      const activeChain = ChainController.state.activeChain;
      const currency = activeChain === ConstantsUtil.CHAIN.SOLANA ? "SOL" : "USDC";
      const address = activeChain ? ((_b2 = (_a4 = ChainController.state.chains.get(activeChain)) == null ? void 0 : _a4.accountState) == null ? void 0 : _b2.address) ?? "" : "";
      const url = new URL(provider.url);
      url.searchParams.append("publicKey", MELD_PUBLIC_KEY);
      url.searchParams.append("destinationCurrencyCode", currency);
      url.searchParams.append("walletAddress", address);
      url.searchParams.append("externalCustomerId", OptionsController.state.projectId);
      state4.selectedProvider = { ...provider, url: url.toString() };
    } else {
      state4.selectedProvider = provider;
    }
  },
  setOnrampProviders(providers) {
    if (Array.isArray(providers) && providers.every((item) => typeof item === "string")) {
      const validOnramp = providers;
      const newProviders = ONRAMP_PROVIDERS.filter((provider) => validOnramp.includes(provider.name));
      state4.providers = newProviders;
    } else {
      state4.providers = [];
    }
  },
  setPurchaseCurrency(currency) {
    state4.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state4.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    OnRampController.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    OnRampController.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state4.purchaseCurrencies = options.purchaseCurrencies;
    state4.paymentCurrencies = options.paymentCurrencies;
    state4.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state4.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    var _a4, _b2;
    state4.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state4.purchaseCurrency,
        paymentCurrency: state4.paymentCurrency,
        amount: ((_a4 = state4.paymentAmount) == null ? void 0 : _a4.toString()) || "0",
        network: (_b2 = state4.purchaseCurrency) == null ? void 0 : _b2.symbol
      });
      state4.quotesLoading = false;
      state4.purchaseAmount = Number(quote == null ? void 0 : quote.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state4.error = error.message;
      state4.quotesLoading = false;
      return null;
    } finally {
      state4.quotesLoading = false;
    }
  },
  resetState() {
    state4.selectedProvider = null;
    state4.error = null;
    state4.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state4.paymentCurrency = USD_CURRENCY_DEFAULT;
    state4.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state4.paymentCurrencies = [];
    state4.paymentAmount = void 0;
    state4.purchaseAmount = void 0;
    state4.quotesLoading = false;
  }
};
var OnRampController = withErrorBoundary(controller3);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TooltipController.js
var state5 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
var controller4 = {
  state: state5,
  subscribe(callback) {
    return subscribe(state5, () => callback(state5));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state5, key, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state5.open = true;
    state5.message = message;
    state5.triggerRect = triggerRect;
    state5.variant = variant;
  },
  hide() {
    state5.open = false;
    state5.message = "";
    state5.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
var TooltipController = withErrorBoundary(controller4);

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB = 2147483648;
var EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js
var state6 = proxy({
  suggestions: [],
  loading: false
});
var controller5 = {
  state: state6,
  subscribe(callback) {
    return subscribe(state6, () => callback(state6));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state6, key, callback);
  },
  async resolveName(name) {
    var _a4, _b2;
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e) {
      const error = e;
      throw new Error(((_b2 = (_a4 = error == null ? void 0 : error.reasons) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.description) || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(value) {
    try {
      state6.loading = true;
      state6.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(value);
      state6.suggestions = response.suggestions || [];
      return state6.suggestions;
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state6.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = ChainController.state.activeCaipNetwork;
      if (!network) {
        return [];
      }
      const cachedEns = StorageUtil.getEnsFromCacheForAddress(address);
      if (cachedEns) {
        return cachedEns;
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      StorageUtil.updateEnsCache({
        address,
        ens: response,
        timestamp: Date.now()
      });
      return response;
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    var _a4;
    const network = ChainController.state.activeCaipNetwork;
    const address = (_a4 = ChainController.getAccountData(network == null ? void 0 : network.chainNamespace)) == null ? void 0 : _a4.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!network) {
      throw new Error("Network not found");
    }
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state6.loading = true;
    try {
      const message = JSON.stringify({
        name,
        attributes: {},
        // Unix timestamp
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        onCancel() {
          RouterController.replace("RegisterAccountName");
        }
      });
      const signature = await ConnectionController.signMessage(message);
      state6.loading = false;
      const networkId = network.id;
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature,
        message
      });
      ChainController.setAccountProp("profileName", name, network.chainNamespace);
      StorageUtil.updateEnsCache({
        address,
        ens: [
          {
            name,
            registered_at: (/* @__PURE__ */ new Date()).toISOString(),
            updated_at: void 0,
            addresses: {},
            attributes: []
          }
        ],
        timestamp: Date.now()
      });
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e) {
      const errorMessage = EnsController.parseEnsApiError(e, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state6.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    var _a4, _b2;
    const ensError = error;
    return ((_b2 = (_a4 = ensError == null ? void 0 : ensError.reasons) == null ? void 0 : _a4[0]) == null ? void 0 : _b2.description) || defaultError;
  }
};
var EnsController = withErrorBoundary(controller5);

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsStateController.js
var state7 = proxy({
  isLegalCheckboxChecked: false
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ExchangeUtil.js
var baseUSDC = {
  network: "eip155:8453",
  asset: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};
var baseSepoliaUSDC = {
  network: "eip155:84532",
  asset: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  metadata: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6
  }
};

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ExchangeController.js
var DEFAULT_STATE = {
  paymentAsset: null,
  amount: null,
  tokenAmount: 0,
  priceLoading: false,
  error: null,
  exchanges: [],
  isLoading: false,
  currentPayment: void 0,
  isPaymentInProgress: false,
  paymentId: "",
  assets: []
};
var state8 = proxy(DEFAULT_STATE);

// node_modules/lit-html/development/lit-html.js
var DEV_MODE = true;
var ENABLE_EXTRA_SECURITY_HOOKS = true;
var ENABLE_SHADYDOM_NOPATCH = true;
var NODE_MODE = false;
var global2 = globalThis;
var debugLogEvent = DEV_MODE ? (event) => {
  const shouldEmit = global2.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global2.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var debugLogRenderId = 0;
var issueWarning;
if (DEV_MODE) {
  global2.litIssuedWarnings ?? (global2.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning = (code, warning) => {
    warning += code ? ` See https://lit.dev/msg/${code} for more information.` : "";
    if (!global2.litIssuedWarnings.has(warning) && !global2.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global2.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    issueWarning("dev-mode", `Lit is in dev mode. Not recommended for production!`);
  });
}
var _a2, _b;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a2 = global2.ShadyDOM) == null ? void 0 : _a2.inUse) && ((_b = global2.ShadyDOM) == null ? void 0 : _b.noPatch) === true ? global2.ShadyDOM.wrap : (node) => node;
var trustedTypes = global2.trustedTypes;
var policy = trustedTypes ? trustedTypes.createPolicy("lit-html", {
  createHTML: (s2) => s2
}) : void 0;
var identityFunction = (value) => value;
var noopSanitizer = (_node, _name, _type) => identityFunction;
var setSanitizer = (newSanitizer) => {
  if (!ENABLE_EXTRA_SECURITY_HOOKS) {
    return;
  }
  if (sanitizerFactoryInternal !== noopSanitizer) {
    throw new Error(`Attempted to overwrite existing lit-html security policy. setSanitizeDOMValueFactory should be called at most once.`);
  }
  sanitizerFactoryInternal = newSanitizer;
};
var _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {
  sanitizerFactoryInternal = noopSanitizer;
};
var createSanitizer = (node, name, type) => {
  return sanitizerFactoryInternal(node, name, type);
};
var boundAttributeSuffix = "$lit$";
var marker = `lit$${Math.random().toFixed(9).slice(2)}$`;
var markerMatch = "?" + marker;
var nodeMarker = `<${markerMatch}>`;
var d2 = NODE_MODE && global2.document === void 0 ? {
  createTreeWalker() {
    return {};
  }
} : document;
var createMarker = () => d2.createComment("");
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isArray = Array.isArray;
var isIterable = (value) => isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof (value == null ? void 0 : value[Symbol.iterator]) === "function";
var SPACE_CHAR = `[ 	
\f\r]`;
var ATTR_VALUE_CHAR = `[^ 	
\f\r"'\`<>=]`;
var NAME_CHAR = `[^\\s"'>=/]`;
var textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var COMMENT_START = 1;
var TAG_NAME = 2;
var DYNAMIC_TAG_NAME = 3;
var commentEndRegex = /-->/g;
var comment2EndRegex = />/g;
var tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`, "g");
var ENTIRE_MATCH = 0;
var ATTRIBUTE_NAME = 1;
var SPACES_AND_EQUALS = 2;
var QUOTE_CHAR = 3;
var singleQuoteAttrEndRegex = /'/g;
var doubleQuoteAttrEndRegex = /"/g;
var rawTextElement = /^(?:script|style|textarea|title)$/i;
var HTML_RESULT = 1;
var SVG_RESULT = 2;
var MATHML_RESULT = 3;
var ATTRIBUTE_PART = 1;
var CHILD_PART = 2;
var PROPERTY_PART = 3;
var BOOLEAN_ATTRIBUTE_PART = 4;
var EVENT_PART = 5;
var ELEMENT_PART = 6;
var COMMENT_PART = 7;
var tag = (type) => (strings, ...values) => {
  if (DEV_MODE && strings.some((s2) => s2 === void 0)) {
    console.warn("Some template strings are undefined.\nThis is probably caused by illegal octal escape sequences.");
  }
  if (DEV_MODE) {
    if (values.some((val) => val == null ? void 0 : val["_$litStatic$"])) {
      issueWarning("", `Static values 'literal' or 'unsafeStatic' cannot be used as values to non-static templates.
Please use the static 'html' tag function. See https://lit.dev/docs/templates/expressions/#static-expressions`);
    }
  }
  return {
    // This property needs to remain unminified.
    ["_$litType$"]: type,
    strings,
    values
  };
};
var html = tag(HTML_RESULT);
var svg = tag(SVG_RESULT);
var mathml = tag(MATHML_RESULT);
var noChange = Symbol.for("lit-noChange");
var nothing = Symbol.for("lit-nothing");
var templateCache = /* @__PURE__ */ new WeakMap();
var walker = d2.createTreeWalker(
  d2,
  129
  /* NodeFilter.SHOW_{ELEMENT|COMMENT} */
);
var sanitizerFactoryInternal = noopSanitizer;
function trustFromTemplateString(tsa, stringFromTSA) {
  if (!isArray(tsa) || !tsa.hasOwnProperty("raw")) {
    let message = "invalid template strings array";
    if (DEV_MODE) {
      message = `
          Internal Error: expected template strings to be an array
          with a 'raw' field. Faking a template strings array by
          calling html or svg like an ordinary function is effectively
          the same as calling unsafeHtml and can lead to major security
          issues, e.g. opening your code up to XSS attacks.
          If you're using the html or svg tagged template functions normally
          and still seeing this error, please file a bug at
          https://github.com/lit/lit/issues/new?template=bug_report.md
          and include information about your build tooling, if any.
        `.trim().replace(/\n */g, "\n");
    }
    throw new Error(message);
  }
  return policy !== void 0 ? policy.createHTML(stringFromTSA) : stringFromTSA;
}
var getTemplateHtml = (strings, type) => {
  const l4 = strings.length - 1;
  const attrNames = [];
  let html2 = type === SVG_RESULT ? "<svg>" : type === MATHML_RESULT ? "<math>" : "";
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i2 = 0; i2 < l4; i2++) {
    const s2 = strings[i2];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match;
    while (lastIndex < s2.length) {
      regex.lastIndex = lastIndex;
      match = regex.exec(s2);
      if (match === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match[COMMENT_START] === "!--") {
          regex = commentEndRegex;
        } else if (match[COMMENT_START] !== void 0) {
          regex = comment2EndRegex;
        } else if (match[TAG_NAME] !== void 0) {
          if (rawTextElement.test(match[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, "g");
          }
          regex = tagEndRegex;
        } else if (match[DYNAMIC_TAG_NAME] !== void 0) {
          if (DEV_MODE) {
            throw new Error("Bindings in tag names are not supported. Please use static templates instead. See https://lit.dev/docs/templates/expressions/#static-expressions");
          }
          regex = tagEndRegex;
        }
      } else if (regex === tagEndRegex) {
        if (match[ENTIRE_MATCH] === ">") {
          regex = rawTextEndRegex ?? textEndRegex;
          attrNameEndIndex = -1;
        } else if (match[ATTRIBUTE_NAME] === void 0) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
          attrName = match[ATTRIBUTE_NAME];
          regex = match[QUOTE_CHAR] === void 0 ? tagEndRegex : match[QUOTE_CHAR] === '"' ? doubleQuoteAttrEndRegex : singleQuoteAttrEndRegex;
        }
      } else if (regex === doubleQuoteAttrEndRegex || regex === singleQuoteAttrEndRegex) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = void 0;
      }
    }
    if (DEV_MODE) {
      console.assert(attrNameEndIndex === -1 || regex === tagEndRegex || regex === singleQuoteAttrEndRegex || regex === doubleQuoteAttrEndRegex, "unexpected parse state B");
    }
    const end = regex === tagEndRegex && strings[i2 + 1].startsWith("/>") ? " " : "";
    html2 += regex === textEndRegex ? s2 + nodeMarker : attrNameEndIndex >= 0 ? (attrNames.push(attrName), s2.slice(0, attrNameEndIndex) + boundAttributeSuffix + s2.slice(attrNameEndIndex)) + marker + end : s2 + marker + (attrNameEndIndex === -2 ? i2 : end);
  }
  const htmlResult = html2 + (strings[l4] || "<?>") + (type === SVG_RESULT ? "</svg>" : type === MATHML_RESULT ? "</math>" : "");
  return [trustFromTemplateString(strings, htmlResult), attrNames];
};
var Template = class _Template {
  constructor({ strings, ["_$litType$"]: type }, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html2, attrNames] = getTemplateHtml(strings, type);
    this.el = _Template.createElement(html2, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT || type === MATHML_RESULT) {
      const wrapper = this.el.content.firstChild;
      wrapper.replaceWith(...wrapper.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (DEV_MODE) {
          const tag2 = node.localName;
          if (/^(?:textarea|template)$/i.test(tag2) && node.innerHTML.includes(marker)) {
            const m2 = `Expressions are not supported inside \`${tag2}\` elements. See https://lit.dev/msg/expression-in-${tag2} for more information.`;
            if (tag2 === "template") {
              throw new Error(m2);
            } else
              issueWarning("", m2);
          }
        }
        if (node.hasAttributes()) {
          for (const name of node.getAttributeNames()) {
            if (name.endsWith(boundAttributeSuffix)) {
              const realName = attrNames[attrNameIndex++];
              const value = node.getAttribute(name);
              const statics = value.split(marker);
              const m2 = /([.?@])?(.*)/.exec(realName);
              parts.push({
                type: ATTRIBUTE_PART,
                index: nodeIndex,
                name: m2[2],
                strings: statics,
                ctor: m2[1] === "." ? PropertyPart : m2[1] === "?" ? BooleanAttributePart : m2[1] === "@" ? EventPart : AttributePart
              });
              node.removeAttribute(name);
            } else if (name.startsWith(marker)) {
              parts.push({
                type: ELEMENT_PART,
                index: nodeIndex
              });
              node.removeAttribute(name);
            }
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings2 = node.textContent.split(marker);
          const lastIndex = strings2.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : "";
            for (let i2 = 0; i2 < lastIndex; i2++) {
              node.append(strings2[i2], createMarker());
              walker.nextNode();
              parts.push({ type: CHILD_PART, index: ++nodeIndex });
            }
            node.append(strings2[lastIndex], createMarker());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({ type: CHILD_PART, index: nodeIndex });
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            parts.push({ type: COMMENT_PART, index: nodeIndex });
            i2 += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
    if (DEV_MODE) {
      if (attrNames.length !== attrNameIndex) {
        throw new Error(`Detected duplicate attribute bindings. This occurs if your template has duplicate attributes on an element tag. For example "<input ?disabled=\${true} ?disabled=\${false}>" contains a duplicate "disabled" attribute. The error was detected in the following template: 
\`` + strings.join("${...}") + "`");
      }
    }
    debugLogEvent && debugLogEvent({
      kind: "template prep",
      template: this,
      clonableTemplate: this.el,
      parts: this.parts,
      strings
    });
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @nocollapse */
  static createElement(html2, _options) {
    const el = d2.createElement("template");
    el.innerHTML = html2;
    return el;
  }
};
function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a4, _b2;
  if (value === noChange) {
    return value;
  }
  let currentDirective = attributeIndex !== void 0 ? (_a4 = parent.__directives) == null ? void 0 : _a4[attributeIndex] : parent.__directive;
  const nextDirectiveConstructor = isPrimitive(value) ? void 0 : (
    // This property needs to remain unminified.
    value["_$litDirective$"]
  );
  if ((currentDirective == null ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {
    (_b2 = currentDirective == null ? void 0 : currentDirective["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _b2.call(currentDirective, false);
    if (nextDirectiveConstructor === void 0) {
      currentDirective = void 0;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== void 0) {
      (parent.__directives ?? (parent.__directives = []))[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== void 0) {
    value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);
  }
  return value;
}
var TemplateInstance = class {
  constructor(template, parent) {
    this._$parts = [];
    this._$disconnectableChildren = void 0;
    this._$template = template;
    this._$parent = parent;
  }
  // Called by ChildPart parentNode getter
  get parentNode() {
    return this._$parent.parentNode;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  // This method is separate from the constructor because we need to return a
  // DocumentFragment and we don't want to hold onto it with an instance field.
  _clone(options) {
    const { el: { content }, parts } = this._$template;
    const fragment = ((options == null ? void 0 : options.creationScope) ?? d2).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== void 0) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (nodeIndex !== (templatePart == null ? void 0 : templatePart.index)) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d2;
    return fragment;
  }
  _update(values) {
    let i2 = 0;
    for (const part of this._$parts) {
      if (part !== void 0) {
        debugLogEvent && debugLogEvent({
          kind: "set part",
          part,
          value: values[i2],
          valueIndex: i2,
          values,
          templateInstance: this
        });
        if (part.strings !== void 0) {
          part._$setValue(values, part, i2);
          i2 += part.strings.length - 2;
        } else {
          part._$setValue(values[i2]);
        }
      }
      i2++;
    }
  }
};
var ChildPart = class _ChildPart {
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    var _a4;
    return ((_a4 = this._$parent) == null ? void 0 : _a4._$isConnected) ?? this.__isConnected;
  }
  constructor(startNode, endNode, parent, options) {
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected = (options == null ? void 0 : options.isConnected) ?? true;
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._textSanitizer = void 0;
    }
  }
  /**
   * The parent node into which the part renders its content.
   *
   * A ChildPart's content consists of a range of adjacent child nodes of
   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
   * `.endNode`).
   *
   * - If both `.startNode` and `.endNode` are non-null, then the part's content
   * consists of all siblings between `.startNode` and `.endNode`, exclusively.
   *
   * - If `.startNode` is non-null but `.endNode` is null, then the part's
   * content consists of all siblings following `.startNode`, up to and
   * including the last child of `.parentNode`. If `.endNode` is non-null, then
   * `.startNode` will always be non-null.
   *
   * - If both `.endNode` and `.startNode` are null, then the part's content
   * consists of all child nodes of `.parentNode`.
   */
  get parentNode() {
    let parentNode = wrap(this._$startNode).parentNode;
    const parent = this._$parent;
    if (parent !== void 0 && (parentNode == null ? void 0 : parentNode.nodeType) === 11) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  /**
   * The part's leading marker node, if any. See `.parentNode` for more
   * information.
   */
  get startNode() {
    return this._$startNode;
  }
  /**
   * The part's trailing marker node, if any. See `.parentNode` for more
   * information.
   */
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    var _a4;
    if (DEV_MODE && this.parentNode === null) {
      throw new Error(`This \`ChildPart\` has no \`parentNode\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \`innerHTML\` or \`textContent\` can do this.`);
    }
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive(value)) {
      if (value === nothing || value == null || value === "") {
        if (this._$committedValue !== nothing) {
          debugLogEvent && debugLogEvent({
            kind: "commit nothing to child",
            start: this._$startNode,
            end: this._$endNode,
            parent: this._$parent,
            options: this.options
          });
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value["_$litType$"] !== void 0) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== void 0) {
      if (DEV_MODE && ((_a4 = this.options) == null ? void 0 : _a4.host) === value) {
        this._commitText(`[probable mistake: rendered a template's host in itself (commonly caused by writing \${this} in a template]`);
        console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);
        return;
      }
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);
  }
  _commitNode(value) {
    var _a4;
    if (this._$committedValue !== value) {
      this._$clear();
      if (ENABLE_EXTRA_SECURITY_HOOKS && sanitizerFactoryInternal !== noopSanitizer) {
        const parentNodeName = (_a4 = this._$startNode.parentNode) == null ? void 0 : _a4.nodeName;
        if (parentNodeName === "STYLE" || parentNodeName === "SCRIPT") {
          let message = "Forbidden";
          if (DEV_MODE) {
            if (parentNodeName === "STYLE") {
              message = `Lit does not support binding inside style nodes. This is a security risk, as style injection attacks can exfiltrate data and spoof UIs. Consider instead using css\`...\` literals to compose styles, and do dynamic styling with css custom properties, ::parts, <slot>s, and by mutating the DOM rather than stylesheets.`;
            } else {
              message = `Lit does not support binding inside script nodes. This is a security risk, as it could allow arbitrary code execution.`;
            }
          }
          throw new Error(message);
        }
      }
      debugLogEvent && debugLogEvent({
        kind: "commit node",
        start: this._$startNode,
        parent: this._$parent,
        value,
        options: this.options
      });
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (this._$committedValue !== nothing && isPrimitive(this._$committedValue)) {
      const node = wrap(this._$startNode).nextSibling;
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(node, "data", "property");
        }
        value = this._textSanitizer(value);
      }
      debugLogEvent && debugLogEvent({
        kind: "commit text",
        node,
        value,
        options: this.options
      });
      node.data = value;
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        const textNode = d2.createTextNode("");
        this._commitNode(textNode);
        if (this._textSanitizer === void 0) {
          this._textSanitizer = createSanitizer(textNode, "data", "property");
        }
        value = this._textSanitizer(value);
        debugLogEvent && debugLogEvent({
          kind: "commit text",
          node: textNode,
          value,
          options: this.options
        });
        textNode.data = value;
      } else {
        this._commitNode(d2.createTextNode(value));
        debugLogEvent && debugLogEvent({
          kind: "commit text",
          node: wrap(this._$startNode).nextSibling,
          value,
          options: this.options
        });
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a4;
    const { values, ["_$litType$"]: type } = result;
    const template = typeof type === "number" ? this._$getTemplate(result) : (type.el === void 0 && (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);
    if (((_a4 = this._$committedValue) == null ? void 0 : _a4._$template) === template) {
      debugLogEvent && debugLogEvent({
        kind: "template updating",
        template,
        instance: this._$committedValue,
        parts: this._$committedValue._$parts,
        options: this.options,
        values
      });
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template, this);
      const fragment = instance._clone(this.options);
      debugLogEvent && debugLogEvent({
        kind: "template instantiated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      instance._update(values);
      debugLogEvent && debugLogEvent({
        kind: "template instantiated and updated",
        template,
        instance,
        parts: instance._$parts,
        options: this.options,
        fragment,
        values
      });
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  // Overridden via `litHtmlPolyfillSupport` to provide platform support.
  /** @internal */
  _$getTemplate(result) {
    let template = templateCache.get(result.strings);
    if (template === void 0) {
      templateCache.set(result.strings, template = new Template(result));
    }
    return template;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(itemPart = new _ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options));
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);
      itemParts.length = partIndex;
    }
  }
  /**
   * Removes the nodes contained within this Part from the DOM.
   *
   * @param start Start node to clear from, for clearing a subset of the part's
   *     DOM (used when truncating iterables)
   * @param from  When `start` is specified, the index within the iterable from
   *     which ChildParts are being removed, used for disconnecting directives
   *     in those Parts.
   *
   * @internal
   */
  _$clear(start = wrap(this._$startNode).nextSibling, from6) {
    var _a4;
    (_a4 = this._$notifyConnectionChanged) == null ? void 0 : _a4.call(this, false, true, from6);
    while (start !== this._$endNode) {
      const n2 = wrap(start).nextSibling;
      wrap(start).remove();
      start = n2;
    }
  }
  /**
   * Implementation of RootPart's `isConnected`. Note that this method
   * should only be called on `RootPart`s (the `ChildPart` returned from a
   * top-level `render()` call). It has no effect on non-root ChildParts.
   * @param isConnected Whether to set
   * @internal
   */
  setConnected(isConnected) {
    var _a4;
    if (this._$parent === void 0) {
      this.__isConnected = isConnected;
      (_a4 = this._$notifyConnectionChanged) == null ? void 0 : _a4.call(this, isConnected);
    } else if (DEV_MODE) {
      throw new Error("part.setConnected() may only be called on a RootPart returned from render().");
    }
  }
};
var AttributePart = class {
  get tagName() {
    return this.element.tagName;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  constructor(element, name, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = void 0;
    this.element = element;
    this.name = name;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== "" || strings[1] !== "") {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      this._sanitizer = void 0;
    }
  }
  /**
   * Sets the value of this part by resolving the value from possibly multiple
   * values and static strings and committing it to the DOM.
   * If this part is single-valued, `this._strings` will be undefined, and the
   * method will be called with a single value argument. If this part is
   * multi-value, `this._strings` will be defined, and the method is called
   * with the value array of the part's owning TemplateInstance, and an offset
   * into the value array from which the values should be read.
   * This method is overloaded this way to eliminate short-lived array slices
   * of the template instance values, and allow a fast-path for single-valued
   * parts.
   *
   * @param value The part value, or an array of values for multi-valued parts
   * @param valueIndex the index to start reading values from. `undefined` for
   *   single-valued parts
   * @param noCommit causes the part to not commit its value to the DOM. Used
   *   in hydration to prime attribute parts with their first-rendered value,
   *   but not set the attribute, and in SSR to no-op the DOM operation and
   *   capture the value for serialization.
   *
   * @internal
   */
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === void 0) {
      value = resolveDirective(this, value, directiveParent, 0);
      change = !isPrimitive(value) || value !== this._$committedValue && value !== noChange;
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i2, v;
      for (i2 = 0; i2 < strings.length - 1; i2++) {
        v = resolveDirective(this, values[valueIndex + i2], directiveParent, i2);
        if (v === noChange) {
          v = this._$committedValue[i2];
        }
        change || (change = !isPrimitive(v) || v !== this._$committedValue[i2]);
        if (v === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v ?? "") + strings[i2 + 1];
        }
        this._$committedValue[i2] = v;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  /** @internal */
  _commitValue(value) {
    if (value === nothing) {
      wrap(this.element).removeAttribute(this.name);
    } else {
      if (ENABLE_EXTRA_SECURITY_HOOKS) {
        if (this._sanitizer === void 0) {
          this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "attribute");
        }
        value = this._sanitizer(value ?? "");
      }
      debugLogEvent && debugLogEvent({
        kind: "commit attribute",
        element: this.element,
        name: this.name,
        value,
        options: this.options
      });
      wrap(this.element).setAttribute(this.name, value ?? "");
    }
  }
};
var PropertyPart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  /** @internal */
  _commitValue(value) {
    if (ENABLE_EXTRA_SECURITY_HOOKS) {
      if (this._sanitizer === void 0) {
        this._sanitizer = sanitizerFactoryInternal(this.element, this.name, "property");
      }
      value = this._sanitizer(value);
    }
    debugLogEvent && debugLogEvent({
      kind: "commit property",
      element: this.element,
      name: this.name,
      value,
      options: this.options
    });
    this.element[this.name] = value === nothing ? void 0 : value;
  }
};
var BooleanAttributePart = class extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  /** @internal */
  _commitValue(value) {
    debugLogEvent && debugLogEvent({
      kind: "commit boolean attribute",
      element: this.element,
      name: this.name,
      value: !!(value && value !== nothing),
      options: this.options
    });
    wrap(this.element).toggleAttribute(this.name, !!value && value !== nothing);
  }
};
var EventPart = class extends AttributePart {
  constructor(element, name, strings, parent, options) {
    super(element, name, strings, parent, options);
    this.type = EVENT_PART;
    if (DEV_MODE && this.strings !== void 0) {
      throw new Error(`A \`<${element.localName}>\` has a \`@${name}=...\` listener with invalid content. Event listeners in templates must have exactly one expression and no surrounding text.`);
    }
  }
  // EventPart does not use the base _$setValue/_resolveValue implementation
  // since the dirty checking is more complex
  /** @internal */
  _$setValue(newListener, directiveParent = this) {
    newListener = resolveDirective(this, newListener, directiveParent, 0) ?? nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener = newListener === nothing && oldListener !== nothing || newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive;
    const shouldAddListener = newListener !== nothing && (oldListener === nothing || shouldRemoveListener);
    debugLogEvent && debugLogEvent({
      kind: "commit event listener",
      element: this.element,
      name: this.name,
      value: newListener,
      options: this.options,
      removeListener: shouldRemoveListener,
      addListener: shouldAddListener,
      oldListener
    });
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a4;
    if (typeof this._$committedValue === "function") {
      this._$committedValue.call(((_a4 = this.options) == null ? void 0 : _a4.host) ?? this.element, event);
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
};
var ElementPart = class {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = void 0;
    this._$parent = parent;
    this.options = options;
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    debugLogEvent && debugLogEvent({
      kind: "commit to element binding",
      element: this.element,
      value,
      options: this.options
    });
    resolveDirective(this, value);
  }
};
var _$LH = {
  // Used in lit-ssr
  _boundAttributeSuffix: boundAttributeSuffix,
  _marker: marker,
  _markerMatch: markerMatch,
  _HTML_RESULT: HTML_RESULT,
  _getTemplateHtml: getTemplateHtml,
  // Used in tests and private-ssr-support
  _TemplateInstance: TemplateInstance,
  _isIterable: isIterable,
  _resolveDirective: resolveDirective,
  _ChildPart: ChildPart,
  _AttributePart: AttributePart,
  _BooleanAttributePart: BooleanAttributePart,
  _EventPart: EventPart,
  _PropertyPart: PropertyPart,
  _ElementPart: ElementPart
};
var polyfillSupport = DEV_MODE ? global2.litHtmlPolyfillSupportDevMode : global2.litHtmlPolyfillSupport;
polyfillSupport == null ? void 0 : polyfillSupport(Template, ChildPart);
(global2.litHtmlVersions ?? (global2.litHtmlVersions = [])).push("3.3.1");
if (DEV_MODE && global2.litHtmlVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}
var render = (value, container, options) => {
  if (DEV_MODE && container == null) {
    throw new TypeError(`The container to render into may not be ${container}`);
  }
  const renderId = DEV_MODE ? debugLogRenderId++ : 0;
  const partOwnerNode = (options == null ? void 0 : options.renderBefore) ?? container;
  let part = partOwnerNode["_$litPart$"];
  debugLogEvent && debugLogEvent({
    kind: "begin render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  if (part === void 0) {
    const endNode = (options == null ? void 0 : options.renderBefore) ?? null;
    partOwnerNode["_$litPart$"] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, void 0, options ?? {});
  }
  part._$setValue(value);
  debugLogEvent && debugLogEvent({
    kind: "end render",
    id: renderId,
    value,
    container,
    options,
    part
  });
  return part;
};
if (ENABLE_EXTRA_SECURITY_HOOKS) {
  render.setSanitizer = setSanitizer;
  render.createSanitizer = createSanitizer;
  if (DEV_MODE) {
    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;
  }
}

// node_modules/@lit/reactive-element/development/css-tag.js
var NODE_MODE2 = false;
var global3 = globalThis;
var supportsAdoptingStyleSheets = global3.ShadowRoot && (global3.ShadyCSS === void 0 || global3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var cssTagCache = /* @__PURE__ */ new WeakMap();
var CSSResult = class {
  constructor(cssText, strings, safeToken) {
    this["_$cssResult$"] = true;
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  // This is a getter so that it's lazy. In practice, this means stylesheets
  // are not created until the first element instance is made.
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === void 0) {
      const cacheable = strings !== void 0 && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === void 0) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var textFromCSSResult = (value) => {
  if (value["_$cssResult$"] === true) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
var unsafeCSS = (value) => new CSSResult(typeof value === "string" ? value : String(value), void 0, constructionToken);
var css = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, strings, constructionToken);
};
var adoptStyles = (renderRoot, styles2) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles2.map((s2) => s2 instanceof CSSStyleSheet ? s2 : s2.styleSheet);
  } else {
    for (const s2 of styles2) {
      const style = document.createElement("style");
      const nonce = global3["litNonce"];
      if (nonce !== void 0) {
        style.setAttribute("nonce", nonce);
      }
      style.textContent = s2.cssText;
      renderRoot.appendChild(style);
    }
  }
};
var cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
var getCompatibleStyle = supportsAdoptingStyleSheets || NODE_MODE2 && global3.CSSStyleSheet === void 0 ? (s2) => s2 : (s2) => s2 instanceof CSSStyleSheet ? cssResultFromStyleSheet(s2) : s2;

// node_modules/@lit/reactive-element/development/reactive-element.js
var { is, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf } = Object;
var NODE_MODE3 = false;
var global4 = globalThis;
if (NODE_MODE3) {
  global4.customElements ?? (global4.customElements = customElements);
}
var DEV_MODE2 = true;
var issueWarning2;
var trustedTypes2 = global4.trustedTypes;
var emptyStringForBooleanAttribute = trustedTypes2 ? trustedTypes2.emptyScript : "";
var polyfillSupport2 = DEV_MODE2 ? global4.reactiveElementPolyfillSupportDevMode : global4.reactiveElementPolyfillSupport;
if (DEV_MODE2) {
  global4.litIssuedWarnings ?? (global4.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning2 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global4.litIssuedWarnings.has(warning) && !global4.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global4.litIssuedWarnings.add(warning);
    }
  };
  queueMicrotask(() => {
    var _a4;
    issueWarning2("dev-mode", `Lit is in dev mode. Not recommended for production!`);
    if (((_a4 = global4.ShadyDOM) == null ? void 0 : _a4.inUse) && polyfillSupport2 === void 0) {
      issueWarning2("polyfill-support-missing", `Shadow DOM is being polyfilled via \`ShadyDOM\` but the \`polyfill-support\` module has not been loaded.`);
    }
  });
}
var debugLogEvent2 = DEV_MODE2 ? (event) => {
  const shouldEmit = global4.emitLitDebugLogEvents;
  if (!shouldEmit) {
    return;
  }
  global4.dispatchEvent(new CustomEvent("lit-debug", {
    detail: event
  }));
} : void 0;
var JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
var notEqual = (value, old) => !is(value, old);
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  useDefault: false,
  hasChanged: notEqual
};
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata"));
global4.litPropertyMetadata ?? (global4.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var ReactiveElement = class extends HTMLElement {
  /**
   * Adds an initializer function to the class that is called during instance
   * construction.
   *
   * This is useful for code that runs against a `ReactiveElement`
   * subclass, such as a decorator, that needs to do work for each
   * instance, such as setting up a `ReactiveController`.
   *
   * ```ts
   * const myDecorator = (target: typeof ReactiveElement, key: string) => {
   *   target.addInitializer((instance: ReactiveElement) => {
   *     // This is run during construction of the element
   *     new MyController(instance);
   *   });
   * }
   * ```
   *
   * Decorating a field will then cause each instance to run an initializer
   * that adds a controller:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   @myDecorator foo;
   * }
   * ```
   *
   * Initializers are stored per-constructor. Adding an initializer to a
   * subclass does not add it to a superclass. Since initializers are run in
   * constructors, initializers will run in order of the class hierarchy,
   * starting with superclasses and progressing to the instance's class.
   *
   * @nocollapse
   */
  static addInitializer(initializer) {
    this.__prepare();
    (this._initializers ?? (this._initializers = [])).push(initializer);
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   * @category attributes
   */
  static get observedAttributes() {
    this.finalize();
    return this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()];
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist
   * and stores a {@linkcode PropertyDeclaration} for the property with the
   * given options. The property setter calls the property's `hasChanged`
   * property option or uses a strict identity check to determine whether or not
   * to request an update.
   *
   * This method may be overridden to customize properties; however,
   * when doing so, it's important to call `super.createProperty` to ensure
   * the property is setup correctly. This method calls
   * `getPropertyDescriptor` internally to get a descriptor to install.
   * To customize what properties do when they are get or set, override
   * `getPropertyDescriptor`. To customize the options for a property,
   * implement `createProperty` like this:
   *
   * ```ts
   * static createProperty(name, options) {
   *   options = Object.assign(options, {myOption: true});
   *   super.createProperty(name, options);
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static createProperty(name, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.__prepare();
    if (this.prototype.hasOwnProperty(name)) {
      options = Object.create(options);
      options.wrapped = true;
    }
    this.elementProperties.set(name, options);
    if (!options.noAccessor) {
      const key = DEV_MODE2 ? (
        // Use Symbol.for in dev mode to make it easier to maintain state
        // when doing HMR.
        Symbol.for(`${String(name)} (@property() cache)`)
      ) : Symbol();
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== void 0) {
        defineProperty(this.prototype, name, descriptor);
      }
    }
  }
  /**
   * Returns a property descriptor to be defined on the given named property.
   * If no descriptor is returned, the property will not become an accessor.
   * For example,
   *
   * ```ts
   * class MyElement extends LitElement {
   *   static getPropertyDescriptor(name, key, options) {
   *     const defaultDescriptor =
   *         super.getPropertyDescriptor(name, key, options);
   *     const setter = defaultDescriptor.set;
   *     return {
   *       get: defaultDescriptor.get,
   *       set(value) {
   *         setter.call(this, value);
   *         // custom action.
   *       },
   *       configurable: true,
   *       enumerable: true
   *     }
   *   }
   * }
   * ```
   *
   * @nocollapse
   * @category properties
   */
  static getPropertyDescriptor(name, key, options) {
    const { get: get2, set: set2 } = getOwnPropertyDescriptor(this.prototype, name) ?? {
      get() {
        return this[key];
      },
      set(v) {
        this[key] = v;
      }
    };
    if (DEV_MODE2 && get2 == null) {
      if ("value" in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {
        throw new Error(`Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it's actually declared as a value on the prototype. Usually this is due to using @property or @state on a method.`);
      }
      issueWarning2("reactive-property-without-getter", `Field ${JSON.stringify(String(name))} on ${this.name} was declared as a reactive property but it does not have a getter. This will be an error in a future version of Lit.`);
    }
    return {
      get: get2,
      set(value) {
        const oldValue = get2 == null ? void 0 : get2.call(this);
        set2 == null ? void 0 : set2.call(this, value);
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  /**
   * Returns the property options associated with the given property.
   * These options are defined with a `PropertyDeclaration` via the `properties`
   * object or the `@property` decorator and are registered in
   * `createProperty(...)`.
   *
   * Note, this method should be considered "final" and not overridden. To
   * customize the options for a given property, override
   * {@linkcode createProperty}.
   *
   * @nocollapse
   * @final
   * @category properties
   */
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) ?? defaultPropertyDeclaration;
  }
  /**
   * Initializes static own properties of the class used in bookkeeping
   * for element properties, initializers, etc.
   *
   * Can be called multiple times by code that needs to ensure these
   * properties exist before using them.
   *
   * This method ensures the superclass is finalized so that inherited
   * property metadata can be copied down.
   * @nocollapse
   */
  static __prepare() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("elementProperties", this))) {
      return;
    }
    const superCtor = getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== void 0) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
  }
  /**
   * Finishes setting up the class so that it's ready to be registered
   * as a custom element and instantiated.
   *
   * This method is called by the ReactiveElement.observedAttributes getter.
   * If you override the observedAttributes getter, you must either call
   * super.observedAttributes to trigger finalization, or call finalize()
   * yourself.
   *
   * @nocollapse
   */
  static finalize() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("finalized", this))) {
      return;
    }
    this.finalized = true;
    this.__prepare();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...getOwnPropertyNames(props),
        ...getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    const metadata = this[Symbol.metadata];
    if (metadata !== null) {
      const properties = litPropertyMetadata.get(metadata);
      if (properties !== void 0) {
        for (const [p, options] of properties) {
          this.elementProperties.set(p, options);
        }
      }
    }
    this.__attributeToPropertyMap = /* @__PURE__ */ new Map();
    for (const [p, options] of this.elementProperties) {
      const attr = this.__attributeNameForProperty(p, options);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    if (DEV_MODE2) {
      if (this.hasOwnProperty("createProperty")) {
        issueWarning2("no-override-create-property", "Overriding ReactiveElement.createProperty() is deprecated. The override will not be called with standard decorators");
      }
      if (this.hasOwnProperty("getPropertyDescriptor")) {
        issueWarning2("no-override-get-property-descriptor", "Overriding ReactiveElement.getPropertyDescriptor() is deprecated. The override will not be called with standard decorators");
      }
    }
  }
  /**
   * Takes the styles the user supplied via the `static styles` property and
   * returns the array of styles to apply to the element.
   * Override this method to integrate into a style management system.
   *
   * Styles are deduplicated preserving the _last_ instance in the list. This
   * is a performance optimization to avoid duplicated styles that can occur
   * especially when composing via subclassing. The last item is kept to try
   * to preserve the cascade order with the assumption that it's most important
   * that last added styles override previous styles.
   *
   * @nocollapse
   * @category styles
   */
  static finalizeStyles(styles2) {
    const elementStyles2 = [];
    if (Array.isArray(styles2)) {
      const set2 = new Set(styles2.flat(Infinity).reverse());
      for (const s2 of set2) {
        elementStyles2.unshift(getCompatibleStyle(s2));
      }
    } else if (styles2 !== void 0) {
      elementStyles2.push(getCompatibleStyle(styles2));
    }
    return elementStyles2;
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  constructor() {
    super();
    this.__instanceProperties = void 0;
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this.__initialize();
  }
  /**
   * Internal only override point for customizing work done when elements
   * are constructed.
   */
  __initialize() {
    var _a4;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a4 = this.constructor._initializers) == null ? void 0 : _a4.forEach((i2) => i2(this));
  }
  /**
   * Registers a `ReactiveController` to participate in the element's reactive
   * update cycle. The element automatically calls into any registered
   * controllers during its lifecycle callbacks.
   *
   * If the element is connected when `addController()` is called, the
   * controller's `hostConnected()` callback will be immediately called.
   * @category controllers
   */
  addController(controller6) {
    var _a4;
    (this.__controllers ?? (this.__controllers = /* @__PURE__ */ new Set())).add(controller6);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_a4 = controller6.hostConnected) == null ? void 0 : _a4.call(controller6);
    }
  }
  /**
   * Removes a `ReactiveController` from the element.
   * @category controllers
   */
  removeController(controller6) {
    var _a4;
    (_a4 = this.__controllers) == null ? void 0 : _a4.delete(controller6);
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs.
   */
  __saveInstanceProperties() {
    const instanceProperties = /* @__PURE__ */ new Map();
    const elementProperties = this.constructor.elementProperties;
    for (const p of elementProperties.keys()) {
      if (this.hasOwnProperty(p)) {
        instanceProperties.set(p, this[p]);
        delete this[p];
      }
    }
    if (instanceProperties.size > 0) {
      this.__instanceProperties = instanceProperties;
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   *
   * @return Returns a node into which to render.
   * @category rendering
   */
  createRenderRoot() {
    const renderRoot = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  /**
   * On first connection, creates the element's renderRoot, sets up
   * element styling, and enables updating.
   * @category lifecycle
   */
  connectedCallback() {
    var _a4;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot());
    this.enableUpdating(true);
    (_a4 = this.__controllers) == null ? void 0 : _a4.forEach((c2) => {
      var _a5;
      return (_a5 = c2.hostConnected) == null ? void 0 : _a5.call(c2);
    });
  }
  /**
   * Note, this method should be considered final and not overridden. It is
   * overridden on the element instance with a function that triggers the first
   * update.
   * @category updates
   */
  enableUpdating(_requestedUpdate) {
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a4;
    (_a4 = this.__controllers) == null ? void 0 : _a4.forEach((c2) => {
      var _a5;
      return (_a5 = c2.hostDisconnected) == null ? void 0 : _a5.call(c2);
    });
  }
  /**
   * Synchronizes property values when attributes change.
   *
   * Specifically, when an attribute is set, the corresponding property is set.
   * You should rarely need to implement this callback. If this method is
   * overridden, `super.attributeChangedCallback(name, _old, value)` must be
   * called.
   *
   * See [responding to attribute changes](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#responding_to_attribute_changes)
   * on MDN for more information about the `attributeChangedCallback`.
   * @category attributes
   */
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value) {
    var _a4;
    const elemProperties = this.constructor.elementProperties;
    const options = elemProperties.get(name);
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== void 0 && options.reflect === true) {
      const converter = ((_a4 = options.converter) == null ? void 0 : _a4.toAttribute) !== void 0 ? options.converter : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      if (DEV_MODE2 && this.constructor.enabledWarnings.includes("migration") && attrValue === void 0) {
        issueWarning2("undefined-attribute-value", `The attribute value for the ${name} property is undefined on element ${this.localName}. The attribute will be removed, but in the previous version of \`ReactiveElement\`, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  /** @internal */
  _$attributeToProperty(name, value) {
    var _a4, _b2;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = typeof options.converter === "function" ? { fromAttribute: options.converter } : ((_a4 = options.converter) == null ? void 0 : _a4.fromAttribute) !== void 0 ? options.converter : defaultConverter;
      this.__reflectingProperty = propName;
      const convertedValue = converter.fromAttribute(value, options.type);
      this[propName] = convertedValue ?? ((_b2 = this.__defaultValues) == null ? void 0 : _b2.get(propName)) ?? // eslint-disable-next-line @typescript-eslint/no-explicit-any
      convertedValue;
      this.__reflectingProperty = null;
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should be called
   * when an element should update based on some state not triggered by setting
   * a reactive property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored.
   *
   * @param name name of requesting property
   * @param oldValue old value of requesting property
   * @param options property options to use instead of the previously
   *     configured options
   * @category updates
   */
  requestUpdate(name, oldValue, options) {
    var _a4;
    if (name !== void 0) {
      if (DEV_MODE2 && name instanceof Event) {
        issueWarning2(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);
      }
      const ctor = this.constructor;
      const newValue = this[name];
      options ?? (options = ctor.getPropertyOptions(name));
      const changed = (options.hasChanged ?? notEqual)(newValue, oldValue) || // When there is no change, check a corner case that can occur when
      // 1. there's a initial value which was not reflected
      // 2. the property is subsequently set to this value.
      // For example, `prop: {useDefault: true, reflect: true}`
      // and el.prop = 'foo'. This should be considered a change if the
      // attribute is not set because we will now reflect the property to the attribute.
      options.useDefault && options.reflect && newValue === ((_a4 = this.__defaultValues) == null ? void 0 : _a4.get(name)) && !this.hasAttribute(ctor.__attributeNameForProperty(name, options));
      if (changed) {
        this._$changeProperty(name, oldValue, options);
      } else {
        return;
      }
    }
    if (this.isUpdatePending === false) {
      this.__updatePromise = this.__enqueueUpdate();
    }
  }
  /**
   * @internal
   */
  _$changeProperty(name, oldValue, { useDefault, reflect, wrapped }, initializeValue) {
    if (useDefault && !(this.__defaultValues ?? (this.__defaultValues = /* @__PURE__ */ new Map())).has(name)) {
      this.__defaultValues.set(name, initializeValue ?? oldValue ?? this[name]);
      if (wrapped !== true || initializeValue !== void 0) {
        return;
      }
    }
    if (!this._$changedProperties.has(name)) {
      if (!this.hasUpdated && !useDefault) {
        oldValue = void 0;
      }
      this._$changedProperties.set(name, oldValue);
    }
    if (reflect === true && this.__reflectingProperty !== name) {
      (this.__reflectingProperties ?? (this.__reflectingProperties = /* @__PURE__ */ new Set())).add(name);
    }
  }
  /**
   * Sets up the element to asynchronously update.
   */
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  /**
   * Schedules an element update. You can override this method to change the
   * timing of updates by returning a Promise. The update will await the
   * returned Promise, and you should resolve the Promise to allow the update
   * to proceed. If this method is overridden, `super.scheduleUpdate()`
   * must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```ts
   * override protected async scheduleUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.scheduleUpdate();
   * }
   * ```
   * @category updates
   */
  scheduleUpdate() {
    const result = this.performUpdate();
    if (DEV_MODE2 && this.constructor.enabledWarnings.includes("async-perform-update") && typeof (result == null ? void 0 : result.then) === "function") {
      issueWarning2("async-perform-update", `Element ${this.localName} returned a Promise from performUpdate(). This behavior is deprecated and will be removed in a future version of ReactiveElement.`);
    }
    return result;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * Call `performUpdate()` to immediately process a pending update. This should
   * generally not be needed, but it can be done in rare cases when you need to
   * update synchronously.
   *
   * @category updates
   */
  performUpdate() {
    var _a4;
    if (!this.isUpdatePending) {
      return;
    }
    debugLogEvent2 == null ? void 0 : debugLogEvent2({ kind: "update" });
    if (!this.hasUpdated) {
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot());
      if (DEV_MODE2) {
        const ctor = this.constructor;
        const shadowedProperties = [...ctor.elementProperties.keys()].filter((p) => this.hasOwnProperty(p) && p in getPrototypeOf(this));
        if (shadowedProperties.length) {
          throw new Error(`The following properties on element ${this.localName} will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. See https://lit.dev/msg/class-field-shadowing for more information.`);
        }
      }
      if (this.__instanceProperties) {
        for (const [p, value] of this.__instanceProperties) {
          this[p] = value;
        }
        this.__instanceProperties = void 0;
      }
      const elementProperties = this.constructor.elementProperties;
      if (elementProperties.size > 0) {
        for (const [p, options] of elementProperties) {
          const { wrapped } = options;
          const value = this[p];
          if (wrapped === true && !this._$changedProperties.has(p) && value !== void 0) {
            this._$changeProperty(p, void 0, options, value);
          }
        }
      }
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_a4 = this.__controllers) == null ? void 0 : _a4.forEach((c2) => {
          var _a5;
          return (_a5 = c2.hostUpdate) == null ? void 0 : _a5.call(c2);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  /**
   * Invoked before `update()` to compute values needed during the update.
   *
   * Implement `willUpdate` to compute property values that depend on other
   * properties and are used in the rest of the update process.
   *
   * ```ts
   * willUpdate(changedProperties) {
   *   // only need to check changed properties for an expensive computation.
   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
   *   }
   * }
   *
   * render() {
   *   return html`SHA: ${this.sha}`;
   * }
   * ```
   *
   * @category updates
   */
  willUpdate(_changedProperties) {
  }
  // Note, this is an override point for polyfill-support.
  // @internal
  _$didUpdate(changedProperties) {
    var _a4;
    (_a4 = this.__controllers) == null ? void 0 : _a4.forEach((c2) => {
      var _a5;
      return (_a5 = c2.hostUpdated) == null ? void 0 : _a5.call(c2);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (DEV_MODE2 && this.isUpdatePending && this.constructor.enabledWarnings.includes("change-in-update")) {
      issueWarning2("change-in-update", `Element ${this.localName} scheduled an update (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = /* @__PURE__ */ new Map();
    this.isUpdatePending = false;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super.getUpdateComplete()`, then any subsequent state.
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  get updateComplete() {
    return this.getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   * ```ts
   * class MyElement extends LitElement {
   *   override async getUpdateComplete() {
   *     const result = await super.getUpdateComplete();
   *     await this._myChild.updateComplete;
   *     return result;
   *   }
   * }
   * ```
   *
   * @return A promise of a boolean that resolves to true if the update completed
   *     without triggering another update.
   * @category updates
   */
  getUpdateComplete() {
    return this.__updatePromise;
  }
  /**
   * Controls whether or not `update()` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  update(_changedProperties) {
    this.__reflectingProperties && (this.__reflectingProperties = this.__reflectingProperties.forEach((p) => this.__propertyToAttribute(p, this[p])));
    this.__markUpdated();
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  updated(_changedProperties) {
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * ```ts
   * firstUpdated() {
   *   this.renderRoot.getElementById('my-text-area').focus();
   * }
   * ```
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   * @category updates
   */
  firstUpdated(_changedProperties) {
  }
};
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
ReactiveElement[JSCompiler_renameProperty("elementProperties", ReactiveElement)] = /* @__PURE__ */ new Map();
ReactiveElement[JSCompiler_renameProperty("finalized", ReactiveElement)] = /* @__PURE__ */ new Map();
polyfillSupport2 == null ? void 0 : polyfillSupport2({ ReactiveElement });
if (DEV_MODE2) {
  ReactiveElement.enabledWarnings = [
    "change-in-update",
    "async-perform-update"
  ];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (!this.enabledWarnings.includes(warning)) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i2 = this.enabledWarnings.indexOf(warning);
    if (i2 >= 0) {
      this.enabledWarnings.splice(i2, 1);
    }
  };
}
(global4.reactiveElementVersions ?? (global4.reactiveElementVersions = [])).push("2.1.1");
if (DEV_MODE2 && global4.reactiveElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning2("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/lit-element/development/lit-element.js
var JSCompiler_renameProperty2 = (prop, _obj) => prop;
var DEV_MODE3 = true;
var global5 = globalThis;
var issueWarning3;
if (DEV_MODE3) {
  global5.litIssuedWarnings ?? (global5.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning3 = (code, warning) => {
    warning += ` See https://lit.dev/msg/${code} for more information.`;
    if (!global5.litIssuedWarnings.has(warning) && !global5.litIssuedWarnings.has(code)) {
      console.warn(warning);
      global5.litIssuedWarnings.add(warning);
    }
  };
}
var LitElement = class extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  /**
   * @category rendering
   */
  createRenderRoot() {
    var _a4;
    const renderRoot = super.createRenderRoot();
    (_a4 = this.renderOptions).renderBefore ?? (_a4.renderBefore = renderRoot.firstChild);
    return renderRoot;
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * @param changedProperties Map of changed properties with old values
   * @category updates
   */
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  /**
   * Invoked when the component is added to the document's DOM.
   *
   * In `connectedCallback()` you should setup tasks that should only occur when
   * the element is connected to the document. The most common of these is
   * adding event listeners to nodes external to the element, like a keydown
   * event handler added to the window.
   *
   * ```ts
   * connectedCallback() {
   *   super.connectedCallback();
   *   addEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * Typically, anything done in `connectedCallback()` should be undone when the
   * element is disconnected, in `disconnectedCallback()`.
   *
   * @category lifecycle
   */
  connectedCallback() {
    var _a4;
    super.connectedCallback();
    (_a4 = this.__childPart) == null ? void 0 : _a4.setConnected(true);
  }
  /**
   * Invoked when the component is removed from the document's DOM.
   *
   * This callback is the main signal to the element that it may no longer be
   * used. `disconnectedCallback()` should ensure that nothing is holding a
   * reference to the element (such as event listeners added to nodes external
   * to the element), so that it is free to be garbage collected.
   *
   * ```ts
   * disconnectedCallback() {
   *   super.disconnectedCallback();
   *   window.removeEventListener('keydown', this._handleKeydown);
   * }
   * ```
   *
   * An element may be re-connected after being disconnected.
   *
   * @category lifecycle
   */
  disconnectedCallback() {
    var _a4;
    super.disconnectedCallback();
    (_a4 = this.__childPart) == null ? void 0 : _a4.setConnected(false);
  }
  /**
   * Invoked on each update to perform rendering tasks. This method may return
   * any value renderable by lit-html's `ChildPart` - typically a
   * `TemplateResult`. Setting properties inside this method will *not* trigger
   * the element to update.
   * @category rendering
   */
  render() {
    return noChange;
  }
};
LitElement["_$litElement$"] = true;
LitElement[JSCompiler_renameProperty2("finalized", LitElement)] = true;
var _a3;
(_a3 = global5.litElementHydrateSupport) == null ? void 0 : _a3.call(global5, { LitElement });
var polyfillSupport3 = DEV_MODE3 ? global5.litElementPolyfillSupportDevMode : global5.litElementPolyfillSupport;
polyfillSupport3 == null ? void 0 : polyfillSupport3({ LitElement });
(global5.litElementVersions ?? (global5.litElementVersions = [])).push("4.2.1");
if (DEV_MODE3 && global5.litElementVersions.length > 1) {
  queueMicrotask(() => {
    issueWarning3("multiple-versions", `Multiple versions of Lit loaded. Loading multiple versions is not recommended.`);
  });
}

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeConstantsUtil.js
var colors = {
  black: "#202020",
  white: "#FFFFFF",
  white010: "rgba(255, 255, 255, 0.1)",
  accent010: "rgba(9, 136, 240, 0.1)",
  accent020: "rgba(9, 136, 240, 0.2)",
  accent030: "rgba(9, 136, 240, 0.3)",
  accent040: "rgba(9, 136, 240, 0.4)",
  accent050: "rgba(9, 136, 240, 0.5)",
  accent060: "rgba(9, 136, 240, 0.6)",
  accent070: "rgba(9, 136, 240, 0.7)",
  accent080: "rgba(9, 136, 240, 0.8)",
  accent090: "rgba(9, 136, 240, 0.9)",
  accent100: "rgba(9, 136, 240, 1.0)",
  accentSecondary010: "rgba(199, 185, 148, 0.1)",
  accentSecondary020: "rgba(199, 185, 148, 0.2)",
  accentSecondary030: "rgba(199, 185, 148, 0.3)",
  accentSecondary040: "rgba(199, 185, 148, 0.4)",
  accentSecondary050: "rgba(199, 185, 148, 0.5)",
  accentSecondary060: "rgba(199, 185, 148, 0.6)",
  accentSecondary070: "rgba(199, 185, 148, 0.7)",
  accentSecondary080: "rgba(199, 185, 148, 0.8)",
  accentSecondary090: "rgba(199, 185, 148, 0.9)",
  accentSecondary100: "rgba(199, 185, 148, 1.0)",
  productWalletKit: "#FFB800",
  productAppKit: "#FF573B",
  productCloud: "#0988F0",
  productDocumentation: "#008847",
  neutrals050: "#F6F6F6",
  neutrals100: "#F3F3F3",
  neutrals200: "#E9E9E9",
  neutrals300: "#D0D0D0",
  neutrals400: "#BBB",
  neutrals500: "#9A9A9A",
  neutrals600: "#6C6C6C",
  neutrals700: "#4F4F4F",
  neutrals800: "#363636",
  neutrals900: "#2A2A2A",
  neutrals1000: "#252525",
  semanticSuccess010: "rgba(48, 164, 107, 0.1)",
  semanticSuccess020: "rgba(48, 164, 107, 0.2)",
  semanticSuccess030: "rgba(48, 164, 107, 0.3)",
  semanticSuccess040: "rgba(48, 164, 107, 0.4)",
  semanticSuccess050: "rgba(48, 164, 107, 0.5)",
  semanticSuccess060: "rgba(48, 164, 107, 0.6)",
  semanticSuccess070: "rgba(48, 164, 107, 0.7)",
  semanticSuccess080: "rgba(48, 164, 107, 0.8)",
  semanticSuccess090: "rgba(48, 164, 107, 0.9)",
  semanticSuccess100: "rgba(48, 164, 107, 1.0)",
  semanticError010: "rgba(223, 74, 52, 0.1)",
  semanticError020: "rgba(223, 74, 52, 0.2)",
  semanticError030: "rgba(223, 74, 52, 0.3)",
  semanticError040: "rgba(223, 74, 52, 0.4)",
  semanticError050: "rgba(223, 74, 52, 0.5)",
  semanticError060: "rgba(223, 74, 52, 0.6)",
  semanticError070: "rgba(223, 74, 52, 0.7)",
  semanticError080: "rgba(223, 74, 52, 0.8)",
  semanticError090: "rgba(223, 74, 52, 0.9)",
  semanticError100: "rgba(223, 74, 52, 1.0)",
  semanticWarning010: "rgba(243, 161, 63, 0.1)",
  semanticWarning020: "rgba(243, 161, 63, 0.2)",
  semanticWarning030: "rgba(243, 161, 63, 0.3)",
  semanticWarning040: "rgba(243, 161, 63, 0.4)",
  semanticWarning050: "rgba(243, 161, 63, 0.5)",
  semanticWarning060: "rgba(243, 161, 63, 0.6)",
  semanticWarning070: "rgba(243, 161, 63, 0.7)",
  semanticWarning080: "rgba(243, 161, 63, 0.8)",
  semanticWarning090: "rgba(243, 161, 63, 0.9)",
  semanticWarning100: "rgba(243, 161, 63, 1.0)"
};
var tokens = {
  core: {
    backgroundAccentPrimary: "#0988F0",
    backgroundAccentCertified: "#C7B994",
    backgroundWalletKit: "#FFB800",
    backgroundAppKit: "#FF573B",
    backgroundCloud: "#0988F0",
    backgroundDocumentation: "#008847",
    backgroundSuccess: "rgba(48, 164, 107, 0.20)",
    backgroundError: "rgba(223, 74, 52, 0.20)",
    backgroundWarning: "rgba(243, 161, 63, 0.20)",
    textAccentPrimary: "#0988F0",
    textAccentCertified: "#C7B994",
    textWalletKit: "#FFB800",
    textAppKit: "#FF573B",
    textCloud: "#0988F0",
    textDocumentation: "#008847",
    textSuccess: "#30A46B",
    textError: "#DF4A34",
    textWarning: "#F3A13F",
    borderAccentPrimary: "#0988F0",
    borderSecondary: "#C7B994",
    borderSuccess: "#30A46B",
    borderError: "#DF4A34",
    borderWarning: "#F3A13F",
    foregroundAccent010: "rgba(9, 136, 240, 0.1)",
    foregroundAccent020: "rgba(9, 136, 240, 0.2)",
    foregroundAccent040: "rgba(9, 136, 240, 0.4)",
    foregroundAccent060: "rgba(9, 136, 240, 0.6)",
    foregroundSecondary020: "rgba(199, 185, 148, 0.2)",
    foregroundSecondary040: "rgba(199, 185, 148, 0.4)",
    foregroundSecondary060: "rgba(199, 185, 148, 0.6)",
    iconAccentPrimary: "#0988F0",
    iconAccentCertified: "#C7B994",
    iconSuccess: "#30A46B",
    iconError: "#DF4A34",
    iconWarning: "#F3A13F",
    glass010: "rgba(255, 255, 255, 0.1)",
    zIndex: "9999"
  },
  dark: {
    overlay: "rgba(0, 0, 0, 0.50)",
    backgroundPrimary: "#202020",
    backgroundInvert: "#FFFFFF",
    textPrimary: "#FFFFFF",
    textSecondary: "#9A9A9A",
    textTertiary: "#BBBBBB",
    textInvert: "#202020",
    borderPrimary: "#2A2A2A",
    borderPrimaryDark: "#363636",
    borderSecondary: "#4F4F4F",
    foregroundPrimary: "#252525",
    foregroundSecondary: "#2A2A2A",
    foregroundTertiary: "#363636",
    iconDefault: "#9A9A9A",
    iconInverse: "#FFFFFF"
  },
  light: {
    overlay: "rgba(230 , 230, 230, 0.5)",
    backgroundPrimary: "#FFFFFF",
    borderPrimaryDark: "#E9E9E9",
    backgroundInvert: "#202020",
    textPrimary: "#202020",
    textSecondary: "#9A9A9A",
    textTertiary: "#6C6C6C",
    textInvert: "#FFFFFF",
    borderPrimary: "#E9E9E9",
    borderSecondary: "#D0D0D0",
    foregroundPrimary: "#F3F3F3",
    foregroundSecondary: "#E9E9E9",
    foregroundTertiary: "#D0D0D0",
    iconDefault: "#9A9A9A",
    iconInverse: "#202020"
  }
};
var borderRadius = {
  "1": "4px",
  "2": "8px",
  "10": "10px",
  "3": "12px",
  "4": "16px",
  "6": "24px",
  "5": "20px",
  "8": "32px",
  "16": "64px",
  "20": "80px",
  "32": "128px",
  "64": "256px",
  "128": "512px",
  round: "9999px"
};
var spacing = {
  "0": "0px",
  "01": "2px",
  "1": "4px",
  "2": "8px",
  "3": "12px",
  "4": "16px",
  "5": "20px",
  "6": "24px",
  "7": "28px",
  "8": "32px",
  "9": "36px",
  "10": "40px",
  "12": "48px",
  "14": "56px",
  "16": "64px",
  "20": "80px",
  "32": "128px",
  "64": "256px"
};
var fontFamily = {
  regular: "KHTeka",
  mono: "KHTekaMono"
};
var fontWeight = {
  regular: "400",
  medium: "500"
};
var textSize = {
  h1: "50px",
  h2: "44px",
  h3: "38px",
  h4: "32px",
  h5: "26px",
  h6: "20px",
  large: "16px",
  medium: "14px",
  small: "12px"
};
var typography = {
  "h1-regular-mono": { lineHeight: "50px", letterSpacing: "-3px" },
  "h1-regular": { lineHeight: "50px", letterSpacing: "-1px" },
  "h1-medium": { lineHeight: "50px", letterSpacing: "-0.84px" },
  "h2-regular-mono": { lineHeight: "44px", letterSpacing: "-2.64px" },
  "h2-regular": { lineHeight: "44px", letterSpacing: "-0.88px" },
  "h2-medium": { lineHeight: "44px", letterSpacing: "-0.88px" },
  "h3-regular-mono": { lineHeight: "38px", letterSpacing: "-2.28px" },
  "h3-regular": { lineHeight: "38px", letterSpacing: "-0.76px" },
  "h3-medium": { lineHeight: "38px", letterSpacing: "-0.76px" },
  "h4-regular-mono": { lineHeight: "32px", letterSpacing: "-1.92px" },
  "h4-regular": { lineHeight: "32px", letterSpacing: "-0.32px" },
  "h4-medium": { lineHeight: "32px", letterSpacing: "-0.32px" },
  "h5-regular-mono": { lineHeight: "26px", letterSpacing: "-1.56px" },
  "h5-regular": { lineHeight: "26px", letterSpacing: "-0.26px" },
  "h5-medium": { lineHeight: "26px", letterSpacing: "-0.26px" },
  "h6-regular-mono": { lineHeight: "20px", letterSpacing: "-1.2px" },
  "h6-regular": { lineHeight: "20px", letterSpacing: "-0.6px" },
  "h6-medium": { lineHeight: "20px", letterSpacing: "-0.6px" },
  "lg-regular-mono": { lineHeight: "16px", letterSpacing: "-0.96px" },
  "lg-regular": { lineHeight: "18px", letterSpacing: "-0.16px" },
  "lg-medium": { lineHeight: "18px", letterSpacing: "-0.16px" },
  "md-regular-mono": { lineHeight: "14px", letterSpacing: "-0.84px" },
  "md-regular": { lineHeight: "16px", letterSpacing: "-0.14px" },
  "md-medium": { lineHeight: "16px", letterSpacing: "-0.14px" },
  "sm-regular-mono": { lineHeight: "12px", letterSpacing: "-0.72px" },
  "sm-regular": { lineHeight: "14px", letterSpacing: "-0.12px" },
  "sm-medium": { lineHeight: "14px", letterSpacing: "-0.12px" }
};
var easings = {
  "ease-out-power-2": "cubic-bezier(0.23, 0.09, 0.08, 1.13)",
  "ease-out-power-1": "cubic-bezier(0.12, 0.04, 0.2, 1.06)",
  "ease-in-power-2": "cubic-bezier(0.92, -0.13, 0.77, 0.91)",
  "ease-in-power-1": "cubic-bezier(0.88, -0.06, 0.8, 0.96)",
  "ease-inout-power-2": "cubic-bezier(0.77, 0.09, 0.23, 1.13)",
  "ease-inout-power-1": "cubic-bezier(0.88, 0.04, 0.12, 1.06)"
};
var durations = {
  xl: "400ms",
  lg: "200ms",
  md: "125ms",
  sm: "75ms"
};
var styles = {
  colors,
  fontFamily,
  fontWeight,
  textSize,
  typography,
  tokens: {
    core: tokens.core,
    theme: tokens.dark
  },
  borderRadius,
  spacing,
  durations,
  easings
};

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeHelperUtil.js
var PREFIX_VAR = "--apkt";
var ThemeHelperUtil = {
  createCSSVariables(styles2) {
    const cssVariables = {};
    const cssVariablesVarPrefix = {};
    function createVars(_styles, parent, currentVar = "") {
      for (const [styleKey, styleValue] of Object.entries(_styles)) {
        const variable = currentVar ? `${currentVar}-${styleKey}` : styleKey;
        if (styleValue && typeof styleValue === "object" && Object.keys(styleValue).length) {
          parent[styleKey] = {};
          createVars(styleValue, parent[styleKey], variable);
        } else if (typeof styleValue === "string") {
          parent[styleKey] = `${PREFIX_VAR}-${variable}`;
        }
      }
    }
    function addVarsPrefix(_styles, parent) {
      for (const [key, value] of Object.entries(_styles)) {
        if (value && typeof value === "object") {
          parent[key] = {};
          addVarsPrefix(value, parent[key]);
        } else if (typeof value === "string") {
          parent[key] = `var(${value})`;
        }
      }
    }
    createVars(styles2, cssVariables);
    addVarsPrefix(cssVariables, cssVariablesVarPrefix);
    return { cssVariables, cssVariablesVarPrefix };
  },
  assignCSSVariables(vars2, styles2) {
    const assignedCSSVariables = {};
    function assignVars(_vars, _styles, variable) {
      for (const [varKey, varValue] of Object.entries(_vars)) {
        const nextVariable = variable ? `${variable}-${varKey}` : varKey;
        const styleValues = _styles[varKey];
        if (varValue && typeof varValue === "object") {
          assignVars(varValue, styleValues, nextVariable);
        } else if (typeof styleValues === "string") {
          assignedCSSVariables[`${PREFIX_VAR}-${nextVariable}`] = styleValues;
        }
      }
    }
    assignVars(vars2, styles2);
    return assignedCSSVariables;
  },
  createRootStyles(theme, themeVariables) {
    const styles2 = {
      ...styles,
      tokens: { ...styles.tokens, theme: theme === "light" ? tokens.light : tokens.dark }
    };
    const { cssVariables } = ThemeHelperUtil.createCSSVariables(styles2);
    const assignedCSSVariables = ThemeHelperUtil.assignCSSVariables(cssVariables, styles2);
    const w3mVariables = ThemeHelperUtil.generateW3MVariables(themeVariables);
    const w3mOverrides = ThemeHelperUtil.generateW3MOverrides(themeVariables);
    const scaledVariables = ThemeHelperUtil.generateScaledVariables(themeVariables);
    const baseVariables = ThemeHelperUtil.generateBaseVariables(assignedCSSVariables);
    const allVariables = {
      ...assignedCSSVariables,
      ...baseVariables,
      ...w3mVariables,
      ...w3mOverrides,
      ...scaledVariables
    };
    const colorMixVariables = ThemeHelperUtil.applyColorMixToVariables(themeVariables, allVariables);
    const finalVariables = {
      ...allVariables,
      ...colorMixVariables
    };
    const rootStyles = Object.entries(finalVariables).map(([key, style]) => `${key}:${style.replace("/[:;{}</>]/g", "")};`).join("");
    return `:root {${rootStyles}}`;
  },
  generateW3MVariables(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const variables = {};
    variables["--w3m-font-family"] = themeVariables["--w3m-font-family"] || "KHTeka";
    variables["--w3m-accent"] = themeVariables["--w3m-accent"] || "#0988F0";
    variables["--w3m-color-mix"] = themeVariables["--w3m-color-mix"] || "#000";
    variables["--w3m-color-mix-strength"] = `${themeVariables["--w3m-color-mix-strength"] || 0}%`;
    variables["--w3m-font-size-master"] = themeVariables["--w3m-font-size-master"] || "10px";
    variables["--w3m-border-radius-master"] = themeVariables["--w3m-border-radius-master"] || "4px";
    return variables;
  },
  generateW3MOverrides(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const overrides = {};
    if (themeVariables["--w3m-accent"]) {
      const accentColor = themeVariables["--w3m-accent"];
      overrides["--apkt-tokens-core-iconAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-borderAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-textAccentPrimary"] = accentColor;
      overrides["--apkt-tokens-core-backgroundAccentPrimary"] = accentColor;
    }
    if (themeVariables["--w3m-font-family"]) {
      overrides["--apkt-fontFamily-regular"] = themeVariables["--w3m-font-family"];
    }
    if (themeVariables["--w3m-z-index"]) {
      overrides["--apkt-tokens-core-zIndex"] = `${themeVariables["--w3m-z-index"]}`;
    }
    return overrides;
  },
  generateScaledVariables(themeVariables) {
    if (!themeVariables) {
      return {};
    }
    const scaledVars = {};
    if (themeVariables["--w3m-font-size-master"]) {
      const masterSize = parseFloat(themeVariables["--w3m-font-size-master"].replace("px", ""));
      scaledVars["--apkt-textSize-h1"] = `${Number(masterSize) * 5}px`;
      scaledVars["--apkt-textSize-h2"] = `${Number(masterSize) * 4.4}px`;
      scaledVars["--apkt-textSize-h3"] = `${Number(masterSize) * 3.8}px`;
      scaledVars["--apkt-textSize-h4"] = `${Number(masterSize) * 3.2}px`;
      scaledVars["--apkt-textSize-h5"] = `${Number(masterSize) * 2.6}px`;
      scaledVars["--apkt-textSize-h6"] = `${Number(masterSize) * 2}px`;
      scaledVars["--apkt-textSize-large"] = `${Number(masterSize) * 1.6}px`;
      scaledVars["--apkt-textSize-medium"] = `${Number(masterSize) * 1.4}px`;
      scaledVars["--apkt-textSize-small"] = `${Number(masterSize) * 1.2}px`;
    }
    if (themeVariables["--w3m-border-radius-master"]) {
      const masterRadius = parseFloat(themeVariables["--w3m-border-radius-master"].replace("px", ""));
      scaledVars["--apkt-borderRadius-1"] = `${Number(masterRadius)}px`;
      scaledVars["--apkt-borderRadius-2"] = `${Number(masterRadius) * 2}px`;
      scaledVars["--apkt-borderRadius-3"] = `${Number(masterRadius) * 3}px`;
      scaledVars["--apkt-borderRadius-4"] = `${Number(masterRadius) * 4}px`;
      scaledVars["--apkt-borderRadius-5"] = `${Number(masterRadius) * 5}px`;
      scaledVars["--apkt-borderRadius-6"] = `${Number(masterRadius) * 6}px`;
      scaledVars["--apkt-borderRadius-8"] = `${Number(masterRadius) * 8}px`;
      scaledVars["--apkt-borderRadius-16"] = `${Number(masterRadius) * 16}px`;
      scaledVars["--apkt-borderRadius-20"] = `${Number(masterRadius) * 20}px`;
      scaledVars["--apkt-borderRadius-32"] = `${Number(masterRadius) * 32}px`;
      scaledVars["--apkt-borderRadius-64"] = `${Number(masterRadius) * 64}px`;
      scaledVars["--apkt-borderRadius-128"] = `${Number(masterRadius) * 128}px`;
    }
    return scaledVars;
  },
  generateColorMixCSS(themeVariables, allVariables) {
    if (!(themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || !themeVariables["--w3m-color-mix-strength"]) {
      return "";
    }
    const colorMix = themeVariables["--w3m-color-mix"];
    const strength = themeVariables["--w3m-color-mix-strength"];
    if (!strength || strength === 0) {
      return "";
    }
    const colorVariables = Object.keys(allVariables || {}).filter((key) => {
      const isColorToken = key.includes("-tokens-core-background") || key.includes("-tokens-core-text") || key.includes("-tokens-core-border") || key.includes("-tokens-core-foreground") || key.includes("-tokens-core-icon") || key.includes("-tokens-theme-background") || key.includes("-tokens-theme-text") || key.includes("-tokens-theme-border") || key.includes("-tokens-theme-foreground") || key.includes("-tokens-theme-icon");
      const isDimensional = key.includes("-borderRadius-") || key.includes("-spacing-") || key.includes("-textSize-") || key.includes("-fontFamily-") || key.includes("-fontWeight-") || key.includes("-typography-") || key.includes("-duration-") || key.includes("-ease-") || key.includes("-path-") || key.includes("-width-") || key.includes("-height-") || key.includes("-visual-size-") || key.includes("-modal-width") || key.includes("-cover");
      return isColorToken && !isDimensional;
    });
    if (colorVariables.length === 0) {
      return "";
    }
    const colorMixVariables = colorVariables.map((key) => {
      const originalValue = (allVariables == null ? void 0 : allVariables[key]) || "";
      if (originalValue.includes("color-mix") || originalValue.startsWith("#") || originalValue.startsWith("rgb")) {
        return `${key}: color-mix(in srgb, ${colorMix} ${strength}%, ${originalValue});`;
      }
      return `${key}: color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base, ${originalValue}));`;
    }).join("");
    return ` @supports (background: color-mix(in srgb, white 50%, black)) {
      :root {
        ${colorMixVariables}
      }
    }`;
  },
  generateBaseVariables(assignedCSSVariables) {
    const baseVariables = {};
    const themeBackgroundPrimary = assignedCSSVariables["--apkt-tokens-theme-backgroundPrimary"];
    if (themeBackgroundPrimary) {
      baseVariables["--apkt-tokens-theme-backgroundPrimary-base"] = themeBackgroundPrimary;
    }
    const coreBackgroundAccentPrimary = assignedCSSVariables["--apkt-tokens-core-backgroundAccentPrimary"];
    if (coreBackgroundAccentPrimary) {
      baseVariables["--apkt-tokens-core-backgroundAccentPrimary-base"] = coreBackgroundAccentPrimary;
    }
    return baseVariables;
  },
  applyColorMixToVariables(themeVariables, allVariables) {
    const colorMixVariables = {};
    if (allVariables == null ? void 0 : allVariables["--apkt-tokens-theme-backgroundPrimary"]) {
      colorMixVariables["--apkt-tokens-theme-backgroundPrimary"] = "var(--apkt-tokens-theme-backgroundPrimary-base)";
    }
    if (allVariables == null ? void 0 : allVariables["--apkt-tokens-core-backgroundAccentPrimary"]) {
      colorMixVariables["--apkt-tokens-core-backgroundAccentPrimary"] = "var(--apkt-tokens-core-backgroundAccentPrimary-base)";
    }
    if (!(themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || !themeVariables["--w3m-color-mix-strength"]) {
      return colorMixVariables;
    }
    const colorMix = themeVariables["--w3m-color-mix"];
    const strength = themeVariables["--w3m-color-mix-strength"];
    if (!strength || strength === 0) {
      return colorMixVariables;
    }
    const colorVariables = Object.keys(allVariables || {}).filter((key) => {
      const isColorToken = key.includes("-tokens-core-background") || key.includes("-tokens-core-text") || key.includes("-tokens-core-border") || key.includes("-tokens-core-foreground") || key.includes("-tokens-core-icon") || key.includes("-tokens-theme-background") || key.includes("-tokens-theme-text") || key.includes("-tokens-theme-border") || key.includes("-tokens-theme-foreground") || key.includes("-tokens-theme-icon") || key.includes("-tokens-theme-overlay");
      const isDimensional = key.includes("-borderRadius-") || key.includes("-spacing-") || key.includes("-textSize-") || key.includes("-fontFamily-") || key.includes("-fontWeight-") || key.includes("-typography-") || key.includes("-duration-") || key.includes("-ease-") || key.includes("-path-") || key.includes("-width-") || key.includes("-height-") || key.includes("-visual-size-") || key.includes("-modal-width") || key.includes("-cover");
      return isColorToken && !isDimensional;
    });
    if (colorVariables.length === 0) {
      return colorMixVariables;
    }
    colorVariables.forEach((key) => {
      const originalValue = (allVariables == null ? void 0 : allVariables[key]) || "";
      if (key.endsWith("-base")) {
        return;
      }
      if (key === "--apkt-tokens-theme-backgroundPrimary" || key === "--apkt-tokens-core-backgroundAccentPrimary") {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base))`;
      } else if (originalValue.includes("color-mix") || originalValue.startsWith("#") || originalValue.startsWith("rgb")) {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, ${originalValue})`;
      } else {
        colorMixVariables[key] = `color-mix(in srgb, ${colorMix} ${strength}%, var(${key}-base, ${originalValue}))`;
      }
    });
    return colorMixVariables;
  }
};
var { cssVariablesVarPrefix: vars } = ThemeHelperUtil.createCSSVariables(styles);
function css2(strings, ...values) {
  return css(strings, ...values.map((value) => typeof value === "function" ? unsafeCSS(value(vars)) : unsafeCSS(value)));
}

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js
var apktTag = void 0;
var themeTag = void 0;
var darkModeTag = void 0;
var lightModeTag = void 0;
var currentThemeVariables = void 0;
var fonts = {
  "KHTeka-500-woff2": "https://fonts.reown.com/KHTeka-Medium.woff2",
  "KHTeka-400-woff2": "https://fonts.reown.com/KHTeka-Regular.woff2",
  "KHTeka-300-woff2": "https://fonts.reown.com/KHTeka-Light.woff2",
  "KHTekaMono-400-woff2": "https://fonts.reown.com/KHTekaMono-Regular.woff2",
  "KHTeka-500-woff": "https://fonts.reown.com/KHTeka-Light.woff",
  "KHTeka-400-woff": "https://fonts.reown.com/KHTeka-Regular.woff",
  "KHTeka-300-woff": "https://fonts.reown.com/KHTeka-Light.woff",
  "KHTekaMono-400-woff": "https://fonts.reown.com/KHTekaMono-Regular.woff"
};
function createAppKitTheme(themeVariables, theme = "dark") {
  if (apktTag) {
    document.head.removeChild(apktTag);
  }
  apktTag = document.createElement("style");
  apktTag.textContent = ThemeHelperUtil.createRootStyles(theme, themeVariables);
  document.head.appendChild(apktTag);
}
function initializeTheming(themeVariables, themeMode = "dark") {
  currentThemeVariables = themeVariables;
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  createAppKitTheme(themeVariables, themeMode);
  setColorTheme(themeMode);
  if (!(themeVariables == null ? void 0 : themeVariables["--w3m-font-family"])) {
    for (const [key, url] of Object.entries(fonts)) {
      const link = document.createElement("link");
      link.rel = "preload";
      link.href = url;
      link.as = "font";
      link.type = key.includes("woff2") ? "font/woff2" : "font/woff";
      link.crossOrigin = "anonymous";
      document.head.appendChild(link);
    }
  }
  setColorTheme(themeMode);
}
function setColorTheme(themeMode = "dark") {
  if (darkModeTag && lightModeTag && apktTag) {
    if (themeMode === "light") {
      createAppKitTheme(currentThemeVariables, themeMode);
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      createAppKitTheme(currentThemeVariables, themeMode);
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(_themeVariables) {
  var _a4, _b2, _c;
  currentThemeVariables = _themeVariables;
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(_themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(_themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(_themeVariables).light.cssText;
    if (_themeVariables == null ? void 0 : _themeVariables["--w3m-font-family"]) {
      const fontFamily2 = _themeVariables["--w3m-font-family"];
      themeTag.textContent = (_a4 = themeTag.textContent) == null ? void 0 : _a4.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
      darkModeTag.textContent = (_b2 = darkModeTag.textContent) == null ? void 0 : _b2.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
      lightModeTag.textContent = (_c = lightModeTag.textContent) == null ? void 0 : _c.replace("font-family: KHTeka", `font-family: ${fontFamily2}`);
    }
  }
  if (apktTag) {
    const currentMode = (lightModeTag == null ? void 0 : lightModeTag.media) === "enabled" ? "light" : "dark";
    createAppKitTheme(_themeVariables, currentMode);
  }
}
function createRootStyles(_themeVariables) {
  const hasCustomFontFamily = Boolean(_themeVariables == null ? void 0 : _themeVariables["--w3m-font-family"]);
  return {
    core: css`
      ${hasCustomFontFamily ? css`` : css`
            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
              font-display: swap;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-300-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-300-woff"])}) format('woff');
              font-weight: 300;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTekaMono';
              src:
                url(${unsafeCSS(fonts["KHTekaMono-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTekaMono-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }

            @font-face {
              font-family: 'KHTeka';
              src:
                url(${unsafeCSS(fonts["KHTeka-400-woff2"])}) format('woff2'),
                url(${unsafeCSS(fonts["KHTeka-400-woff"])}) format('woff');
              font-weight: 400;
              font-style: normal;
            }
          `}

      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --apkt-modal-width: 370px;

        --apkt-visual-size-inherit: inherit;
        --apkt-visual-size-sm: 40px;
        --apkt-visual-size-md: 55px;
        --apkt-visual-size-lg: 80px;

        --apkt-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --apkt-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --apkt-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --apkt-width-network-sm: 36px;
        --apkt-width-network-md: 48px;
        --apkt-width-network-lg: 86px;

        --apkt-duration-dynamic: 0ms;
        --apkt-height-network-sm: 40px;
        --apkt-height-network-md: 54px;
        --apkt-height-network-lg: 96px;
      }
    `,
    dark: css`
      :root {
      }
    `,
    light: css`
      :root {
      }
    `
  };
}
var resetStyles = css`
  div,
  span,
  iframe,
  a,
  img,
  form,
  button,
  label,
  *::after,
  *::before {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    backface-visibility: hidden;
  }

  :host {
    font-family: var(--apkt-fontFamily-regular);
  }
`;
var elementStyles = css`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;

    will-change: background-color, color, border, box-shadow, width, height, transform, opacity;
    outline: none;
    border: none;
    text-decoration: none;
    transition:
      background-color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      color var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      box-shadow var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      width var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      height var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      transform var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      opacity var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      scale var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2),
      border-radius var(--apkt-durations-lg) var(--apkt-easings-ease-out-power-2);
    will-change:
      background-color, color, border, box-shadow, width, height, transform, opacity, scale,
      border-radius;
  }

  a:active:not([disabled]),
  button:active:not([disabled]) {
    scale: 0.975;
    transform-origin: center;
  }

  button:disabled {
    cursor: default;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;

// node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js
var DECIMAL_POINT = ".";
var UiHelperUtil = {
  getSpacingStyles(spacing2, index) {
    if (Array.isArray(spacing2)) {
      return spacing2[index] ? `var(--apkt-spacing-${spacing2[index]})` : void 0;
    } else if (typeof spacing2 === "string") {
      return `var(--apkt-spacing-${spacing2})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  formatCurrency(amount = 0, options = {}) {
    const numericAmount = Number(amount);
    if (isNaN(numericAmount)) {
      return "$0.00";
    }
    const formatter = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
      ...options
    });
    return formatter.format(numericAmount);
  },
  getHostName(url) {
    try {
      const newUrl = new URL(url);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string, charsStart, charsEnd, truncate }) {
    if (string.length <= charsStart + charsEnd) {
      return string;
    }
    if (truncate === "end") {
      return `${string.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string.substring(string.length - charsEnd)}`;
    }
    return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash = address.toLowerCase().replace(/^0x/iu, "").replace(/[^a-f0-9]/gu, "");
    const baseColor = hash.substring(0, 6).padEnd(6, "0");
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius == null ? void 0 : masterBorderRadius.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors2 = [];
    for (let i2 = 0; i2 < 5; i2 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i2);
      colors2.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors2[0]};
    --local-color-2: ${colors2[1]};
    --local-color-3: ${colors2[2]};
    --local-color-4: ${colors2[3]};
    --local-color-5: ${colors2[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g = bigint >> 8 & 255;
    const b = bigint & 255;
    return [r2, g, b];
  },
  tintColor(rgb, tint) {
    const [r2, g, b] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g + (255 - g) * tint);
    const tintedB = Math.round(b + (255 - b) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character) {
    const regex = {
      number: /^[0-9]+$/u
    };
    return regex.number.test(character);
  },
  getColorTheme(theme) {
    var _a4;
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia && typeof window.matchMedia === "function") {
      if ((_a4 = window.matchMedia("(prefers-color-scheme: dark)")) == null ? void 0 : _a4.matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts = input.split(".");
    if (parts.length === 2) {
      return [parts[0], parts[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number, threshold, fixed) {
    const roundedNumber = number.toString().length >= threshold ? Number(number).toFixed(fixed) : number;
    return roundedNumber;
  },
  cssDurationToNumber(duration) {
    if (duration.endsWith("s")) {
      return Number(duration.replace("s", "")) * 1e3;
    } else if (duration.endsWith("ms")) {
      return Number(duration.replace("ms", ""));
    }
    return 0;
  },
  maskInput({ value, decimals, integers }) {
    value = value.replace(",", ".");
    if (value === DECIMAL_POINT) {
      return `0${DECIMAL_POINT}`;
    }
    const [integerPart = "", decimalsPart] = value.split(DECIMAL_POINT).map((p) => p.replace(/[^0-9]/gu, ""));
    const limitedInteger = integers ? integerPart.substring(0, integers) : integerPart;
    const cleanIntegerPart = limitedInteger.length === 2 ? String(Number(limitedInteger)) : limitedInteger;
    const cleanDecimalsPart = typeof decimals === "number" ? decimalsPart == null ? void 0 : decimalsPart.substring(0, decimals) : decimalsPart;
    const canIncludeDecimals = typeof decimals !== "number" || decimals > 0;
    const maskValue = typeof cleanDecimalsPart === "string" && canIncludeDecimals ? [cleanIntegerPart, cleanDecimalsPart].join(DECIMAL_POINT) : cleanIntegerPart;
    return maskValue ?? "";
  },
  capitalize(value) {
    if (!value) {
      return "";
    }
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
};

// node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create2(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil3 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  },
  VIEWS_WITH_LEGAL_FOOTER: [
    "Connect",
    "ConnectWallets",
    "OnRampTokenSelect",
    "OnRampFiatSelect",
    "OnRampProviders"
  ],
  VIEWS_WITH_DEFAULT_FOOTER: ["Networks"]
};

export {
  ProviderController,
  OnRampController,
  AlertController,
  SwapController,
  TooltipController,
  EnsController,
  baseUSDC,
  baseSepoliaUSDC,
  SIWXUtil,
  ModalUtil,
  ConstantsUtil3 as ConstantsUtil,
  css,
  defaultConverter,
  notEqual,
  html,
  svg,
  mathml,
  noChange,
  nothing,
  _$LH,
  LitElement,
  vars,
  css2,
  initializeTheming,
  setColorTheme,
  setThemeVariables,
  resetStyles,
  elementStyles,
  UiHelperUtil,
  customElement
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

lit-html/development/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/development/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/development/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-I7D56A7P.js.map
