import {
  CaipNetworksUtil,
  ConnectorUtil,
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  LoggerUtil,
  PresetsUtil,
  SemVerUtils,
  TokenUtil,
  WalletUtil
} from "./chunk-OZEIBQXI.js";
import {
  AlertController,
  EnsController,
  OnRampController,
  ProviderController,
  SIWXUtil,
  setColorTheme,
  setThemeVariables
} from "./chunk-I7D56A7P.js";
import "./chunk-URUUDYQZ.js";
import "./chunk-JKEYR2OQ.js";
import "./chunk-5GTPK223.js";
import {
  Chi,
  HashMD,
  Maj
} from "./chunk-K3RD5TKS.js";
import {
  BaseError as BaseError2,
  LruMap,
  checksumAddress,
  concat as concat2,
  defineFormatter,
  from,
  fromBoolean,
  fromBytes,
  fromNumber,
  fromString as fromString2,
  fromString2 as fromString3,
  hexToBigInt as hexToBigInt2,
  hexToNumber as hexToNumber2,
  isHex,
  keccak256,
  keccak_256,
  numberToHex as numberToHex2,
  padLeft,
  padRight,
  size,
  size2,
  toHex as toHex2
} from "./chunk-YAJTXCSD.js";
import {
  clean,
  createHasher,
  rotl
} from "./chunk-DVCKQDEZ.js";
import {
  ApiController,
  AssetUtil,
  BlockchainApiController,
  ChainController,
  ConnectionController,
  ConnectionControllerUtil,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  ModalController,
  NetworkUtil,
  OptionsController,
  ParseUtil,
  PublicStateController,
  RouterController,
  SendController,
  SnackController,
  StorageUtil,
  ThemeController,
  UserRejectedRequestError,
  getPreferredAccountType
} from "./chunk-UQBMRNYB.js";
import {
  C,
  IEvents,
  Po,
  Qe,
  Qo,
  concat,
  decode,
  destr,
  detect,
  encode,
  esm_default,
  esm_exports,
  f,
  f2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  fromString,
  getBigIntRpcId,
  i,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  o,
  payloadId,
  r,
  require_blakejs,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_events,
  require_quick_format_unescaped,
  safeJsonParse,
  safeJsonStringify,
  sn,
  toString
} from "./chunk-T6HKKWQ2.js";
import {
  base32,
  clear,
  createStore,
  del,
  get,
  keys,
  set
} from "./chunk-NM3AWL5M.js";
import {
  AccountNotFoundError,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  formatLog,
  formatTransaction,
  serializeAccessList,
  serializeTransaction,
  sha256,
  toRlp,
  toYParitySignatureArray
} from "./chunk-O2S2GY3Y.js";
import {
  BaseError,
  FeeCapTooHighError,
  InvalidAddressError,
  InvalidChainIdError,
  TipAboveFeeCapError,
  assertRequest,
  concatHex,
  defineTransactionRequest,
  extract,
  formatTransactionRequest,
  getCallError,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  isAddress,
  maxUint16,
  maxUint256,
  numberToHex,
  pad,
  parseAccount,
  toBytes,
  toHex,
  trim
} from "./chunk-T5I2KZ6F.js";
import "./chunk-XDVZA6Z7.js";
import "./chunk-IKWKDL2L.js";
import "./chunk-QMDVOU32.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OS7ZSSJM.js";

// node_modules/@reown/appkit/node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/@reown/appkit/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers4) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k4) {
          return k4 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers4);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers4 = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers4);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers4;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers4, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback2) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts3 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i4 = 0; i4 < args.length; i4++) args[i4] = arguments[i4];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts3));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts: ts3,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts3) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o2 = {};
      if (ts3) {
        o2.time = ts3;
      }
      o2.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o2, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o2.msg = msg;
      return o2;
    }
    function applySerializers(args, serialize, serializers4, stdErrSerialize) {
      for (const i4 in args) {
        if (stdErrSerialize && args[i4] instanceof Error) {
          args[i4] = pino.stdSerializers.err(args[i4]);
        } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
          for (const k4 in args[i4]) {
            if (serialize && serialize.indexOf(k4) > -1 && k4 in serializers4) {
              args[i4][k4] = serializers4[k4](args[i4][k4]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i4 = 1; i4 < args.length; i4++) {
          args[i4] = arguments[i4 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts3 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts3;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a2) {
      return a2;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o2) {
        return typeof o2 !== "undefined" && o2;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@reown/appkit/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c5) => c5.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a2;
  if (!key) {
    return "";
  }
  return ((_a2 = key.split("?")[0]) == null ? void 0 : _a2.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base2) {
  base2 = normalizeKey(base2);
  return base2 ? base2 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base2) {
  if (base2) {
    return key.startsWith(base2) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@reown/appkit/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base2 of context.mountpoints) {
      if (key.startsWith(base2)) {
        return {
          base: base2,
          relativeKey: key.slice(base2.length),
          driver: context.mounts[base2]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base2, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base2) || includeParent && base2.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base2.length > mountpoint.length ? base2.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base2, opts = {}) {
      var _a2;
      base2 = normalizeBaseKey(base2);
      const mounts = getMounts(base2, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a2 = mount.driver.flags) == null ? void 0 : _a2.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p3) => fullKey.startsWith(p3))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base2)
      );
    },
    // Utils
    async clear(base2, opts = {}) {
      base2 = normalizeBaseKey(base2);
      await Promise.all(
        getMounts(base2, false).map(async (m4) => {
          if (m4.driver.clear) {
            return asyncCall(m4.driver.clear, m4.relativeBase, opts);
          }
          if (m4.driver.removeItem) {
            const keys2 = await m4.driver.getKeys(m4.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m4.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base2, driver) {
      base2 = normalizeBaseKey(base2);
      if (base2 && context.mounts[base2]) {
        throw new Error(`already mounted at ${base2}`);
      }
      if (base2) {
        context.mountpoints.push(base2);
        context.mountpoints.sort((a2, b4) => b4.length - a2.length);
      }
      context.mounts[base2] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base2)).then((unwatcher) => {
          context.unwatch[base2] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base2, _dispose = true) {
      var _a2, _b;
      base2 = normalizeBaseKey(base2);
      if (!base2 || !context.mounts[base2]) {
        return;
      }
      if (context.watching && base2 in context.unwatch) {
        (_b = (_a2 = context.unwatch)[base2]) == null ? void 0 : _b.call(_a2);
        delete context.unwatch[base2];
      }
      if (_dispose) {
        await dispose(context.mounts[base2]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base2);
      delete context.mounts[base2];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m4 = getMount(key);
      return {
        driver: m4.driver,
        base: m4.base
      };
    },
    getMounts(base2 = "", opts = {}) {
      base2 = normalizeKey(base2);
      const mounts = getMounts(base2, opts.parents);
      return mounts.map((m4) => ({
        driver: m4.driver,
        base: m4.mountpoint
      }));
    },
    // Aliases
    keys: (base2, opts = {}) => storage.getKeys(base2, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base2) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base2 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@reown/appkit/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i4 = {}) => {
  const t = i4.base && i4.base.length > 0 ? `${i4.base}:` : "", e = (s2) => t + s2;
  let n3;
  return i4.dbName && i4.storeName && (n3 = createStore(i4.dbName, i4.storeName)), { name: x, options: i4, async hasItem(s2) {
    return !(typeof await get(e(s2), n3) > "u");
  }, async getItem(s2) {
    return await get(e(s2), n3) ?? null;
  }, setItem(s2, a2) {
    return set(e(s2), a2, n3);
  }, removeItem(s2) {
    return del(e(s2), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i4;
  function t() {
  }
  i4 = t, i4.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i4.prototype.setItem = function(e, n3) {
    this[e] = String(n3);
  }, i4.prototype.removeItem = function(e) {
    delete this[e];
  }, i4.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n3) {
      e[n3] = void 0, delete e[n3];
    });
  }, i4.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i4.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k(i4) {
  var t;
  return [i4[0], safeJsonParse((t = i4[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y = 1;
var O = async (i4, t, e) => {
  const n3 = N, s2 = await t.getItem(n3);
  if (s2 && s2 >= y) {
    e(t);
    return;
  }
  const a2 = await i4.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m4 = [];
  for (; a2.length; ) {
    const r2 = a2.shift();
    if (!r2) continue;
    const o2 = r2.toLowerCase();
    if (o2.includes("wc@") || o2.includes("walletconnect") || o2.includes("wc_") || o2.includes("wallet_connect")) {
      const f7 = await i4.getItem(r2);
      await t.setItem(r2, f7), m4.push(r2);
    }
  }
  await t.setItem(n3, y), e(t), j(i4, m4);
};
var j = async (i4, t) => {
  t.length && t.forEach(async (e) => {
    await i4.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e = new _();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser());
var import_pino2 = __toESM(require_browser());
var c2 = { level: "info" };
var n = "custom_context";
var l2 = 1e3 * 1024;
var O2 = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const t = new O2(e);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let t = this.head;
    for (; t !== null; ) e.push(t.value), t = t.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: true, value: null };
      const t = e.value;
      return e = e.next, { done: false, value: t };
    } };
  }
};
var L = class {
  constructor(e, t = l2) {
    this.level = e ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, t) {
    t === import_pino.levels.values.error ? console.error(e) : t === import_pino.levels.values.warn ? console.warn(e) : t === import_pino.levels.values.debug ? console.debug(e) : t === import_pino.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const t = typeof e == "string" ? JSON.parse(e).level : e.level;
    t >= this.levelValue && this.forwardToConsole(e, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const t = this.getLogArray();
    return t.push(safeJsonStringify({ extraMetadata: e })), new Blob(t, { type: "application/json" });
  }
};
var m = class {
  constructor(e, t = l2) {
    this.baseChunkLogger = new L(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const t = URL.createObjectURL(this.logsToBlob(e)), o2 = document.createElement("a");
    o2.href = t, o2.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o2), o2.click(), document.body.removeChild(o2), URL.revokeObjectURL(t);
  }
};
var B = class {
  constructor(e, t = l2) {
    this.baseChunkLogger = new L(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var x2 = Object.defineProperty;
var S = Object.defineProperties;
var _2 = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z2 = Object.prototype.propertyIsEnumerable;
var f3 = (r2, e, t) => e in r2 ? x2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var i2 = (r2, e) => {
  for (var t in e || (e = {})) T.call(e, t) && f3(r2, t, e[t]);
  if (p) for (var t of p(e)) z2.call(e, t) && f3(r2, t, e[t]);
  return r2;
};
var g = (r2, e) => S(r2, _2(e));
function k2(r2) {
  return g(i2({}, r2), { level: (r2 == null ? void 0 : r2.level) || c2.level });
}
function v(r2, e = n) {
  return r2[e] || "";
}
function b(r2, e, t = n) {
  return r2[t] = e, r2;
}
function y2(r2, e = n) {
  let t = "";
  return typeof r2.bindings > "u" ? t = v(r2, e) : t = r2.bindings().context || "", t;
}
function w(r2, e, t = n) {
  const o2 = y2(r2, t);
  return o2.trim() ? `${o2}/${e}` : e;
}
function E2(r2, e, t = n) {
  const o2 = w(r2, e, t), a2 = r2.child({ context: o2 });
  return b(a2, o2, t);
}
function C2(r2) {
  var e, t;
  const o2 = new m((e = r2.opts) == null ? void 0 : e.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r2.opts), { level: "trace", browser: g(i2({}, (t = r2.opts) == null ? void 0 : t.browser), { write: (a2) => o2.write(a2) }) })), chunkLoggerController: o2 };
}
function I(r2) {
  var e;
  const t = new B((e = r2.opts) == null ? void 0 : e.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r2.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r2) {
  return typeof r2.loggerOverride < "u" && typeof r2.loggerOverride != "string" ? { logger: r2.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C2(r2) : I(r2);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s2, r2) => s2 in e ? a(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var c3 = (e, s2, r2) => u(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var h3 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, c3(this, "protocol", "wc"), c3(this, "version", 2);
  }
};
var p2 = Object.defineProperty;
var b2 = (e, s2, r2) => s2 in e ? p2(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var v2 = (e, s2, r2) => b2(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var I2 = class extends IEvents {
  constructor(s2, r2) {
    super(), this.core = s2, this.logger = r2, v2(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s2, r2) {
    this.logger = s2, this.core = r2;
  }
};
var m2 = class extends IEvents {
  constructor(s2, r2) {
    super(), this.relayer = s2, this.logger = r2;
  }
};
var d2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var f4 = class {
  constructor(s2, r2, t, q2) {
    this.core = s2, this.logger = r2, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s2, r2) {
    super(), this.relayer = s2, this.logger = r2;
  }
};
var S2 = class extends IEvents {
  constructor(s2, r2) {
    super(), this.core = s2, this.logger = r2;
  }
};
var M = class {
  constructor(s2, r2, t) {
    this.core = s2, this.logger = r2, this.store = t;
  }
};
var O3 = class {
  constructor(s2, r2) {
    this.projectId = s2, this.logger = r2;
  }
};
var R = class {
  constructor(s2, r2, t) {
    this.core = s2, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T2 = Object.defineProperty;
var k3 = (e, s2, r2) => s2 in e ? T2(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var i3 = (e, s2, r2) => k3(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var J = class {
  constructor(s2) {
    this.opts = s2, i3(this, "protocol", "wc"), i3(this, "version", 2);
  }
};
var V = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex2(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-34RCU2SF.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s: s2, v: v5, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v5);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt2(r2), hexToBigInt2(s2)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex2(signature);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction2(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction2 = defineFormatter("transaction", formatTransaction2);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction2(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock2 = defineFormatter("block", formatBlock);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber2(count);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog2(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt2 = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex2(0, {
  size: 32
});

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@reown/appkit/node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: A4, B: B4, C: C6, D: D2, E: E4 } = this;
    return [A4, B4, C6, D2, E4];
  }
  set(A4, B4, C6, D2, E4) {
    this.A = A4 | 0;
    this.B = B4 | 0;
    this.C = C6 | 0;
    this.D = D2 | 0;
    this.E = E4 | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4)
      SHA1_W[i4] = view.getUint32(offset, false);
    for (let i4 = 16; i4 < 80; i4++)
      SHA1_W[i4] = rotl(SHA1_W[i4 - 3] ^ SHA1_W[i4 - 8] ^ SHA1_W[i4 - 14] ^ SHA1_W[i4 - 16], 1);
    let { A: A4, B: B4, C: C6, D: D2, E: E4 } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      let F3, K5;
      if (i4 < 20) {
        F3 = Chi(B4, C6, D2);
        K5 = 1518500249;
      } else if (i4 < 40) {
        F3 = B4 ^ C6 ^ D2;
        K5 = 1859775393;
      } else if (i4 < 60) {
        F3 = Maj(B4, C6, D2);
        K5 = 2400959708;
      } else {
        F3 = B4 ^ C6 ^ D2;
        K5 = 3395469782;
      }
      const T4 = rotl(A4, 5) + F3 + E4 + K5 + SHA1_W[i4] | 0;
      E4 = D2;
      D2 = C6;
      C6 = rotl(B4, 30);
      B4 = A4;
      A4 = T4;
    }
    A4 = A4 + this.A | 0;
    B4 = B4 + this.B | 0;
    C6 = C6 + this.C | 0;
    D2 = D2 + this.D | 0;
    E4 = E4 + this.E | 0;
    this.set(A4, B4, C6, D2, E4);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K2 = Array.from({ length: 64 }, (_4, i4) => Math.floor(p32 * Math.abs(Math.sin(i4 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A: A4, B: B4, C: C6, D: D2 } = this;
    return [A4, B4, C6, D2];
  }
  set(A4, B4, C6, D2) {
    this.A = A4 | 0;
    this.B = B4 | 0;
    this.C = C6 | 0;
    this.D = D2 | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4)
      MD5_W[i4] = view.getUint32(offset, true);
    let { A: A4, B: B4, C: C6, D: D2 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      let F3, g4, s2;
      if (i4 < 16) {
        F3 = Chi(B4, C6, D2);
        g4 = i4;
        s2 = [7, 12, 17, 22];
      } else if (i4 < 32) {
        F3 = Chi(D2, B4, C6);
        g4 = (5 * i4 + 1) % 16;
        s2 = [5, 9, 14, 20];
      } else if (i4 < 48) {
        F3 = B4 ^ C6 ^ D2;
        g4 = (3 * i4 + 5) % 16;
        s2 = [4, 11, 16, 23];
      } else {
        F3 = C6 ^ (B4 | ~D2);
        g4 = 7 * i4 % 16;
        s2 = [6, 10, 15, 21];
      }
      F3 = F3 + A4 + K2[i4] + MD5_W[g4];
      A4 = D2;
      D2 = C6;
      C6 = B4;
      B4 = B4 + rotl(F3, s2[i4 % 4]);
    }
    A4 = A4 + this.A | 0;
    B4 = B4 + this.B | 0;
    C6 = C6 + this.C | 0;
    D2 = D2 + this.D | 0;
    this.set(A4, B4, C6, D2);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_4, i4) => i4)))();
var Pi160 = (() => Id160.map((i4) => (9 * i4 + 5) % 16))();
var idxLR = (() => {
  const L3 = [Id160];
  const R4 = [Pi160];
  const res = [L3, R4];
  for (let i4 = 0; i4 < 4; i4++)
    for (let j3 of res)
      j3.push(j3[i4].map((k4) => Rho160[k4]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i4) => Uint8Array.from(i4));
var shiftsL160 = idxL.map((idx, i4) => idx.map((j3) => shifts160[i4][j3]));
var shiftsR160 = idxR.map((idx, i4) => idx.map((j3) => shifts160[i4][j3]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x5, y5, z6) {
  if (group === 0)
    return x5 ^ y5 ^ z6;
  if (group === 1)
    return x5 & y5 | ~x5 & z6;
  if (group === 2)
    return (x5 | ~y5) ^ z6;
  if (group === 3)
    return x5 & z6 | y5 & ~z6;
  return x5 ^ (y5 | ~z6);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4 } = this;
    return [h0, h1, h22, h32, h4];
  }
  set(h0, h1, h22, h32, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4)
      BUF_160[i4] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar3 = al, bl = this.h1 | 0, br3 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr3 = dl, el = this.h4 | 0, er2 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i4 = 0; i4 < 16; i4++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i4]] + hbl, sl[i4]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i4 = 0; i4 < 16; i4++) {
        const tr = rotl(ar3 + ripemd_f(rGroup, br3, cr2, dr3) + BUF_160[rr3[i4]] + hbr, sr[i4]) + er2 | 0;
        ar3 = er2, er2 = dr3, dr3 = rotl(cr2, 10) | 0, cr2 = br3, br3 = tr;
      }
    }
    this.set(this.h1 + cl + dr3 | 0, this.h2 + dl + er2 | 0, this.h3 + el + ar3 | 0, this.h4 + al + br3 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as: as2 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as2 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError3({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError3({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString2(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash[i4 >> 1] >> 4 >= 8 && characters[i4]) {
      characters[i4] = characters[i4].toUpperCase();
    }
    if ((hash[i4 >> 1] & 15) >= 8 && characters[i4 + 1]) {
      characters[i4 + 1] = characters[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError3 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint162 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2563 = 2n ** 256n - 1n;

// node_modules/@reown/appkit/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i4 = 0; i4 < types.length; i4++) {
    const type = types[i4];
    const value = values[i4];
    data.push(encodePacked2.encode(type, value));
  }
  return concat2(...data);
}
(function(encodePacked3) {
  function encode5(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString3(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits, 10) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4, 10) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4, 10),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i4 = 0; i4 < value.length; i4++) {
        data.push(encode5(childType, value[i4], true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode5;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size2(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var Ae = ":";
function Je(t) {
  const [e, n3] = t.split(Ae);
  return { namespace: e, reference: n3 };
}
function Ie(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Qs = Object.defineProperty;
var ti = Object.defineProperties;
var ei = Object.getOwnPropertyDescriptors;
var ar = Object.getOwnPropertySymbols;
var ni = Object.prototype.hasOwnProperty;
var ri = Object.prototype.propertyIsEnumerable;
var en = (t, e, n3) => e in t ? Qs(t, e, { enumerable: true, configurable: true, writable: true, value: n3 }) : t[e] = n3;
var ur = (t, e) => {
  for (var n3 in e || (e = {})) ni.call(e, n3) && en(t, n3, e[n3]);
  if (ar) for (var n3 of ar(e)) ri.call(e, n3) && en(t, n3, e[n3]);
  return t;
};
var oi = (t, e) => ti(t, ei(e));
var lr = (t, e, n3) => en(t, typeof e != "symbol" ? e + "" : e, n3);
var dr = "ReactNative";
var et = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var pr = "js";
function rn() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function At() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === dr;
}
function ci() {
  return At() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function fi() {
  return At() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Wt() {
  return !rn() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function Vt() {
  return At() ? et.reactNative : rn() ? et.node : Wt() ? et.browser : et.unknown;
}
function ai() {
  var t;
  try {
    return At() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function gr(t, e) {
  const n3 = new URLSearchParams(t);
  return Object.entries(e).sort(([r2], [o2]) => r2.localeCompare(o2)).forEach(([r2, o2]) => {
    o2 != null && n3.set(r2, String(o2));
  }), n3.toString();
}
function ui(t) {
  var e, n3;
  const r2 = br();
  try {
    return t != null && t.url && r2.url && new URL(t.url).host !== new URL(r2.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r2.url}. This is probably unintended and can lead to issues.`), t.url = r2.url), (e = t == null ? void 0 : t.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o2) => o2 !== "")), oi(ur(ur({}, r2), t), { url: (t == null ? void 0 : t.url) || r2.url, name: (t == null ? void 0 : t.name) || r2.name, description: (t == null ? void 0 : t.description) || r2.description, icons: (n3 = t == null ? void 0 : t.icons) != null && n3.length && t.icons.length > 0 ? t.icons : r2.icons });
  } catch (o2) {
    return console.warn("Error populating app metadata", o2), t || r2;
  }
}
function br() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function yr() {
  if (Vt() === et.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n3, Version: r2 } = global.Platform;
    return [n3, r2].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function mr() {
  var t;
  const e = Vt();
  return e === et.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function wr(t, e, n3) {
  const r2 = yr(), o2 = mr();
  return [[t, e].join("-"), [pr, n3].join("-"), r2, o2].join("/");
}
function di({ protocol: t, version: e, relayUrl: n3, sdkVersion: r2, auth: o2, projectId: s2, useOnCloseEvent: i4, bundleId: c5, packageName: f7 }) {
  const u2 = n3.split("?"), a2 = wr(t, e, r2), l4 = { auth: o2, ua: a2, projectId: s2, useOnCloseEvent: i4 || void 0, packageName: f7 || void 0, bundleId: c5 || void 0 }, d5 = gr(u2[1] || "", l4);
  return u2[0] + "?" + d5;
}
function It(t, e) {
  return t.filter((n3) => e.includes(n3)).length === t.length;
}
function bi(t) {
  return Object.fromEntries(t.entries());
}
function yi(t) {
  return new Map(Object.entries(t));
}
function xi(t = import_time.FIVE_MINUTES, e) {
  const n3 = (0, import_time.toMiliseconds)(t || import_time.FIVE_MINUTES);
  let r2, o2, s2, i4;
  return { resolve: (c5) => {
    s2 && r2 && (clearTimeout(s2), r2(c5), i4 = Promise.resolve(c5));
  }, reject: (c5) => {
    s2 && o2 && (clearTimeout(s2), o2(c5));
  }, done: () => new Promise((c5, f7) => {
    if (i4) return c5(i4);
    s2 = setTimeout(() => {
      const u2 = new Error(e);
      i4 = Promise.reject(u2), f7(u2);
    }, n3), r2 = c5, o2 = f7;
  }) };
}
function Ei(t, e, n3) {
  return new Promise(async (r2, o2) => {
    const s2 = setTimeout(() => o2(new Error(n3)), e);
    try {
      const i4 = await t;
      r2(i4);
    } catch (i4) {
      o2(i4);
    }
    clearTimeout(s2);
  });
}
function on(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Bi(t) {
  return on("topic", t);
}
function Ai(t) {
  return on("id", t);
}
function Ii(t) {
  const [e, n3] = t.split(":"), r2 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n3 == "string") r2.topic = n3;
  else if (e === "id" && Number.isInteger(Number(n3))) r2.id = Number(n3);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n3}`);
  return r2;
}
function Si(t, e) {
  return (0, import_time.fromMiliseconds)((e || Date.now()) + (0, import_time.toMiliseconds)(t));
}
function Oi(t) {
  return Date.now() >= (0, import_time.toMiliseconds)(t);
}
function Ni(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ut(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Ui({ id: t, topic: e, wcDeepLink: n3 }) {
  var r2;
  try {
    if (!n3) return;
    const o2 = typeof n3 == "string" ? JSON.parse(n3) : n3, s2 = o2 == null ? void 0 : o2.href;
    if (typeof s2 != "string") return;
    const i4 = Br(s2, t, e), c5 = Vt();
    if (c5 === et.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Ar(i4);
    } else c5 === et.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i4);
  } catch (o2) {
    console.error(o2);
  }
}
function Br(t, e, n3) {
  const r2 = `requestId=${e}&sessionTopic=${n3}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o2 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s2 = t.includes("?") ? "&startapp=" : "?startapp=";
    o2 = `${o2}${s2}${Or(r2, true)}`;
  } else o2 = `${o2}/wc?${r2}`;
  return o2;
}
function Ar(t) {
  let e = "_self";
  Sr() ? e = "_top" : (Ir() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function _i(t, e) {
  let n3 = "";
  try {
    if (Wt() && (n3 = localStorage.getItem(e), n3)) return n3;
    n3 = await t.getItem(e);
  } catch (r2) {
    console.error(r2);
  }
  return n3;
}
function Ri(t, e) {
  if (!t.includes(e)) return null;
  const n3 = t.split(/([&,?,=])/), r2 = n3.indexOf(e);
  return n3[r2 + 2];
}
function $i() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ti() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Ir() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Sr() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function Or(t, e = false) {
  const n3 = Buffer.from(t).toString("base64");
  return e ? n3.replace(/[=]/g, "") : n3;
}
function cn(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Ci(t) {
  return new Promise((e) => setTimeout(e, t));
}
var ji = class {
  constructor({ limit: e }) {
    lr(this, "limit"), lr(this, "set"), this.limit = e, this.set = /* @__PURE__ */ new Set();
  }
  add(e) {
    if (!this.set.has(e)) {
      if (this.set.size >= this.limit) {
        const n3 = this.set.values().next().value;
        n3 && this.set.delete(n3);
      }
      this.set.add(e);
    }
  }
  has(e) {
    return this.set.has(e);
  }
};
var Oe = BigInt(2 ** 32 - 1);
var Nr = BigInt(32);
function Ur(t, e = false) {
  return e ? { h: Number(t & Oe), l: Number(t >> Nr & Oe) } : { h: Number(t >> Nr & Oe) | 0, l: Number(t & Oe) | 0 };
}
function _r(t, e = false) {
  const n3 = t.length;
  let r2 = new Uint32Array(n3), o2 = new Uint32Array(n3);
  for (let s2 = 0; s2 < n3; s2++) {
    const { h: i4, l: c5 } = Ur(t[s2], e);
    [r2[s2], o2[s2]] = [i4, c5];
  }
  return [r2, o2];
}
var Rr = (t, e, n3) => t >>> n3;
var $r = (t, e, n3) => t << 32 - n3 | e >>> n3;
var St = (t, e, n3) => t >>> n3 | e << 32 - n3;
var Ot = (t, e, n3) => t << 32 - n3 | e >>> n3;
var de = (t, e, n3) => t << 64 - n3 | e >>> n3 - 32;
var he = (t, e, n3) => t >>> n3 - 32 | e << 64 - n3;
var Li = (t, e) => e;
var ki = (t, e) => t;
var Pi = (t, e, n3) => t << n3 | e >>> 32 - n3;
var Hi = (t, e, n3) => e << n3 | t >>> 32 - n3;
var Di = (t, e, n3) => e << n3 - 32 | t >>> 64 - n3;
var Vi = (t, e, n3) => t << n3 - 32 | e >>> 64 - n3;
function dt(t, e, n3, r2) {
  const o2 = (e >>> 0) + (r2 >>> 0);
  return { h: t + n3 + (o2 / 2 ** 32 | 0) | 0, l: o2 | 0 };
}
var fn = (t, e, n3) => (t >>> 0) + (e >>> 0) + (n3 >>> 0);
var an = (t, e, n3, r2) => e + n3 + r2 + (t / 2 ** 32 | 0) | 0;
var Mi = (t, e, n3, r2) => (t >>> 0) + (e >>> 0) + (n3 >>> 0) + (r2 >>> 0);
var Ki = (t, e, n3, r2, o2) => e + n3 + r2 + o2 + (t / 2 ** 32 | 0) | 0;
var qi = (t, e, n3, r2, o2) => (t >>> 0) + (e >>> 0) + (n3 >>> 0) + (r2 >>> 0) + (o2 >>> 0);
var Fi = (t, e, n3, r2, o2, s2) => e + n3 + r2 + o2 + s2 + (t / 2 ** 32 | 0) | 0;
var Xt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ne(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ht(t, ...e) {
  if (!Ne(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ue(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t.outputLen), mt(t.blockLen);
}
function Nt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function un(t, e) {
  ht(t);
  const n3 = e.outputLen;
  if (t.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
function pe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function lt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function ln(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function bt(t, e) {
  return t << 32 - e | t >>> e;
}
var Tr = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Cr(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
var wt = Tr ? (t) => t : (t) => Cr(t);
function Zi(t) {
  for (let e = 0; e < t.length; e++) t[e] = Cr(t[e]);
  return t;
}
var Ut = Tr ? (t) => t : Zi;
var jr = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Gi = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Jt(t) {
  if (ht(t), jr) return t.toHex();
  let e = "";
  for (let n3 = 0; n3 < t.length; n3++) e += Gi[t[n3]];
  return e;
}
var vt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Lr(t) {
  if (t >= vt._0 && t <= vt._9) return t - vt._0;
  if (t >= vt.A && t <= vt.F) return t - (vt.A - 10);
  if (t >= vt.a && t <= vt.f) return t - (vt.a - 10);
}
function _e(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  if (jr) return Uint8Array.fromHex(t);
  const e = t.length, n3 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n3);
  for (let o2 = 0, s2 = 0; o2 < n3; o2++, s2 += 2) {
    const i4 = Lr(t.charCodeAt(s2)), c5 = Lr(t.charCodeAt(s2 + 1));
    if (i4 === void 0 || c5 === void 0) {
      const f7 = t[s2] + t[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + f7 + '" at index ' + s2);
    }
    r2[o2] = i4 * 16 + c5;
  }
  return r2;
}
function kr(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function pt(t) {
  return typeof t == "string" && (t = kr(t)), ht(t), t;
}
function _t(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    ht(o2), e += o2.length;
  }
  const n3 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const s2 = t[r2];
    n3.set(s2, o2), o2 += s2.length;
  }
  return n3;
}
var Re = class {
};
function ge(t) {
  const e = (r2) => t().update(pt(r2)).digest(), n3 = t();
  return e.outputLen = n3.outputLen, e.blockLen = n3.blockLen, e.create = () => t(), e;
}
function zi(t) {
  const e = (r2, o2) => t(o2).update(pt(r2)).digest(), n3 = t({});
  return e.outputLen = n3.outputLen, e.blockLen = n3.blockLen, e.create = (r2) => t(r2), e;
}
function Mt(t = 32) {
  if (Xt && typeof Xt.getRandomValues == "function") return Xt.getRandomValues(new Uint8Array(t));
  if (Xt && typeof Xt.randomBytes == "function") return Uint8Array.from(Xt.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
var Yi = BigInt(0);
var be = BigInt(1);
var Wi = BigInt(2);
var Xi = BigInt(7);
var Ji = BigInt(256);
var Qi = BigInt(113);
var Pr = [];
var Hr = [];
var Dr = [];
for (let t = 0, e = be, n3 = 1, r2 = 0; t < 24; t++) {
  [n3, r2] = [r2, (2 * n3 + 3 * r2) % 5], Pr.push(2 * (5 * r2 + n3)), Hr.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Yi;
  for (let s2 = 0; s2 < 7; s2++) e = (e << be ^ (e >> Xi) * Qi) % Ji, e & Wi && (o2 ^= be << (be << BigInt(s2)) - be);
  Dr.push(o2);
}
var Vr = _r(Dr, true);
var tc = Vr[0];
var ec = Vr[1];
var Mr = (t, e, n3) => n3 > 32 ? Di(t, e, n3) : Pi(t, e, n3);
var Kr = (t, e, n3) => n3 > 32 ? Vi(t, e, n3) : Hi(t, e, n3);
function nc(t, e = 24) {
  const n3 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let i4 = 0; i4 < 10; i4++) n3[i4] = t[i4] ^ t[i4 + 10] ^ t[i4 + 20] ^ t[i4 + 30] ^ t[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const c5 = (i4 + 8) % 10, f7 = (i4 + 2) % 10, u2 = n3[f7], a2 = n3[f7 + 1], l4 = Mr(u2, a2, 1) ^ n3[c5], d5 = Kr(u2, a2, 1) ^ n3[c5 + 1];
      for (let h4 = 0; h4 < 50; h4 += 10) t[i4 + h4] ^= l4, t[i4 + h4 + 1] ^= d5;
    }
    let o2 = t[2], s2 = t[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const c5 = Hr[i4], f7 = Mr(o2, s2, c5), u2 = Kr(o2, s2, c5), a2 = Pr[i4];
      o2 = t[a2], s2 = t[a2 + 1], t[a2] = f7, t[a2 + 1] = u2;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let c5 = 0; c5 < 10; c5++) n3[c5] = t[i4 + c5];
      for (let c5 = 0; c5 < 10; c5++) t[i4 + c5] ^= ~n3[(c5 + 2) % 10] & n3[(c5 + 4) % 10];
    }
    t[0] ^= tc[r2], t[1] ^= ec[r2];
  }
  lt(n3);
}
var Jn = class _Jn extends Re {
  constructor(e, n3, r2, o2 = false, s2 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n3, this.outputLen = r2, this.enableXOF = o2, this.rounds = s2, mt(r2), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = pe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ut(this.state32), nc(this.state32, this.rounds), Ut(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n3, state: r2 } = this, o2 = e.length;
    for (let s2 = 0; s2 < o2; ) {
      const i4 = Math.min(n3 - this.pos, o2 - s2);
      for (let c5 = 0; c5 < i4; c5++) r2[this.pos++] ^= e[s2++];
      this.pos === n3 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n3, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n3, (n3 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Nt(this, false), ht(e), this.finish();
    const n3 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, s2 = e.length; o2 < s2; ) {
      this.posOut >= r2 && this.keccak();
      const i4 = Math.min(r2 - this.posOut, s2 - o2);
      e.set(n3.subarray(this.posOut, this.posOut + i4), o2), this.posOut += i4, o2 += i4;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return mt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (un(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, lt(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n3, suffix: r2, outputLen: o2, rounds: s2, enableXOF: i4 } = this;
    return e || (e = new _Jn(n3, r2, o2, i4, s2)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s2, e.suffix = r2, e.outputLen = o2, e.enableXOF = i4, e.destroyed = this.destroyed, e;
  }
};
var rc = (t, e, n3) => ge(() => new Jn(e, t, n3));
var oc = rc(1, 136, 256 / 8);
function sc(t, e, n3, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n3, r2);
  const o2 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n3 >> o2 & s2), c5 = Number(n3 & s2), f7 = r2 ? 4 : 0, u2 = r2 ? 0 : 4;
  t.setUint32(e + f7, i4, r2), t.setUint32(e + u2, c5, r2);
}
function ic(t, e, n3) {
  return t & e ^ ~t & n3;
}
function cc(t, e, n3) {
  return t & e ^ t & n3 ^ e & n3;
}
var qr = class extends Re {
  constructor(e, n3, r2, o2) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n3, this.padOffset = r2, this.isLE = o2, this.buffer = new Uint8Array(e), this.view = ln(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { view: n3, buffer: r2, blockLen: o2 } = this, s2 = e.length;
    for (let i4 = 0; i4 < s2; ) {
      const c5 = Math.min(o2 - this.pos, s2 - i4);
      if (c5 === o2) {
        const f7 = ln(e);
        for (; o2 <= s2 - i4; i4 += o2) this.process(f7, i4);
        continue;
      }
      r2.set(e.subarray(i4, i4 + c5), this.pos), this.pos += c5, i4 += c5, this.pos === o2 && (this.process(n3, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Nt(this), un(e, this), this.finished = true;
    const { buffer: n3, view: r2, blockLen: o2, isLE: s2 } = this;
    let { pos: i4 } = this;
    n3[i4++] = 128, lt(this.buffer.subarray(i4)), this.padOffset > o2 - i4 && (this.process(r2, 0), i4 = 0);
    for (let l4 = i4; l4 < o2; l4++) n3[l4] = 0;
    sc(r2, o2 - 8, BigInt(this.length * 8), s2), this.process(r2, 0);
    const c5 = ln(e), f7 = this.outputLen;
    if (f7 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u2 = f7 / 4, a2 = this.get();
    if (u2 > a2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l4 = 0; l4 < u2; l4++) c5.setUint32(4 * l4, a2[l4], s2);
  }
  digest() {
    const { buffer: e, outputLen: n3 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n3);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n3, buffer: r2, length: o2, finished: s2, destroyed: i4, pos: c5 } = this;
    return e.destroyed = i4, e.finished = s2, e.length = o2, e.pos = c5, o2 % n3 && e.buffer.set(r2), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var Rt = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var X = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var J2 = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var fc = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var $t = new Uint32Array(64);
var ac = class extends qr {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Rt[0] | 0, this.B = Rt[1] | 0, this.C = Rt[2] | 0, this.D = Rt[3] | 0, this.E = Rt[4] | 0, this.F = Rt[5] | 0, this.G = Rt[6] | 0, this.H = Rt[7] | 0;
  }
  get() {
    const { A: e, B: n3, C: r2, D: o2, E: s2, F: i4, G: c5, H: f7 } = this;
    return [e, n3, r2, o2, s2, i4, c5, f7];
  }
  set(e, n3, r2, o2, s2, i4, c5, f7) {
    this.A = e | 0, this.B = n3 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = s2 | 0, this.F = i4 | 0, this.G = c5 | 0, this.H = f7 | 0;
  }
  process(e, n3) {
    for (let l4 = 0; l4 < 16; l4++, n3 += 4) $t[l4] = e.getUint32(n3, false);
    for (let l4 = 16; l4 < 64; l4++) {
      const d5 = $t[l4 - 15], h4 = $t[l4 - 2], y5 = bt(d5, 7) ^ bt(d5, 18) ^ d5 >>> 3, m4 = bt(h4, 17) ^ bt(h4, 19) ^ h4 >>> 10;
      $t[l4] = m4 + $t[l4 - 7] + y5 + $t[l4 - 16] | 0;
    }
    let { A: r2, B: o2, C: s2, D: i4, E: c5, F: f7, G: u2, H: a2 } = this;
    for (let l4 = 0; l4 < 64; l4++) {
      const d5 = bt(c5, 6) ^ bt(c5, 11) ^ bt(c5, 25), h4 = a2 + d5 + ic(c5, f7, u2) + fc[l4] + $t[l4] | 0, m4 = (bt(r2, 2) ^ bt(r2, 13) ^ bt(r2, 22)) + cc(r2, o2, s2) | 0;
      a2 = u2, u2 = f7, f7 = c5, c5 = i4 + h4 | 0, i4 = s2, s2 = o2, o2 = r2, r2 = h4 + m4 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, s2 = s2 + this.C | 0, i4 = i4 + this.D | 0, c5 = c5 + this.E | 0, f7 = f7 + this.F | 0, u2 = u2 + this.G | 0, a2 = a2 + this.H | 0, this.set(r2, o2, s2, i4, c5, f7, u2, a2);
  }
  roundClean() {
    lt($t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), lt(this.buffer);
  }
};
var Fr = _r(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t)));
var uc = Fr[0];
var lc = Fr[1];
var Tt = new Uint32Array(80);
var Ct = new Uint32Array(80);
var dn = class extends qr {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = J2[0] | 0, this.Al = J2[1] | 0, this.Bh = J2[2] | 0, this.Bl = J2[3] | 0, this.Ch = J2[4] | 0, this.Cl = J2[5] | 0, this.Dh = J2[6] | 0, this.Dl = J2[7] | 0, this.Eh = J2[8] | 0, this.El = J2[9] | 0, this.Fh = J2[10] | 0, this.Fl = J2[11] | 0, this.Gh = J2[12] | 0, this.Gl = J2[13] | 0, this.Hh = J2[14] | 0, this.Hl = J2[15] | 0;
  }
  get() {
    const { Ah: e, Al: n3, Bh: r2, Bl: o2, Ch: s2, Cl: i4, Dh: c5, Dl: f7, Eh: u2, El: a2, Fh: l4, Fl: d5, Gh: h4, Gl: y5, Hh: m4, Hl: v5 } = this;
    return [e, n3, r2, o2, s2, i4, c5, f7, u2, a2, l4, d5, h4, y5, m4, v5];
  }
  set(e, n3, r2, o2, s2, i4, c5, f7, u2, a2, l4, d5, h4, y5, m4, v5) {
    this.Ah = e | 0, this.Al = n3 | 0, this.Bh = r2 | 0, this.Bl = o2 | 0, this.Ch = s2 | 0, this.Cl = i4 | 0, this.Dh = c5 | 0, this.Dl = f7 | 0, this.Eh = u2 | 0, this.El = a2 | 0, this.Fh = l4 | 0, this.Fl = d5 | 0, this.Gh = h4 | 0, this.Gl = y5 | 0, this.Hh = m4 | 0, this.Hl = v5 | 0;
  }
  process(e, n3) {
    for (let R4 = 0; R4 < 16; R4++, n3 += 4) Tt[R4] = e.getUint32(n3), Ct[R4] = e.getUint32(n3 += 4);
    for (let R4 = 16; R4 < 80; R4++) {
      const Z2 = Tt[R4 - 15] | 0, H2 = Ct[R4 - 15] | 0, j3 = St(Z2, H2, 1) ^ St(Z2, H2, 8) ^ Rr(Z2, H2, 7), L3 = Ot(Z2, H2, 1) ^ Ot(Z2, H2, 8) ^ $r(Z2, H2, 7), k4 = Tt[R4 - 2] | 0, O5 = Ct[R4 - 2] | 0, T4 = St(k4, O5, 19) ^ de(k4, O5, 61) ^ Rr(k4, O5, 6), C6 = Ot(k4, O5, 19) ^ he(k4, O5, 61) ^ $r(k4, O5, 6), _4 = Mi(L3, C6, Ct[R4 - 7], Ct[R4 - 16]), p3 = Ki(_4, j3, T4, Tt[R4 - 7], Tt[R4 - 16]);
      Tt[R4] = p3 | 0, Ct[R4] = _4 | 0;
    }
    let { Ah: r2, Al: o2, Bh: s2, Bl: i4, Ch: c5, Cl: f7, Dh: u2, Dl: a2, Eh: l4, El: d5, Fh: h4, Fl: y5, Gh: m4, Gl: v5, Hh: U4, Hl: F3 } = this;
    for (let R4 = 0; R4 < 80; R4++) {
      const Z2 = St(l4, d5, 14) ^ St(l4, d5, 18) ^ de(l4, d5, 41), H2 = Ot(l4, d5, 14) ^ Ot(l4, d5, 18) ^ he(l4, d5, 41), j3 = l4 & h4 ^ ~l4 & m4, L3 = d5 & y5 ^ ~d5 & v5, k4 = qi(F3, H2, L3, lc[R4], Ct[R4]), O5 = Fi(k4, U4, Z2, j3, uc[R4], Tt[R4]), T4 = k4 | 0, C6 = St(r2, o2, 28) ^ de(r2, o2, 34) ^ de(r2, o2, 39), _4 = Ot(r2, o2, 28) ^ he(r2, o2, 34) ^ he(r2, o2, 39), p3 = r2 & s2 ^ r2 & c5 ^ s2 & c5, b4 = o2 & i4 ^ o2 & f7 ^ i4 & f7;
      U4 = m4 | 0, F3 = v5 | 0, m4 = h4 | 0, v5 = y5 | 0, h4 = l4 | 0, y5 = d5 | 0, { h: l4, l: d5 } = dt(u2 | 0, a2 | 0, O5 | 0, T4 | 0), u2 = c5 | 0, a2 = f7 | 0, c5 = s2 | 0, f7 = i4 | 0, s2 = r2 | 0, i4 = o2 | 0;
      const g4 = fn(T4, _4, b4);
      r2 = an(g4, O5, C6, p3), o2 = g4 | 0;
    }
    ({ h: r2, l: o2 } = dt(this.Ah | 0, this.Al | 0, r2 | 0, o2 | 0)), { h: s2, l: i4 } = dt(this.Bh | 0, this.Bl | 0, s2 | 0, i4 | 0), { h: c5, l: f7 } = dt(this.Ch | 0, this.Cl | 0, c5 | 0, f7 | 0), { h: u2, l: a2 } = dt(this.Dh | 0, this.Dl | 0, u2 | 0, a2 | 0), { h: l4, l: d5 } = dt(this.Eh | 0, this.El | 0, l4 | 0, d5 | 0), { h: h4, l: y5 } = dt(this.Fh | 0, this.Fl | 0, h4 | 0, y5 | 0), { h: m4, l: v5 } = dt(this.Gh | 0, this.Gl | 0, m4 | 0, v5 | 0), { h: U4, l: F3 } = dt(this.Hh | 0, this.Hl | 0, U4 | 0, F3 | 0), this.set(r2, o2, s2, i4, c5, f7, u2, a2, l4, d5, h4, y5, m4, v5, U4, F3);
  }
  roundClean() {
    lt(Tt, Ct);
  }
  destroy() {
    lt(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var dc = class extends dn {
  constructor() {
    super(48), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Q = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var hc = class extends dn {
  constructor() {
    super(32), this.Ah = Q[0] | 0, this.Al = Q[1] | 0, this.Bh = Q[2] | 0, this.Bl = Q[3] | 0, this.Ch = Q[4] | 0, this.Cl = Q[5] | 0, this.Dh = Q[6] | 0, this.Dl = Q[7] | 0, this.Eh = Q[8] | 0, this.El = Q[9] | 0, this.Fh = Q[10] | 0, this.Fl = Q[11] | 0, this.Gh = Q[12] | 0, this.Gl = Q[13] | 0, this.Hh = Q[14] | 0, this.Hl = Q[15] | 0;
  }
};
var $e = ge(() => new ac());
var pc = ge(() => new dn());
var gc = ge(() => new dc());
var bc = ge(() => new hc());
var yc = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var z3 = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var S3 = new Uint32Array(32);
function jt(t, e, n3, r2, o2, s2) {
  const i4 = o2[s2], c5 = o2[s2 + 1];
  let f7 = S3[2 * t], u2 = S3[2 * t + 1], a2 = S3[2 * e], l4 = S3[2 * e + 1], d5 = S3[2 * n3], h4 = S3[2 * n3 + 1], y5 = S3[2 * r2], m4 = S3[2 * r2 + 1], v5 = fn(f7, a2, i4);
  u2 = an(v5, u2, l4, c5), f7 = v5 | 0, { Dh: m4, Dl: y5 } = { Dh: m4 ^ u2, Dl: y5 ^ f7 }, { Dh: m4, Dl: y5 } = { Dh: Li(m4, y5), Dl: ki(m4) }, { h: h4, l: d5 } = dt(h4, d5, m4, y5), { Bh: l4, Bl: a2 } = { Bh: l4 ^ h4, Bl: a2 ^ d5 }, { Bh: l4, Bl: a2 } = { Bh: St(l4, a2, 24), Bl: Ot(l4, a2, 24) }, S3[2 * t] = f7, S3[2 * t + 1] = u2, S3[2 * e] = a2, S3[2 * e + 1] = l4, S3[2 * n3] = d5, S3[2 * n3 + 1] = h4, S3[2 * r2] = y5, S3[2 * r2 + 1] = m4;
}
function Lt(t, e, n3, r2, o2, s2) {
  const i4 = o2[s2], c5 = o2[s2 + 1];
  let f7 = S3[2 * t], u2 = S3[2 * t + 1], a2 = S3[2 * e], l4 = S3[2 * e + 1], d5 = S3[2 * n3], h4 = S3[2 * n3 + 1], y5 = S3[2 * r2], m4 = S3[2 * r2 + 1], v5 = fn(f7, a2, i4);
  u2 = an(v5, u2, l4, c5), f7 = v5 | 0, { Dh: m4, Dl: y5 } = { Dh: m4 ^ u2, Dl: y5 ^ f7 }, { Dh: m4, Dl: y5 } = { Dh: St(m4, y5, 16), Dl: Ot(m4, y5, 16) }, { h: h4, l: d5 } = dt(h4, d5, m4, y5), { Bh: l4, Bl: a2 } = { Bh: l4 ^ h4, Bl: a2 ^ d5 }, { Bh: l4, Bl: a2 } = { Bh: de(l4, a2, 63), Bl: he(l4, a2, 63) }, S3[2 * t] = f7, S3[2 * t + 1] = u2, S3[2 * e] = a2, S3[2 * e + 1] = l4, S3[2 * n3] = d5, S3[2 * n3 + 1] = h4, S3[2 * r2] = y5, S3[2 * r2 + 1] = m4;
}
function mc(t, e = {}, n3, r2, o2) {
  if (mt(n3), t < 0 || t > n3) throw new Error("outputLen bigger than keyLen");
  const { key: s2, salt: i4, personalization: c5 } = e;
  if (s2 !== void 0 && (s2.length < 1 || s2.length > n3)) throw new Error("key length must be undefined or 1.." + n3);
  if (i4 !== void 0 && i4.length !== r2) throw new Error("salt must be undefined or " + r2);
  if (c5 !== void 0 && c5.length !== o2) throw new Error("personalization must be undefined or " + o2);
}
var wc = class extends Re {
  constructor(e, n3) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e), mt(n3), this.blockLen = e, this.outputLen = n3, this.buffer = new Uint8Array(e), this.buffer32 = pe(this.buffer);
  }
  update(e) {
    Nt(this), e = pt(e), ht(e);
    const { blockLen: n3, buffer: r2, buffer32: o2 } = this, s2 = e.length, i4 = e.byteOffset, c5 = e.buffer;
    for (let f7 = 0; f7 < s2; ) {
      this.pos === n3 && (Ut(o2), this.compress(o2, 0, false), Ut(o2), this.pos = 0);
      const u2 = Math.min(n3 - this.pos, s2 - f7), a2 = i4 + f7;
      if (u2 === n3 && !(a2 % 4) && f7 + u2 < s2) {
        const l4 = new Uint32Array(c5, a2, Math.floor((s2 - f7) / 4));
        Ut(l4);
        for (let d5 = 0; f7 + n3 < s2; d5 += o2.length, f7 += n3) this.length += n3, this.compress(l4, d5, false);
        Ut(l4);
        continue;
      }
      r2.set(e.subarray(f7, f7 + u2), this.pos), this.pos += u2, this.length += u2, f7 += u2;
    }
    return this;
  }
  digestInto(e) {
    Nt(this), un(e, this);
    const { pos: n3, buffer32: r2 } = this;
    this.finished = true, lt(this.buffer.subarray(n3)), Ut(r2), this.compress(r2, 0, true), Ut(r2);
    const o2 = pe(e);
    this.get().forEach((s2, i4) => o2[i4] = wt(s2));
  }
  digest() {
    const { buffer: e, outputLen: n3 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n3);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    const { buffer: n3, length: r2, finished: o2, destroyed: s2, outputLen: i4, pos: c5 } = this;
    return e || (e = new this.constructor({ dkLen: i4 })), e.set(...this.get()), e.buffer.set(n3), e.destroyed = s2, e.finished = o2, e.length = r2, e.pos = c5, e.outputLen = i4, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var vc = class extends wc {
  constructor(e = {}) {
    const n3 = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n3), this.v0l = z3[0] | 0, this.v0h = z3[1] | 0, this.v1l = z3[2] | 0, this.v1h = z3[3] | 0, this.v2l = z3[4] | 0, this.v2h = z3[5] | 0, this.v3l = z3[6] | 0, this.v3h = z3[7] | 0, this.v4l = z3[8] | 0, this.v4h = z3[9] | 0, this.v5l = z3[10] | 0, this.v5h = z3[11] | 0, this.v6l = z3[12] | 0, this.v6h = z3[13] | 0, this.v7l = z3[14] | 0, this.v7h = z3[15] | 0, mc(n3, e, 64, 16, 16);
    let { key: r2, personalization: o2, salt: s2 } = e, i4 = 0;
    if (r2 !== void 0 && (r2 = pt(r2), i4 = r2.length), this.v0l ^= this.outputLen | i4 << 8 | 65536 | 1 << 24, s2 !== void 0) {
      s2 = pt(s2);
      const c5 = pe(s2);
      this.v4l ^= wt(c5[0]), this.v4h ^= wt(c5[1]), this.v5l ^= wt(c5[2]), this.v5h ^= wt(c5[3]);
    }
    if (o2 !== void 0) {
      o2 = pt(o2);
      const c5 = pe(o2);
      this.v6l ^= wt(c5[0]), this.v6h ^= wt(c5[1]), this.v7l ^= wt(c5[2]), this.v7h ^= wt(c5[3]);
    }
    if (r2 !== void 0) {
      const c5 = new Uint8Array(this.blockLen);
      c5.set(r2), this.update(c5);
    }
  }
  get() {
    let { v0l: e, v0h: n3, v1l: r2, v1h: o2, v2l: s2, v2h: i4, v3l: c5, v3h: f7, v4l: u2, v4h: a2, v5l: l4, v5h: d5, v6l: h4, v6h: y5, v7l: m4, v7h: v5 } = this;
    return [e, n3, r2, o2, s2, i4, c5, f7, u2, a2, l4, d5, h4, y5, m4, v5];
  }
  set(e, n3, r2, o2, s2, i4, c5, f7, u2, a2, l4, d5, h4, y5, m4, v5) {
    this.v0l = e | 0, this.v0h = n3 | 0, this.v1l = r2 | 0, this.v1h = o2 | 0, this.v2l = s2 | 0, this.v2h = i4 | 0, this.v3l = c5 | 0, this.v3h = f7 | 0, this.v4l = u2 | 0, this.v4h = a2 | 0, this.v5l = l4 | 0, this.v5h = d5 | 0, this.v6l = h4 | 0, this.v6h = y5 | 0, this.v7l = m4 | 0, this.v7h = v5 | 0;
  }
  compress(e, n3, r2) {
    this.get().forEach((f7, u2) => S3[u2] = f7), S3.set(z3, 16);
    let { h: o2, l: s2 } = Ur(BigInt(this.length));
    S3[24] = z3[8] ^ s2, S3[25] = z3[9] ^ o2, r2 && (S3[28] = ~S3[28], S3[29] = ~S3[29]);
    let i4 = 0;
    const c5 = yc;
    for (let f7 = 0; f7 < 12; f7++) jt(0, 4, 8, 12, e, n3 + 2 * c5[i4++]), Lt(0, 4, 8, 12, e, n3 + 2 * c5[i4++]), jt(1, 5, 9, 13, e, n3 + 2 * c5[i4++]), Lt(1, 5, 9, 13, e, n3 + 2 * c5[i4++]), jt(2, 6, 10, 14, e, n3 + 2 * c5[i4++]), Lt(2, 6, 10, 14, e, n3 + 2 * c5[i4++]), jt(3, 7, 11, 15, e, n3 + 2 * c5[i4++]), Lt(3, 7, 11, 15, e, n3 + 2 * c5[i4++]), jt(0, 5, 10, 15, e, n3 + 2 * c5[i4++]), Lt(0, 5, 10, 15, e, n3 + 2 * c5[i4++]), jt(1, 6, 11, 12, e, n3 + 2 * c5[i4++]), Lt(1, 6, 11, 12, e, n3 + 2 * c5[i4++]), jt(2, 7, 8, 13, e, n3 + 2 * c5[i4++]), Lt(2, 7, 8, 13, e, n3 + 2 * c5[i4++]), jt(3, 4, 9, 14, e, n3 + 2 * c5[i4++]), Lt(3, 4, 9, 14, e, n3 + 2 * c5[i4++]);
    this.v0l ^= S3[0] ^ S3[16], this.v0h ^= S3[1] ^ S3[17], this.v1l ^= S3[2] ^ S3[18], this.v1h ^= S3[3] ^ S3[19], this.v2l ^= S3[4] ^ S3[20], this.v2h ^= S3[5] ^ S3[21], this.v3l ^= S3[6] ^ S3[22], this.v3h ^= S3[7] ^ S3[23], this.v4l ^= S3[8] ^ S3[24], this.v4h ^= S3[9] ^ S3[25], this.v5l ^= S3[10] ^ S3[26], this.v5h ^= S3[11] ^ S3[27], this.v6l ^= S3[12] ^ S3[28], this.v6h ^= S3[13] ^ S3[29], this.v7l ^= S3[14] ^ S3[30], this.v7h ^= S3[15] ^ S3[31], lt(S3);
  }
  destroy() {
    this.destroyed = true, lt(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var xc = zi((t) => new vc(t));
var Ec = "https://rpc.walletconnect.org/v1";
function hn(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n3 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(oc(n3)).toString("hex");
}
async function Zr(t, e, n3, r2, o2, s2) {
  switch (n3.t) {
    case "eip191":
      return await Gr(t, e, n3.s);
    case "eip1271":
      return await zr(t, e, n3.s, r2, o2, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n3.t}`);
  }
}
async function Gr(t, e, n3) {
  return (await recoverAddress({ hash: hn(e), signature: n3 })).toLowerCase() === t.toLowerCase();
}
async function zr(t, e, n3, r2, o2, s2) {
  const i4 = Je(r2);
  if (!i4.namespace || !i4.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c5 = "0x1626ba7e", f7 = "0000000000000000000000000000000000000000000000000000000000000040", u2 = n3.substring(2), a2 = (u2.length / 2).toString(16).padStart(64, "0"), l4 = (e.startsWith("0x") ? e : hn(e)).substring(2), d5 = c5 + l4 + f7 + a2 + u2, h4 = await fetch(`${s2 || Ec}/?chainId=${r2}&projectId=${o2}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: Bc(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: d5 }, "latest"] }) }), { result: y5 } = await h4.json();
    return y5 ? y5.slice(0, c5.length).toLowerCase() === c5.toLowerCase() : false;
  } catch (c5) {
    return console.error("isValidEip1271Signature: ", c5), false;
  }
}
function Bc() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Ac(t) {
  const e = atob(t), n3 = new Uint8Array(e.length);
  for (let i4 = 0; i4 < e.length; i4++) n3[i4] = e.charCodeAt(i4);
  const r2 = n3[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o2 = 1 + r2 * 64;
  if (n3.length < o2) throw new Error("Transaction data too short for claimed signature count");
  if (n3.length < 100) throw new Error("Transaction too short");
  const s2 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(s2);
}
function Ic(t) {
  const e = new Uint8Array(Buffer.from(t, "base64")), n3 = Array.from("TransactionData::").map((s2) => s2.charCodeAt(0)), r2 = new Uint8Array(n3.length + e.length);
  r2.set(n3), r2.set(e, n3.length);
  const o2 = xc(r2, { dkLen: 32 });
  return esm_default.encode(o2);
}
function Sc(t) {
  const e = new Uint8Array($e(Yr(t)));
  return esm_default.encode(e);
}
function Yr(t) {
  if (t instanceof Uint8Array) return t;
  if (Array.isArray(t)) return new Uint8Array(t);
  if (typeof t == "object" && t != null && t.data) return new Uint8Array(Object.values(t.data));
  if (typeof t == "object" && t) return new Uint8Array(Object.values(t));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function Oc(t) {
  const e = Buffer.from(t, "base64"), n3 = decode(e).txn;
  if (!n3) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r2 = encode(n3), o2 = Buffer.from("TX"), s2 = Buffer.concat([o2, Buffer.from(r2)]), i4 = bc(s2);
  return base32.encode(i4).replace(/=+$/, "");
}
function pn(t) {
  const e = [];
  let n3 = BigInt(t);
  for (; n3 >= BigInt(128); ) e.push(Number(n3 & BigInt(127) | BigInt(128))), n3 >>= BigInt(7);
  return e.push(Number(n3)), Buffer.from(e);
}
function Nc(t) {
  const e = Buffer.from(t.signed.bodyBytes, "base64"), n3 = Buffer.from(t.signed.authInfoBytes, "base64"), r2 = Buffer.from(t.signature.signature, "base64"), o2 = [];
  o2.push(Buffer.from([10])), o2.push(pn(e.length)), o2.push(e), o2.push(Buffer.from([18])), o2.push(pn(n3.length)), o2.push(n3), o2.push(Buffer.from([26])), o2.push(pn(r2.length)), o2.push(r2);
  const s2 = Buffer.concat(o2), i4 = $e(s2);
  return Buffer.from(i4).toString("hex").toUpperCase();
}
function Uc(t) {
  var e, n3;
  const r2 = [];
  try {
    if (typeof t == "string") return r2.push(t), r2;
    if (typeof t != "object") return r2;
    t != null && t.id && r2.push(t.id);
    const o2 = (n3 = (e = t == null ? void 0 : t.capabilities) == null ? void 0 : e.caip345) == null ? void 0 : n3.transactionHashes;
    o2 && r2.push(...o2);
  } catch (o2) {
    console.warn("getWalletSendCallsHashes failed: ", o2);
  }
  return r2;
}
var _c = Object.defineProperty;
var Rc = Object.defineProperties;
var $c = Object.getOwnPropertyDescriptors;
var Wr = Object.getOwnPropertySymbols;
var Tc = Object.prototype.hasOwnProperty;
var Cc = Object.prototype.propertyIsEnumerable;
var Xr = (t, e, n3) => e in t ? _c(t, e, { enumerable: true, configurable: true, writable: true, value: n3 }) : t[e] = n3;
var gn = (t, e) => {
  for (var n3 in e || (e = {})) Tc.call(e, n3) && Xr(t, n3, e[n3]);
  if (Wr) for (var n3 of Wr(e)) Cc.call(e, n3) && Xr(t, n3, e[n3]);
  return t;
};
var Jr = (t, e) => Rc(t, $c(e));
var jc = "did:pkh:";
var Te = (t) => t == null ? void 0 : t.split(":");
var Qr = (t) => {
  const e = t && Te(t);
  if (e) return t.includes(jc) ? e[3] : e[1];
};
var to = (t) => {
  const e = t && Te(t);
  if (e) return e[2] + ":" + e[3];
};
var bn = (t) => {
  const e = t && Te(t);
  if (e) return e.pop();
};
async function Lc(t) {
  const { cacao: e, projectId: n3 } = t, { s: r2, p: o2 } = e, s2 = eo(o2, o2.iss), i4 = bn(o2.iss);
  return await Zr(i4, s2, r2, to(o2.iss), n3);
}
var eo = (t, e) => {
  const n3 = `${t.domain} wants you to sign in with your Ethereum account:`, r2 = bn(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o2 = t.statement || void 0;
  const s2 = `URI: ${t.aud || t.uri}`, i4 = `Version: ${t.version}`, c5 = `Chain ID: ${Qr(e)}`, f7 = `Nonce: ${t.nonce}`, u2 = `Issued At: ${t.iat}`, a2 = t.exp ? `Expiration Time: ${t.exp}` : void 0, l4 = t.nbf ? `Not Before: ${t.nbf}` : void 0, d5 = t.requestId ? `Request ID: ${t.requestId}` : void 0, h4 = t.resources ? `Resources:${t.resources.map((m4) => `
- ${m4}`).join("")}` : void 0, y5 = je(t.resources);
  if (y5) {
    const m4 = kt(y5);
    o2 = wn(o2, m4);
  }
  return [n3, r2, "", o2, "", s2, i4, c5, f7, u2, a2, l4, d5, h4].filter((m4) => m4 != null).join(`
`);
};
function so(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function io(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function yt(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n3) => {
    const r2 = t.att[n3];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n3}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n3}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n3}`);
    Object.keys(r2).forEach((o2) => {
      const s2 = r2[o2];
      if (!Array.isArray(s2)) throw new Error(`Ability limits ${o2} must be an array of objects, found: ${s2}`);
      if (!s2.length) throw new Error(`Value of ${o2} is empty array, must be an array with objects`);
      s2.forEach((i4) => {
        if (typeof i4 != "object") throw new Error(`Ability limits (${o2}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function co(t, e, n3, r2 = {}) {
  return n3 == null ? void 0 : n3.sort((o2, s2) => o2.localeCompare(s2)), { att: { [t]: yn(e, n3, r2) } };
}
function yn(t, e, n3 = {}) {
  e = e == null ? void 0 : e.sort((o2, s2) => o2.localeCompare(s2));
  const r2 = e.map((o2) => ({ [`${t}/${o2}`]: [n3] }));
  return Object.assign({}, ...r2);
}
function Ce(t) {
  return yt(t), `urn:recap:${so(t).replace(/=/g, "")}`;
}
function kt(t) {
  const e = io(t.replace("urn:recap:", ""));
  return yt(e), e;
}
function Vc(t, e, n3) {
  const r2 = co(t, e, n3);
  return Ce(r2);
}
function mn(t) {
  return t && t.includes("urn:recap:");
}
function Mc(t, e) {
  const n3 = kt(t), r2 = kt(e), o2 = ao(n3, r2);
  return Ce(o2);
}
function ao(t, e) {
  yt(t), yt(e);
  const n3 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o2, s2) => o2.localeCompare(s2)), r2 = { att: {} };
  return n3.forEach((o2) => {
    var s2, i4;
    Object.keys(((s2 = t.att) == null ? void 0 : s2[o2]) || {}).concat(Object.keys(((i4 = e.att) == null ? void 0 : i4[o2]) || {})).sort((c5, f7) => c5.localeCompare(f7)).forEach((c5) => {
      var f7, u2;
      r2.att[o2] = Jr(gn({}, r2.att[o2]), { [c5]: ((f7 = t.att[o2]) == null ? void 0 : f7[c5]) || ((u2 = e.att[o2]) == null ? void 0 : u2[c5]) });
    });
  }), r2;
}
function wn(t = "", e) {
  yt(e);
  const n3 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n3)) return t;
  const r2 = [];
  let o2 = 0;
  Object.keys(e.att).forEach((c5) => {
    const f7 = Object.keys(e.att[c5]).map((l4) => ({ ability: l4.split("/")[0], action: l4.split("/")[1] }));
    f7.sort((l4, d5) => l4.action.localeCompare(d5.action));
    const u2 = {};
    f7.forEach((l4) => {
      u2[l4.ability] || (u2[l4.ability] = []), u2[l4.ability].push(l4.action);
    });
    const a2 = Object.keys(u2).map((l4) => (o2++, `(${o2}) '${l4}': '${u2[l4].join("', '")}' for '${c5}'.`));
    r2.push(a2.join(", ").replace(".,", "."));
  });
  const s2 = r2.join(" "), i4 = `${n3}${s2}`;
  return `${t ? t + " " : ""}${i4}`;
}
function Kc(t) {
  var e;
  const n3 = kt(t);
  yt(n3);
  const r2 = (e = n3.att) == null ? void 0 : e.eip155;
  return r2 ? Object.keys(r2).map((o2) => o2.split("/")[1]) : [];
}
function qc(t) {
  const e = kt(t);
  yt(e);
  const n3 = [];
  return Object.values(e.att).forEach((r2) => {
    Object.values(r2).forEach((o2) => {
      var s2;
      (s2 = o2 == null ? void 0 : o2[0]) != null && s2.chains && n3.push(o2[0].chains);
    });
  }), [...new Set(n3.flat())];
}
function je(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return mn(e) ? e : void 0;
}
function lo(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function vn(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
function xn(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function ot(t, ...e) {
  if (!lo(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function ho(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Fc(t, e) {
  ot(t);
  const n3 = e.outputLen;
  if (t.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
function Pt(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Qt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
function Zc(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var Gc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function zc(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function En(t) {
  if (typeof t == "string") t = zc(t);
  else if (lo(t)) t = Bn(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function Yc(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Wc(t, e) {
  if (t.length !== e.length) return false;
  let n3 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n3 |= t[r2] ^ e[r2];
  return n3 === 0;
}
var Xc = (t, e) => {
  function n3(r2, ...o2) {
    if (ot(r2), !Gc) throw new Error("Non little-endian hardware is not yet supported");
    if (t.nonceLength !== void 0) {
      const a2 = o2[0];
      if (!a2) throw new Error("nonce / iv required");
      t.varSizeNonce ? ot(a2) : ot(a2, t.nonceLength);
    }
    const s2 = t.tagLength;
    s2 && o2[1] !== void 0 && ot(o2[1]);
    const i4 = e(r2, ...o2), c5 = (a2, l4) => {
      if (l4 !== void 0) {
        if (a2 !== 2) throw new Error("cipher output not supported");
        ot(l4);
      }
    };
    let f7 = false;
    return { encrypt(a2, l4) {
      if (f7) throw new Error("cannot encrypt() twice with same key + nonce");
      return f7 = true, ot(a2), c5(i4.encrypt.length, l4), i4.encrypt(a2, l4);
    }, decrypt(a2, l4) {
      if (ot(a2), s2 && a2.length < s2) throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c5(i4.decrypt.length, l4), i4.decrypt(a2, l4);
    } };
  }
  return Object.assign(n3, t), n3;
};
function po(t, e, n3 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n3 && !Qc(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function go(t, e, n3, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n3, r2);
  const o2 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n3 >> o2 & s2), c5 = Number(n3 & s2), f7 = r2 ? 4 : 0, u2 = r2 ? 0 : 4;
  t.setUint32(e + f7, i4, r2), t.setUint32(e + u2, c5, r2);
}
function Jc(t, e, n3) {
  vn(n3);
  const r2 = new Uint8Array(16), o2 = Zc(r2);
  return go(o2, 0, BigInt(e), n3), go(o2, 8, BigInt(t), n3), r2;
}
function Qc(t) {
  return t.byteOffset % 4 === 0;
}
function Bn(t) {
  return Uint8Array.from(t);
}
var bo = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var tf = bo("expand 16-byte k");
var ef = bo("expand 32-byte k");
var nf = Pt(tf);
var rf = Pt(ef);
function K3(t, e) {
  return t << e | t >>> 32 - e;
}
function An(t) {
  return t.byteOffset % 4 === 0;
}
var Le = 64;
var of = 16;
var yo = 2 ** 32 - 1;
var mo = new Uint32Array();
function sf(t, e, n3, r2, o2, s2, i4, c5) {
  const f7 = o2.length, u2 = new Uint8Array(Le), a2 = Pt(u2), l4 = An(o2) && An(s2), d5 = l4 ? Pt(o2) : mo, h4 = l4 ? Pt(s2) : mo;
  for (let y5 = 0; y5 < f7; i4++) {
    if (t(e, n3, r2, a2, i4, c5), i4 >= yo) throw new Error("arx: counter overflow");
    const m4 = Math.min(Le, f7 - y5);
    if (l4 && m4 === Le) {
      const v5 = y5 / 4;
      if (y5 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let U4 = 0, F3; U4 < of; U4++) F3 = v5 + U4, h4[F3] = d5[F3] ^ a2[U4];
      y5 += Le;
      continue;
    }
    for (let v5 = 0, U4; v5 < m4; v5++) U4 = y5 + v5, s2[U4] = o2[U4] ^ u2[v5];
    y5 += m4;
  }
}
function cf(t, e) {
  const { allowShortKeys: n3, extendNonceFn: r2, counterLength: o2, counterRight: s2, rounds: i4 } = Yc({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return xn(o2), xn(i4), vn(s2), vn(n3), (c5, f7, u2, a2, l4 = 0) => {
    ot(c5), ot(f7), ot(u2);
    const d5 = u2.length;
    if (a2 === void 0 && (a2 = new Uint8Array(d5)), ot(a2), xn(l4), l4 < 0 || l4 >= yo) throw new Error("arx: counter overflow");
    if (a2.length < d5) throw new Error(`arx: output (${a2.length}) is shorter than data (${d5})`);
    const h4 = [];
    let y5 = c5.length, m4, v5;
    if (y5 === 32) h4.push(m4 = Bn(c5)), v5 = rf;
    else if (y5 === 16 && n3) m4 = new Uint8Array(32), m4.set(c5), m4.set(c5, 16), v5 = nf, h4.push(m4);
    else throw new Error(`arx: invalid 32-byte key, got length=${y5}`);
    An(f7) || h4.push(f7 = Bn(f7));
    const U4 = Pt(m4);
    if (r2) {
      if (f7.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(v5, U4, Pt(f7.subarray(0, 16)), U4), f7 = f7.subarray(16);
    }
    const F3 = 16 - o2;
    if (F3 !== f7.length) throw new Error(`arx: nonce must be ${F3} or 16 bytes`);
    if (F3 !== 12) {
      const Z2 = new Uint8Array(12);
      Z2.set(f7, s2 ? 0 : 12 - f7.length), f7 = Z2, h4.push(f7);
    }
    const R4 = Pt(f7);
    return sf(t, v5, U4, R4, u2, a2, l4, i4), Qt(...h4), a2;
  };
}
var W = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var ff = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = En(e), ot(e, 32);
    const n3 = W(e, 0), r2 = W(e, 2), o2 = W(e, 4), s2 = W(e, 6), i4 = W(e, 8), c5 = W(e, 10), f7 = W(e, 12), u2 = W(e, 14);
    this.r[0] = n3 & 8191, this.r[1] = (n3 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | c5 << 2) & 8191, this.r[7] = (c5 >>> 11 | f7 << 5) & 8065, this.r[8] = (f7 >>> 8 | u2 << 8) & 8191, this.r[9] = u2 >>> 5 & 127;
    for (let a2 = 0; a2 < 8; a2++) this.pad[a2] = W(e, 16 + 2 * a2);
  }
  process(e, n3, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: s2, r: i4 } = this, c5 = i4[0], f7 = i4[1], u2 = i4[2], a2 = i4[3], l4 = i4[4], d5 = i4[5], h4 = i4[6], y5 = i4[7], m4 = i4[8], v5 = i4[9], U4 = W(e, n3 + 0), F3 = W(e, n3 + 2), R4 = W(e, n3 + 4), Z2 = W(e, n3 + 6), H2 = W(e, n3 + 8), j3 = W(e, n3 + 10), L3 = W(e, n3 + 12), k4 = W(e, n3 + 14);
    let O5 = s2[0] + (U4 & 8191), T4 = s2[1] + ((U4 >>> 13 | F3 << 3) & 8191), C6 = s2[2] + ((F3 >>> 10 | R4 << 6) & 8191), _4 = s2[3] + ((R4 >>> 7 | Z2 << 9) & 8191), p3 = s2[4] + ((Z2 >>> 4 | H2 << 12) & 8191), b4 = s2[5] + (H2 >>> 1 & 8191), g4 = s2[6] + ((H2 >>> 14 | j3 << 2) & 8191), x5 = s2[7] + ((j3 >>> 11 | L3 << 5) & 8191), E4 = s2[8] + ((L3 >>> 8 | k4 << 8) & 8191), A4 = s2[9] + (k4 >>> 5 | o2), w3 = 0, B4 = w3 + O5 * c5 + T4 * (5 * v5) + C6 * (5 * m4) + _4 * (5 * y5) + p3 * (5 * h4);
    w3 = B4 >>> 13, B4 &= 8191, B4 += b4 * (5 * d5) + g4 * (5 * l4) + x5 * (5 * a2) + E4 * (5 * u2) + A4 * (5 * f7), w3 += B4 >>> 13, B4 &= 8191;
    let I3 = w3 + O5 * f7 + T4 * c5 + C6 * (5 * v5) + _4 * (5 * m4) + p3 * (5 * y5);
    w3 = I3 >>> 13, I3 &= 8191, I3 += b4 * (5 * h4) + g4 * (5 * d5) + x5 * (5 * l4) + E4 * (5 * a2) + A4 * (5 * u2), w3 += I3 >>> 13, I3 &= 8191;
    let N4 = w3 + O5 * u2 + T4 * f7 + C6 * c5 + _4 * (5 * v5) + p3 * (5 * m4);
    w3 = N4 >>> 13, N4 &= 8191, N4 += b4 * (5 * y5) + g4 * (5 * h4) + x5 * (5 * d5) + E4 * (5 * l4) + A4 * (5 * a2), w3 += N4 >>> 13, N4 &= 8191;
    let D2 = w3 + O5 * a2 + T4 * u2 + C6 * f7 + _4 * c5 + p3 * (5 * v5);
    w3 = D2 >>> 13, D2 &= 8191, D2 += b4 * (5 * m4) + g4 * (5 * y5) + x5 * (5 * h4) + E4 * (5 * d5) + A4 * (5 * l4), w3 += D2 >>> 13, D2 &= 8191;
    let P4 = w3 + O5 * l4 + T4 * a2 + C6 * u2 + _4 * f7 + p3 * c5;
    w3 = P4 >>> 13, P4 &= 8191, P4 += b4 * (5 * v5) + g4 * (5 * m4) + x5 * (5 * y5) + E4 * (5 * h4) + A4 * (5 * d5), w3 += P4 >>> 13, P4 &= 8191;
    let $3 = w3 + O5 * d5 + T4 * l4 + C6 * a2 + _4 * u2 + p3 * f7;
    w3 = $3 >>> 13, $3 &= 8191, $3 += b4 * c5 + g4 * (5 * v5) + x5 * (5 * m4) + E4 * (5 * y5) + A4 * (5 * h4), w3 += $3 >>> 13, $3 &= 8191;
    let V3 = w3 + O5 * h4 + T4 * d5 + C6 * l4 + _4 * a2 + p3 * u2;
    w3 = V3 >>> 13, V3 &= 8191, V3 += b4 * f7 + g4 * c5 + x5 * (5 * v5) + E4 * (5 * m4) + A4 * (5 * y5), w3 += V3 >>> 13, V3 &= 8191;
    let q2 = w3 + O5 * y5 + T4 * h4 + C6 * d5 + _4 * l4 + p3 * a2;
    w3 = q2 >>> 13, q2 &= 8191, q2 += b4 * u2 + g4 * f7 + x5 * c5 + E4 * (5 * v5) + A4 * (5 * m4), w3 += q2 >>> 13, q2 &= 8191;
    let G4 = w3 + O5 * m4 + T4 * y5 + C6 * h4 + _4 * d5 + p3 * l4;
    w3 = G4 >>> 13, G4 &= 8191, G4 += b4 * a2 + g4 * u2 + x5 * f7 + E4 * c5 + A4 * (5 * v5), w3 += G4 >>> 13, G4 &= 8191;
    let M5 = w3 + O5 * v5 + T4 * m4 + C6 * y5 + _4 * h4 + p3 * d5;
    w3 = M5 >>> 13, M5 &= 8191, M5 += b4 * l4 + g4 * a2 + x5 * u2 + E4 * f7 + A4 * c5, w3 += M5 >>> 13, M5 &= 8191, w3 = (w3 << 2) + w3 | 0, w3 = w3 + B4 | 0, B4 = w3 & 8191, w3 = w3 >>> 13, I3 += w3, s2[0] = B4, s2[1] = I3, s2[2] = N4, s2[3] = D2, s2[4] = P4, s2[5] = $3, s2[6] = V3, s2[7] = q2, s2[8] = G4, s2[9] = M5;
  }
  finalize() {
    const { h: e, pad: n3 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c5 = 2; c5 < 10; c5++) e[c5] += o2, o2 = e[c5] >>> 13, e[c5] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c5 = 1; c5 < 10; c5++) r2[c5] = e[c5] + o2, o2 = r2[c5] >>> 13, r2[c5] &= 8191;
    r2[9] -= 8192;
    let s2 = (o2 ^ 1) - 1;
    for (let c5 = 0; c5 < 10; c5++) r2[c5] &= s2;
    s2 = ~s2;
    for (let c5 = 0; c5 < 10; c5++) e[c5] = e[c5] & s2 | r2[c5];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let i4 = e[0] + n3[0];
    e[0] = i4 & 65535;
    for (let c5 = 1; c5 < 8; c5++) i4 = (e[c5] + n3[c5] | 0) + (i4 >>> 16) | 0, e[c5] = i4 & 65535;
    Qt(r2);
  }
  update(e) {
    ho(this), e = En(e), ot(e);
    const { buffer: n3, blockLen: r2 } = this, o2 = e.length;
    for (let s2 = 0; s2 < o2; ) {
      const i4 = Math.min(r2 - this.pos, o2 - s2);
      if (i4 === r2) {
        for (; r2 <= o2 - s2; s2 += r2) this.process(e, s2);
        continue;
      }
      n3.set(e.subarray(s2, s2 + i4), this.pos), this.pos += i4, s2 += i4, this.pos === r2 && (this.process(n3, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Qt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    ho(this), Fc(e, this), this.finished = true;
    const { buffer: n3, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n3[o2++] = 1; o2 < 16; o2++) n3[o2] = 0;
      this.process(n3, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i4 = 0; i4 < 8; i4++) e[s2++] = r2[i4] >>> 0, e[s2++] = r2[i4] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n3 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n3);
    return this.destroy(), r2;
  }
};
function af(t) {
  const e = (r2, o2) => t(o2).update(En(r2)).digest(), n3 = t(new Uint8Array(32));
  return e.outputLen = n3.outputLen, e.blockLen = n3.blockLen, e.create = (r2) => t(r2), e;
}
var uf = af((t) => new ff(t));
function lf(t, e, n3, r2, o2, s2 = 20) {
  let i4 = t[0], c5 = t[1], f7 = t[2], u2 = t[3], a2 = e[0], l4 = e[1], d5 = e[2], h4 = e[3], y5 = e[4], m4 = e[5], v5 = e[6], U4 = e[7], F3 = o2, R4 = n3[0], Z2 = n3[1], H2 = n3[2], j3 = i4, L3 = c5, k4 = f7, O5 = u2, T4 = a2, C6 = l4, _4 = d5, p3 = h4, b4 = y5, g4 = m4, x5 = v5, E4 = U4, A4 = F3, w3 = R4, B4 = Z2, I3 = H2;
  for (let D2 = 0; D2 < s2; D2 += 2) j3 = j3 + T4 | 0, A4 = K3(A4 ^ j3, 16), b4 = b4 + A4 | 0, T4 = K3(T4 ^ b4, 12), j3 = j3 + T4 | 0, A4 = K3(A4 ^ j3, 8), b4 = b4 + A4 | 0, T4 = K3(T4 ^ b4, 7), L3 = L3 + C6 | 0, w3 = K3(w3 ^ L3, 16), g4 = g4 + w3 | 0, C6 = K3(C6 ^ g4, 12), L3 = L3 + C6 | 0, w3 = K3(w3 ^ L3, 8), g4 = g4 + w3 | 0, C6 = K3(C6 ^ g4, 7), k4 = k4 + _4 | 0, B4 = K3(B4 ^ k4, 16), x5 = x5 + B4 | 0, _4 = K3(_4 ^ x5, 12), k4 = k4 + _4 | 0, B4 = K3(B4 ^ k4, 8), x5 = x5 + B4 | 0, _4 = K3(_4 ^ x5, 7), O5 = O5 + p3 | 0, I3 = K3(I3 ^ O5, 16), E4 = E4 + I3 | 0, p3 = K3(p3 ^ E4, 12), O5 = O5 + p3 | 0, I3 = K3(I3 ^ O5, 8), E4 = E4 + I3 | 0, p3 = K3(p3 ^ E4, 7), j3 = j3 + C6 | 0, I3 = K3(I3 ^ j3, 16), x5 = x5 + I3 | 0, C6 = K3(C6 ^ x5, 12), j3 = j3 + C6 | 0, I3 = K3(I3 ^ j3, 8), x5 = x5 + I3 | 0, C6 = K3(C6 ^ x5, 7), L3 = L3 + _4 | 0, A4 = K3(A4 ^ L3, 16), E4 = E4 + A4 | 0, _4 = K3(_4 ^ E4, 12), L3 = L3 + _4 | 0, A4 = K3(A4 ^ L3, 8), E4 = E4 + A4 | 0, _4 = K3(_4 ^ E4, 7), k4 = k4 + p3 | 0, w3 = K3(w3 ^ k4, 16), b4 = b4 + w3 | 0, p3 = K3(p3 ^ b4, 12), k4 = k4 + p3 | 0, w3 = K3(w3 ^ k4, 8), b4 = b4 + w3 | 0, p3 = K3(p3 ^ b4, 7), O5 = O5 + T4 | 0, B4 = K3(B4 ^ O5, 16), g4 = g4 + B4 | 0, T4 = K3(T4 ^ g4, 12), O5 = O5 + T4 | 0, B4 = K3(B4 ^ O5, 8), g4 = g4 + B4 | 0, T4 = K3(T4 ^ g4, 7);
  let N4 = 0;
  r2[N4++] = i4 + j3 | 0, r2[N4++] = c5 + L3 | 0, r2[N4++] = f7 + k4 | 0, r2[N4++] = u2 + O5 | 0, r2[N4++] = a2 + T4 | 0, r2[N4++] = l4 + C6 | 0, r2[N4++] = d5 + _4 | 0, r2[N4++] = h4 + p3 | 0, r2[N4++] = y5 + b4 | 0, r2[N4++] = m4 + g4 | 0, r2[N4++] = v5 + x5 | 0, r2[N4++] = U4 + E4 | 0, r2[N4++] = F3 + A4 | 0, r2[N4++] = R4 + w3 | 0, r2[N4++] = Z2 + B4 | 0, r2[N4++] = H2 + I3 | 0;
}
var df = cf(lf, { counterRight: false, counterLength: 4, allowShortKeys: false });
var hf = new Uint8Array(16);
var wo = (t, e) => {
  t.update(e);
  const n3 = e.length % 16;
  n3 && t.update(hf.subarray(n3));
};
var pf = new Uint8Array(32);
function vo(t, e, n3, r2, o2) {
  const s2 = t(e, n3, pf), i4 = uf.create(s2);
  o2 && wo(i4, o2), wo(i4, r2);
  const c5 = Jc(r2.length, o2 ? o2.length : 0, true);
  i4.update(c5);
  const f7 = i4.digest();
  return Qt(s2, c5), f7;
}
var gf = (t) => (e, n3, r2) => ({ encrypt(s2, i4) {
  const c5 = s2.length;
  i4 = po(c5 + 16, i4, false), i4.set(s2);
  const f7 = i4.subarray(0, -16);
  t(e, n3, f7, f7, 1);
  const u2 = vo(t, e, n3, f7, r2);
  return i4.set(u2, c5), Qt(u2), i4;
}, decrypt(s2, i4) {
  i4 = po(s2.length - 16, i4, false);
  const c5 = s2.subarray(0, -16), f7 = s2.subarray(-16), u2 = vo(t, e, n3, c5, r2);
  if (!Wc(f7, u2)) throw new Error("invalid tag");
  return i4.set(s2.subarray(0, -16)), t(e, n3, i4, i4, 1), Qt(u2), i4;
} });
var xo = Xc({ blockSize: 64, nonceLength: 12, tagLength: 16 }, gf(df));
var Eo = class extends Re {
  constructor(e, n3) {
    super(), this.finished = false, this.destroyed = false, Ue(e);
    const r2 = pt(n3);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, s2 = new Uint8Array(o2);
    s2.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 54;
    this.iHash.update(s2), this.oHash = e.create();
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 106;
    this.oHash.update(s2), lt(s2);
  }
  update(e) {
    return Nt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Nt(this), ht(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n3, iHash: r2, finished: o2, destroyed: s2, blockLen: i4, outputLen: c5 } = this;
    return e = e, e.finished = o2, e.destroyed = s2, e.blockLen = i4, e.outputLen = c5, e.oHash = n3._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ke = (t, e, n3) => new Eo(t, e).update(n3).digest();
ke.create = (t, e) => new Eo(t, e);
function bf(t, e, n3) {
  return Ue(t), n3 === void 0 && (n3 = new Uint8Array(t.outputLen)), ke(t, pt(n3), pt(e));
}
var In = Uint8Array.from([0]);
var Bo = Uint8Array.of();
function yf(t, e, n3, r2 = 32) {
  Ue(t), mt(r2);
  const o2 = t.outputLen;
  if (r2 > 255 * o2) throw new Error("Length should be <= 255*HashLen");
  const s2 = Math.ceil(r2 / o2);
  n3 === void 0 && (n3 = Bo);
  const i4 = new Uint8Array(s2 * o2), c5 = ke.create(t, e), f7 = c5._cloneInto(), u2 = new Uint8Array(c5.outputLen);
  for (let a2 = 0; a2 < s2; a2++) In[0] = a2 + 1, f7.update(a2 === 0 ? Bo : u2).update(n3).update(In).digestInto(u2), i4.set(u2, o2 * a2), c5._cloneInto(f7);
  return c5.destroy(), f7.destroy(), lt(u2, In), i4.slice(0, r2);
}
var mf = (t, e, n3, r2, o2) => yf(t, bf(t, e, n3), r2, o2);
var Pe = $e;
var Sn = BigInt(0);
var On = BigInt(1);
function He(t, e = "") {
  if (typeof t != "boolean") {
    const n3 = e && `"${e}"`;
    throw new Error(n3 + "expected boolean, got type=" + typeof t);
  }
  return t;
}
function Kt(t, e, n3 = "") {
  const r2 = Ne(t), o2 = t == null ? void 0 : t.length, s2 = e !== void 0;
  if (!r2 || s2 && o2 !== e) {
    const i4 = n3 && `"${n3}" `, c5 = s2 ? ` of length ${e}` : "", f7 = r2 ? `length=${o2}` : `type=${typeof t}`;
    throw new Error(i4 + "expected Uint8Array" + c5 + ", got " + f7);
  }
  return t;
}
function De(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Ao(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Sn : BigInt("0x" + t);
}
function Ve(t) {
  return Ao(Jt(t));
}
function Me(t) {
  return ht(t), Ao(Jt(Uint8Array.from(t).reverse()));
}
function Nn(t, e) {
  return _e(t.toString(16).padStart(e * 2, "0"));
}
function Un(t, e) {
  return Nn(t, e).reverse();
}
function tt(t, e, n3) {
  let r2;
  if (typeof e == "string") try {
    r2 = _e(e);
  } catch (s2) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (Ne(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n3 == "number" && o2 !== n3) throw new Error(t + " of length " + n3 + " expected, got " + o2);
  return r2;
}
var _n = (t) => typeof t == "bigint" && Sn <= t;
function wf(t, e, n3) {
  return _n(t) && _n(e) && _n(n3) && e <= t && t < n3;
}
function Rn(t, e, n3, r2) {
  if (!wf(e, n3, r2)) throw new Error("expected valid " + t + ": " + n3 + " <= n < " + r2 + ", got " + e);
}
function Io(t) {
  let e;
  for (e = 0; t > Sn; t >>= On, e += 1) ;
  return e;
}
var ye = (t) => (On << BigInt(t)) - On;
function vf(t, e, n3) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n3 != "function") throw new Error("hmacFn must be a function");
  const r2 = (h4) => new Uint8Array(h4), o2 = (h4) => Uint8Array.of(h4);
  let s2 = r2(t), i4 = r2(t), c5 = 0;
  const f7 = () => {
    s2.fill(1), i4.fill(0), c5 = 0;
  }, u2 = (...h4) => n3(i4, s2, ...h4), a2 = (h4 = r2(0)) => {
    i4 = u2(o2(0), h4), s2 = u2(), h4.length !== 0 && (i4 = u2(o2(1), h4), s2 = u2());
  }, l4 = () => {
    if (c5++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let h4 = 0;
    const y5 = [];
    for (; h4 < e; ) {
      s2 = u2();
      const m4 = s2.slice();
      y5.push(m4), h4 += s2.length;
    }
    return _t(...y5);
  };
  return (h4, y5) => {
    f7(), a2(h4);
    let m4;
    for (; !(m4 = y5(l4())); ) a2();
    return f7(), m4;
  };
}
function Ke(t, e, n3 = {}) {
  if (!t || typeof t != "object") throw new Error("expected valid options object");
  function r2(o2, s2, i4) {
    const c5 = t[o2];
    if (i4 && c5 === void 0) return;
    const f7 = typeof c5;
    if (f7 !== s2 || c5 === null) throw new Error(`param "${o2}" is invalid: expected ${s2}, got ${f7}`);
  }
  Object.entries(e).forEach(([o2, s2]) => r2(o2, s2, false)), Object.entries(n3).forEach(([o2, s2]) => r2(o2, s2, true));
}
function So(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n3, ...r2) => {
    const o2 = e.get(n3);
    if (o2 !== void 0) return o2;
    const s2 = t(n3, ...r2);
    return e.set(n3, s2), s2;
  };
}
var st = BigInt(0);
var nt = BigInt(1);
var qt = BigInt(2);
var Oo = BigInt(3);
var No = BigInt(4);
var Uo = BigInt(5);
var xf = BigInt(7);
var _o = BigInt(8);
var Ef = BigInt(9);
var Ro = BigInt(16);
function ct(t, e) {
  const n3 = t % e;
  return n3 >= st ? n3 : e + n3;
}
function gt(t, e, n3) {
  let r2 = t;
  for (; e-- > st; ) r2 *= r2, r2 %= n3;
  return r2;
}
function $o(t, e) {
  if (t === st) throw new Error("invert: expected non-zero number");
  if (e <= st) throw new Error("invert: expected positive modulus, got " + e);
  let n3 = ct(t, e), r2 = e, o2 = st, s2 = nt;
  for (; n3 !== st; ) {
    const c5 = r2 / n3, f7 = r2 % n3, u2 = o2 - s2 * c5;
    r2 = n3, n3 = f7, o2 = s2, s2 = u2;
  }
  if (r2 !== nt) throw new Error("invert: does not exist");
  return ct(o2, e);
}
function $n(t, e, n3) {
  if (!t.eql(t.sqr(e), n3)) throw new Error("Cannot find square root");
}
function To(t, e) {
  const n3 = (t.ORDER + nt) / No, r2 = t.pow(e, n3);
  return $n(t, r2, e), r2;
}
function Bf(t, e) {
  const n3 = (t.ORDER - Uo) / _o, r2 = t.mul(e, qt), o2 = t.pow(r2, n3), s2 = t.mul(e, o2), i4 = t.mul(t.mul(s2, qt), o2), c5 = t.mul(s2, t.sub(i4, t.ONE));
  return $n(t, c5, e), c5;
}
function Af(t) {
  const e = Ht(t), n3 = Co(t), r2 = n3(e, e.neg(e.ONE)), o2 = n3(e, r2), s2 = n3(e, e.neg(r2)), i4 = (t + xf) / Ro;
  return (c5, f7) => {
    let u2 = c5.pow(f7, i4), a2 = c5.mul(u2, r2);
    const l4 = c5.mul(u2, o2), d5 = c5.mul(u2, s2), h4 = c5.eql(c5.sqr(a2), f7), y5 = c5.eql(c5.sqr(l4), f7);
    u2 = c5.cmov(u2, a2, h4), a2 = c5.cmov(d5, l4, y5);
    const m4 = c5.eql(c5.sqr(a2), f7), v5 = c5.cmov(u2, a2, m4);
    return $n(c5, v5, f7), v5;
  };
}
function Co(t) {
  if (t < Oo) throw new Error("sqrt is not defined for small field");
  let e = t - nt, n3 = 0;
  for (; e % qt === st; ) e /= qt, n3++;
  let r2 = qt;
  const o2 = Ht(t);
  for (; Lo(o2, r2) === 1; ) if (r2++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n3 === 1) return To;
  let s2 = o2.pow(r2, e);
  const i4 = (e + nt) / qt;
  return function(f7, u2) {
    if (f7.is0(u2)) return u2;
    if (Lo(f7, u2) !== 1) throw new Error("Cannot find square root");
    let a2 = n3, l4 = f7.mul(f7.ONE, s2), d5 = f7.pow(u2, e), h4 = f7.pow(u2, i4);
    for (; !f7.eql(d5, f7.ONE); ) {
      if (f7.is0(d5)) return f7.ZERO;
      let y5 = 1, m4 = f7.sqr(d5);
      for (; !f7.eql(m4, f7.ONE); ) if (y5++, m4 = f7.sqr(m4), y5 === a2) throw new Error("Cannot find square root");
      const v5 = nt << BigInt(a2 - y5 - 1), U4 = f7.pow(l4, v5);
      a2 = y5, l4 = f7.sqr(U4), d5 = f7.mul(d5, l4), h4 = f7.mul(h4, U4);
    }
    return h4;
  };
}
function If(t) {
  return t % No === Oo ? To : t % _o === Uo ? Bf : t % Ro === Ef ? Af(t) : Co(t);
}
var Sf = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Of(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n3 = Sf.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Ke(t, n3), t;
}
function Nf(t, e, n3) {
  if (n3 < st) throw new Error("invalid exponent, negatives unsupported");
  if (n3 === st) return t.ONE;
  if (n3 === nt) return e;
  let r2 = t.ONE, o2 = e;
  for (; n3 > st; ) n3 & nt && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n3 >>= nt;
  return r2;
}
function jo(t, e, n3 = false) {
  const r2 = new Array(e.length).fill(n3 ? t.ZERO : void 0), o2 = e.reduce((i4, c5, f7) => t.is0(c5) ? i4 : (r2[f7] = i4, t.mul(i4, c5)), t.ONE), s2 = t.inv(o2);
  return e.reduceRight((i4, c5, f7) => t.is0(c5) ? i4 : (r2[f7] = t.mul(i4, r2[f7]), t.mul(i4, c5)), s2), r2;
}
function Lo(t, e) {
  const n3 = (t.ORDER - nt) / qt, r2 = t.pow(e, n3), o2 = t.eql(r2, t.ONE), s2 = t.eql(r2, t.ZERO), i4 = t.eql(r2, t.neg(t.ONE));
  if (!o2 && !s2 && !i4) throw new Error("invalid Legendre symbol result");
  return o2 ? 1 : s2 ? 0 : -1;
}
function ko(t, e) {
  e !== void 0 && mt(e);
  const n3 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n3 / 8);
  return { nBitLength: n3, nByteLength: r2 };
}
function Ht(t, e, n3 = false, r2 = {}) {
  if (t <= st) throw new Error("invalid field: expected ORDER > 0, got " + t);
  let o2, s2, i4 = false, c5;
  if (typeof e == "object" && e != null) {
    if (r2.sqrt || n3) throw new Error("cannot specify opts in two arguments");
    const d5 = e;
    d5.BITS && (o2 = d5.BITS), d5.sqrt && (s2 = d5.sqrt), typeof d5.isLE == "boolean" && (n3 = d5.isLE), typeof d5.modFromBytes == "boolean" && (i4 = d5.modFromBytes), c5 = d5.allowedLengths;
  } else typeof e == "number" && (o2 = e), r2.sqrt && (s2 = r2.sqrt);
  const { nBitLength: f7, nByteLength: u2 } = ko(t, o2);
  if (u2 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a2;
  const l4 = Object.freeze({ ORDER: t, isLE: n3, BITS: f7, BYTES: u2, MASK: ye(f7), ZERO: st, ONE: nt, allowedLengths: c5, create: (d5) => ct(d5, t), isValid: (d5) => {
    if (typeof d5 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof d5);
    return st <= d5 && d5 < t;
  }, is0: (d5) => d5 === st, isValidNot0: (d5) => !l4.is0(d5) && l4.isValid(d5), isOdd: (d5) => (d5 & nt) === nt, neg: (d5) => ct(-d5, t), eql: (d5, h4) => d5 === h4, sqr: (d5) => ct(d5 * d5, t), add: (d5, h4) => ct(d5 + h4, t), sub: (d5, h4) => ct(d5 - h4, t), mul: (d5, h4) => ct(d5 * h4, t), pow: (d5, h4) => Nf(l4, d5, h4), div: (d5, h4) => ct(d5 * $o(h4, t), t), sqrN: (d5) => d5 * d5, addN: (d5, h4) => d5 + h4, subN: (d5, h4) => d5 - h4, mulN: (d5, h4) => d5 * h4, inv: (d5) => $o(d5, t), sqrt: s2 || ((d5) => (a2 || (a2 = If(t)), a2(l4, d5))), toBytes: (d5) => n3 ? Un(d5, u2) : Nn(d5, u2), fromBytes: (d5, h4 = true) => {
    if (c5) {
      if (!c5.includes(d5.length) || d5.length > u2) throw new Error("Field.fromBytes: expected " + c5 + " bytes, got " + d5.length);
      const m4 = new Uint8Array(u2);
      m4.set(d5, n3 ? 0 : m4.length - d5.length), d5 = m4;
    }
    if (d5.length !== u2) throw new Error("Field.fromBytes: expected " + u2 + " bytes, got " + d5.length);
    let y5 = n3 ? Me(d5) : Ve(d5);
    if (i4 && (y5 = ct(y5, t)), !h4 && !l4.isValid(y5)) throw new Error("invalid field element: outside of range 0..ORDER");
    return y5;
  }, invertBatch: (d5) => jo(l4, d5), cmov: (d5, h4, y5) => y5 ? h4 : d5 });
  return Object.freeze(l4);
}
function Po2(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Ho(t) {
  const e = Po2(t);
  return e + Math.ceil(e / 2);
}
function Uf(t, e, n3 = false) {
  const r2 = t.length, o2 = Po2(e), s2 = Ho(e);
  if (r2 < 16 || r2 < s2 || r2 > 1024) throw new Error("expected " + s2 + "-1024 bytes of input, got " + r2);
  const i4 = n3 ? Me(t) : Ve(t), c5 = ct(i4, e - nt) + nt;
  return n3 ? Un(c5, o2) : Nn(c5, o2);
}
var te = BigInt(0);
var Ft = BigInt(1);
function qe(t, e) {
  const n3 = e.negate();
  return t ? n3 : e;
}
function Tn(t, e) {
  const n3 = jo(t.Fp, e.map((r2) => r2.Z));
  return e.map((r2, o2) => t.fromAffine(r2.toAffine(n3[o2])));
}
function Do(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Cn(t, e) {
  Do(t, e);
  const n3 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1), o2 = 2 ** t, s2 = ye(t), i4 = BigInt(t);
  return { windows: n3, windowSize: r2, mask: s2, maxNumber: o2, shiftBy: i4 };
}
function Vo(t, e, n3) {
  const { windowSize: r2, mask: o2, maxNumber: s2, shiftBy: i4 } = n3;
  let c5 = Number(t & o2), f7 = t >> i4;
  c5 > r2 && (c5 -= s2, f7 += Ft);
  const u2 = e * r2, a2 = u2 + Math.abs(c5) - 1, l4 = c5 === 0, d5 = c5 < 0, h4 = e % 2 !== 0;
  return { nextN: f7, offset: a2, isZero: l4, isNeg: d5, isNegF: h4, offsetF: u2 };
}
function _f(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n3, r2) => {
    if (!(n3 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function Rf(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n3, r2) => {
    if (!e.isValid(n3)) throw new Error("invalid scalar at index " + r2);
  });
}
var jn = /* @__PURE__ */ new WeakMap();
var Mo = /* @__PURE__ */ new WeakMap();
function Ln(t) {
  return Mo.get(t) || 1;
}
function Ko(t) {
  if (t !== te) throw new Error("invalid wNAF");
}
var $f = class {
  constructor(e, n3) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = n3;
  }
  _unsafeLadder(e, n3, r2 = this.ZERO) {
    let o2 = e;
    for (; n3 > te; ) n3 & Ft && (r2 = r2.add(o2)), o2 = o2.double(), n3 >>= Ft;
    return r2;
  }
  precomputeWindow(e, n3) {
    const { windows: r2, windowSize: o2 } = Cn(n3, this.bits), s2 = [];
    let i4 = e, c5 = i4;
    for (let f7 = 0; f7 < r2; f7++) {
      c5 = i4, s2.push(c5);
      for (let u2 = 1; u2 < o2; u2++) c5 = c5.add(i4), s2.push(c5);
      i4 = c5.double();
    }
    return s2;
  }
  wNAF(e, n3, r2) {
    if (!this.Fn.isValid(r2)) throw new Error("invalid scalar");
    let o2 = this.ZERO, s2 = this.BASE;
    const i4 = Cn(e, this.bits);
    for (let c5 = 0; c5 < i4.windows; c5++) {
      const { nextN: f7, offset: u2, isZero: a2, isNeg: l4, isNegF: d5, offsetF: h4 } = Vo(r2, c5, i4);
      r2 = f7, a2 ? s2 = s2.add(qe(d5, n3[h4])) : o2 = o2.add(qe(l4, n3[u2]));
    }
    return Ko(r2), { p: o2, f: s2 };
  }
  wNAFUnsafe(e, n3, r2, o2 = this.ZERO) {
    const s2 = Cn(e, this.bits);
    for (let i4 = 0; i4 < s2.windows && r2 !== te; i4++) {
      const { nextN: c5, offset: f7, isZero: u2, isNeg: a2 } = Vo(r2, i4, s2);
      if (r2 = c5, !u2) {
        const l4 = n3[f7];
        o2 = o2.add(a2 ? l4.negate() : l4);
      }
    }
    return Ko(r2), o2;
  }
  getPrecomputes(e, n3, r2) {
    let o2 = jn.get(n3);
    return o2 || (o2 = this.precomputeWindow(n3, e), e !== 1 && (typeof r2 == "function" && (o2 = r2(o2)), jn.set(n3, o2))), o2;
  }
  cached(e, n3, r2) {
    const o2 = Ln(e);
    return this.wNAF(o2, this.getPrecomputes(o2, e, r2), n3);
  }
  unsafe(e, n3, r2, o2) {
    const s2 = Ln(e);
    return s2 === 1 ? this._unsafeLadder(e, n3, o2) : this.wNAFUnsafe(s2, this.getPrecomputes(s2, e, r2), n3, o2);
  }
  createCache(e, n3) {
    Do(n3, this.bits), Mo.set(e, n3), jn.delete(e);
  }
  hasCache(e) {
    return Ln(e) !== 1;
  }
};
function Tf(t, e, n3, r2) {
  let o2 = e, s2 = t.ZERO, i4 = t.ZERO;
  for (; n3 > te || r2 > te; ) n3 & Ft && (s2 = s2.add(o2)), r2 & Ft && (i4 = i4.add(o2)), o2 = o2.double(), n3 >>= Ft, r2 >>= Ft;
  return { p1: s2, p2: i4 };
}
function Cf(t, e, n3, r2) {
  _f(n3, t), Rf(r2, e);
  const o2 = n3.length, s2 = r2.length;
  if (o2 !== s2) throw new Error("arrays of points and scalars must have equal length");
  const i4 = t.ZERO, c5 = Io(BigInt(o2));
  let f7 = 1;
  c5 > 12 ? f7 = c5 - 3 : c5 > 4 ? f7 = c5 - 2 : c5 > 0 && (f7 = 2);
  const u2 = ye(f7), a2 = new Array(Number(u2) + 1).fill(i4), l4 = Math.floor((e.BITS - 1) / f7) * f7;
  let d5 = i4;
  for (let h4 = l4; h4 >= 0; h4 -= f7) {
    a2.fill(i4);
    for (let m4 = 0; m4 < s2; m4++) {
      const v5 = r2[m4], U4 = Number(v5 >> BigInt(h4) & u2);
      a2[U4] = a2[U4].add(n3[m4]);
    }
    let y5 = i4;
    for (let m4 = a2.length - 1, v5 = i4; m4 > 0; m4--) v5 = v5.add(a2[m4]), y5 = y5.add(v5);
    if (d5 = d5.add(y5), h4 !== 0) for (let m4 = 0; m4 < f7; m4++) d5 = d5.double();
  }
  return d5;
}
function qo(t, e, n3) {
  if (e) {
    if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Of(e), e;
  } else return Ht(t, { isLE: n3 });
}
function jf(t, e, n3 = {}, r2) {
  if (r2 === void 0 && (r2 = t === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${t} CURVE object`);
  for (const f7 of ["p", "n", "h"]) {
    const u2 = e[f7];
    if (!(typeof u2 == "bigint" && u2 > te)) throw new Error(`CURVE.${f7} must be positive bigint`);
  }
  const o2 = qo(e.p, n3.Fp, r2), s2 = qo(e.n, n3.Fn, r2), c5 = ["Gx", "Gy", "a", t === "weierstrass" ? "b" : "d"];
  for (const f7 of c5) if (!o2.isValid(e[f7])) throw new Error(`CURVE.${f7} must be valid field element of CURVE.Fp`);
  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: o2, Fn: s2 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8), kr("HashToScalar-");
var me = BigInt(0);
var ee = BigInt(1);
var Fe = BigInt(2);
function Lf(t) {
  return Ke(t, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t });
}
function kf(t) {
  const e = Lf(t), { P: n3, type: r2, adjustScalarBytes: o2, powPminus2: s2, randomBytes: i4 } = e, c5 = r2 === "x25519";
  if (!c5 && r2 !== "x448") throw new Error("invalid type");
  const f7 = i4 || Mt, u2 = c5 ? 255 : 448, a2 = c5 ? 32 : 56, l4 = BigInt(c5 ? 9 : 5), d5 = BigInt(c5 ? 121665 : 39081), h4 = c5 ? Fe ** BigInt(254) : Fe ** BigInt(447), y5 = c5 ? BigInt(8) * Fe ** BigInt(251) - ee : BigInt(4) * Fe ** BigInt(445) - ee, m4 = h4 + y5 + ee, v5 = (p3) => ct(p3, n3), U4 = F3(l4);
  function F3(p3) {
    return Un(v5(p3), a2);
  }
  function R4(p3) {
    const b4 = tt("u coordinate", p3, a2);
    return c5 && (b4[31] &= 127), v5(Me(b4));
  }
  function Z2(p3) {
    return Me(o2(tt("scalar", p3, a2)));
  }
  function H2(p3, b4) {
    const g4 = k4(R4(b4), Z2(p3));
    if (g4 === me) throw new Error("invalid private or public key received");
    return F3(g4);
  }
  function j3(p3) {
    return H2(p3, U4);
  }
  function L3(p3, b4, g4) {
    const x5 = v5(p3 * (b4 - g4));
    return b4 = v5(b4 - x5), g4 = v5(g4 + x5), { x_2: b4, x_3: g4 };
  }
  function k4(p3, b4) {
    Rn("u", p3, me, n3), Rn("scalar", b4, h4, m4);
    const g4 = b4, x5 = p3;
    let E4 = ee, A4 = me, w3 = p3, B4 = ee, I3 = me;
    for (let D2 = BigInt(u2 - 1); D2 >= me; D2--) {
      const P4 = g4 >> D2 & ee;
      I3 ^= P4, { x_2: E4, x_3: w3 } = L3(I3, E4, w3), { x_2: A4, x_3: B4 } = L3(I3, A4, B4), I3 = P4;
      const $3 = E4 + A4, V3 = v5($3 * $3), q2 = E4 - A4, G4 = v5(q2 * q2), M5 = V3 - G4, Y2 = w3 + B4, Yt3 = w3 - B4, ce3 = v5(Yt3 * $3), fe4 = v5(Y2 * q2), Qn2 = ce3 + fe4, tr = ce3 - fe4;
      w3 = v5(Qn2 * Qn2), B4 = v5(x5 * v5(tr * tr)), E4 = v5(V3 * G4), A4 = v5(M5 * (V3 + v5(d5 * M5)));
    }
    ({ x_2: E4, x_3: w3 } = L3(I3, E4, w3)), { x_2: A4, x_3: B4 } = L3(I3, A4, B4);
    const N4 = s2(A4);
    return v5(E4 * N4);
  }
  const O5 = { secretKey: a2, publicKey: a2, seed: a2 }, T4 = (p3 = f7(a2)) => (ht(p3, O5.seed), p3);
  function C6(p3) {
    const b4 = T4(p3);
    return { secretKey: b4, publicKey: j3(b4) };
  }
  return { keygen: C6, getSharedSecret: (p3, b4) => H2(p3, b4), getPublicKey: (p3) => j3(p3), scalarMult: H2, scalarMultBase: j3, utils: { randomSecretKey: T4, randomPrivateKey: T4 }, GuBytes: U4.slice(), lengths: O5 };
}
var Pf = BigInt(1);
var Fo = BigInt(2);
var Hf = BigInt(3);
var Df = BigInt(5);
var Vf = BigInt(8);
var Zo = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var Mf = { p: Zo, n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Vf, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Kf(t) {
  const e = BigInt(10), n3 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), s2 = Zo, c5 = t * t % s2 * t % s2, f7 = gt(c5, Fo, s2) * c5 % s2, u2 = gt(f7, Pf, s2) * t % s2, a2 = gt(u2, Df, s2) * u2 % s2, l4 = gt(a2, e, s2) * a2 % s2, d5 = gt(l4, n3, s2) * l4 % s2, h4 = gt(d5, r2, s2) * d5 % s2, y5 = gt(h4, o2, s2) * h4 % s2, m4 = gt(y5, o2, s2) * h4 % s2, v5 = gt(m4, e, s2) * a2 % s2;
  return { pow_p_5_8: gt(v5, Fo, s2) * t % s2, b2: c5 };
}
function qf(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var Ff = Ht(Mf.p, { isLE: true });
var kn = (() => {
  const t = Ff.ORDER;
  return kf({ P: t, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: n3, b2: r2 } = Kf(e);
    return ct(gt(n3, Hf, t) * r2, t);
  }, adjustScalarBytes: qf });
})();
var Go = (t, e) => (t + (t >= 0 ? e : -e) / zo) / e;
function Zf(t, e, n3) {
  const [[r2, o2], [s2, i4]] = e, c5 = Go(i4 * t, n3), f7 = Go(-o2 * t, n3);
  let u2 = t - c5 * r2 - f7 * s2, a2 = -c5 * o2 - f7 * i4;
  const l4 = u2 < Et, d5 = a2 < Et;
  l4 && (u2 = -u2), d5 && (a2 = -a2);
  const h4 = ye(Math.ceil(Io(n3) / 2)) + ne;
  if (u2 < Et || u2 >= h4 || a2 < Et || a2 >= h4) throw new Error("splitScalar (endomorphism): failed, k=" + t);
  return { k1neg: l4, k1: u2, k2neg: d5, k2: a2 };
}
function Pn(t) {
  if (!["compact", "recovered", "der"].includes(t)) throw new Error('Signature format must be "compact", "recovered", or "der"');
  return t;
}
function Hn(t, e) {
  const n3 = {};
  for (let r2 of Object.keys(e)) n3[r2] = t[r2] === void 0 ? e[r2] : t[r2];
  return He(n3.lowS, "lowS"), He(n3.prehash, "prehash"), n3.format !== void 0 && Pn(n3.format), n3;
}
var Gf = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var xt = { Err: Gf, _tlv: { encode: (t, e) => {
  const { Err: n3 } = xt;
  if (t < 0 || t > 256) throw new n3("tlv.encode: wrong tag");
  if (e.length & 1) throw new n3("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = De(r2);
  if (o2.length / 2 & 128) throw new n3("tlv.encode: long form length too big");
  const s2 = r2 > 127 ? De(o2.length / 2 | 128) : "";
  return De(t) + s2 + o2 + e;
}, decode(t, e) {
  const { Err: n3 } = xt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n3("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n3("tlv.decode: wrong tlv");
  const o2 = e[r2++], s2 = !!(o2 & 128);
  let i4 = 0;
  if (!s2) i4 = o2;
  else {
    const f7 = o2 & 127;
    if (!f7) throw new n3("tlv.decode(long): indefinite length not supported");
    if (f7 > 4) throw new n3("tlv.decode(long): byte length is too big");
    const u2 = e.subarray(r2, r2 + f7);
    if (u2.length !== f7) throw new n3("tlv.decode: length bytes not complete");
    if (u2[0] === 0) throw new n3("tlv.decode(long): zero leftmost byte");
    for (const a2 of u2) i4 = i4 << 8 | a2;
    if (r2 += f7, i4 < 128) throw new n3("tlv.decode(long): not minimal encoding");
  }
  const c5 = e.subarray(r2, r2 + i4);
  if (c5.length !== i4) throw new n3("tlv.decode: wrong value length");
  return { v: c5, l: e.subarray(r2 + i4) };
} }, _int: { encode(t) {
  const { Err: e } = xt;
  if (t < Et) throw new e("integer: negative integers are not allowed");
  let n3 = De(t);
  if (Number.parseInt(n3[0], 16) & 8 && (n3 = "00" + n3), n3.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n3;
}, decode(t) {
  const { Err: e } = xt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Ve(t);
} }, toSig(t) {
  const { Err: e, _int: n3, _tlv: r2 } = xt, o2 = tt("signature", t), { v: s2, l: i4 } = r2.decode(48, o2);
  if (i4.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c5, l: f7 } = r2.decode(2, s2), { v: u2, l: a2 } = r2.decode(2, f7);
  if (a2.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n3.decode(c5), s: n3.decode(u2) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n3 } = xt, r2 = e.encode(2, n3.encode(t.r)), o2 = e.encode(2, n3.encode(t.s)), s2 = r2 + o2;
  return e.encode(48, s2);
} };
var Et = BigInt(0);
var ne = BigInt(1);
var zo = BigInt(2);
var Ze = BigInt(3);
var zf = BigInt(4);
function re(t, e) {
  const { BYTES: n3 } = t;
  let r2;
  if (typeof e == "bigint") r2 = e;
  else {
    let o2 = tt("private key", e);
    try {
      r2 = t.fromBytes(o2);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${n3}, got ${typeof e}`);
    }
  }
  if (!t.isValidNot0(r2)) throw new Error("invalid private key: out of range [1..N-1]");
  return r2;
}
function Yf(t, e = {}) {
  const n3 = jf("weierstrass", t, e), { Fp: r2, Fn: o2 } = n3;
  let s2 = n3.CURVE;
  const { h: i4, n: c5 } = s2;
  Ke(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: f7 } = e;
  if (f7 && (!r2.is0(s2.a) || typeof f7.beta != "bigint" || !Array.isArray(f7.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const u2 = Wo(r2, o2);
  function a2() {
    if (!r2.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function l4(_4, p3, b4) {
    const { x: g4, y: x5 } = p3.toAffine(), E4 = r2.toBytes(g4);
    if (He(b4, "isCompressed"), b4) {
      a2();
      const A4 = !r2.isOdd(x5);
      return _t(Yo(A4), E4);
    } else return _t(Uint8Array.of(4), E4, r2.toBytes(x5));
  }
  function d5(_4) {
    Kt(_4, void 0, "Point");
    const { publicKey: p3, publicKeyUncompressed: b4 } = u2, g4 = _4.length, x5 = _4[0], E4 = _4.subarray(1);
    if (g4 === p3 && (x5 === 2 || x5 === 3)) {
      const A4 = r2.fromBytes(E4);
      if (!r2.isValid(A4)) throw new Error("bad point: is not on curve, wrong x");
      const w3 = m4(A4);
      let B4;
      try {
        B4 = r2.sqrt(w3);
      } catch (D2) {
        const P4 = D2 instanceof Error ? ": " + D2.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + P4);
      }
      a2();
      const I3 = r2.isOdd(B4);
      return (x5 & 1) === 1 !== I3 && (B4 = r2.neg(B4)), { x: A4, y: B4 };
    } else if (g4 === b4 && x5 === 4) {
      const A4 = r2.BYTES, w3 = r2.fromBytes(E4.subarray(0, A4)), B4 = r2.fromBytes(E4.subarray(A4, A4 * 2));
      if (!v5(w3, B4)) throw new Error("bad point: is not on curve");
      return { x: w3, y: B4 };
    } else throw new Error(`bad point: got length ${g4}, expected compressed=${p3} or uncompressed=${b4}`);
  }
  const h4 = e.toBytes || l4, y5 = e.fromBytes || d5;
  function m4(_4) {
    const p3 = r2.sqr(_4), b4 = r2.mul(p3, _4);
    return r2.add(r2.add(b4, r2.mul(_4, s2.a)), s2.b);
  }
  function v5(_4, p3) {
    const b4 = r2.sqr(p3), g4 = m4(_4);
    return r2.eql(b4, g4);
  }
  if (!v5(s2.Gx, s2.Gy)) throw new Error("bad curve params: generator point");
  const U4 = r2.mul(r2.pow(s2.a, Ze), zf), F3 = r2.mul(r2.sqr(s2.b), BigInt(27));
  if (r2.is0(r2.add(U4, F3))) throw new Error("bad curve params: a or b");
  function R4(_4, p3, b4 = false) {
    if (!r2.isValid(p3) || b4 && r2.is0(p3)) throw new Error(`bad point coordinate ${_4}`);
    return p3;
  }
  function Z2(_4) {
    if (!(_4 instanceof O5)) throw new Error("ProjectivePoint expected");
  }
  function H2(_4) {
    if (!f7 || !f7.basises) throw new Error("no endo");
    return Zf(_4, f7.basises, o2.ORDER);
  }
  const j3 = So((_4, p3) => {
    const { X: b4, Y: g4, Z: x5 } = _4;
    if (r2.eql(x5, r2.ONE)) return { x: b4, y: g4 };
    const E4 = _4.is0();
    p3 == null && (p3 = E4 ? r2.ONE : r2.inv(x5));
    const A4 = r2.mul(b4, p3), w3 = r2.mul(g4, p3), B4 = r2.mul(x5, p3);
    if (E4) return { x: r2.ZERO, y: r2.ZERO };
    if (!r2.eql(B4, r2.ONE)) throw new Error("invZ was invalid");
    return { x: A4, y: w3 };
  }), L3 = So((_4) => {
    if (_4.is0()) {
      if (e.allowInfinityPoint && !r2.is0(_4.Y)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: p3, y: b4 } = _4.toAffine();
    if (!r2.isValid(p3) || !r2.isValid(b4)) throw new Error("bad point: x or y not field elements");
    if (!v5(p3, b4)) throw new Error("bad point: equation left != right");
    if (!_4.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function k4(_4, p3, b4, g4, x5) {
    return b4 = new O5(r2.mul(b4.X, _4), b4.Y, b4.Z), p3 = qe(g4, p3), b4 = qe(x5, b4), p3.add(b4);
  }
  class O5 {
    constructor(p3, b4, g4) {
      this.X = R4("x", p3), this.Y = R4("y", b4, true), this.Z = R4("z", g4), Object.freeze(this);
    }
    static CURVE() {
      return s2;
    }
    static fromAffine(p3) {
      const { x: b4, y: g4 } = p3 || {};
      if (!p3 || !r2.isValid(b4) || !r2.isValid(g4)) throw new Error("invalid affine point");
      if (p3 instanceof O5) throw new Error("projective point not allowed");
      return r2.is0(b4) && r2.is0(g4) ? O5.ZERO : new O5(b4, g4, r2.ONE);
    }
    static fromBytes(p3) {
      const b4 = O5.fromAffine(y5(Kt(p3, void 0, "point")));
      return b4.assertValidity(), b4;
    }
    static fromHex(p3) {
      return O5.fromBytes(tt("pointHex", p3));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(p3 = 8, b4 = true) {
      return C6.createCache(this, p3), b4 || this.multiply(Ze), this;
    }
    assertValidity() {
      L3(this);
    }
    hasEvenY() {
      const { y: p3 } = this.toAffine();
      if (!r2.isOdd) throw new Error("Field doesn't support isOdd");
      return !r2.isOdd(p3);
    }
    equals(p3) {
      Z2(p3);
      const { X: b4, Y: g4, Z: x5 } = this, { X: E4, Y: A4, Z: w3 } = p3, B4 = r2.eql(r2.mul(b4, w3), r2.mul(E4, x5)), I3 = r2.eql(r2.mul(g4, w3), r2.mul(A4, x5));
      return B4 && I3;
    }
    negate() {
      return new O5(this.X, r2.neg(this.Y), this.Z);
    }
    double() {
      const { a: p3, b: b4 } = s2, g4 = r2.mul(b4, Ze), { X: x5, Y: E4, Z: A4 } = this;
      let w3 = r2.ZERO, B4 = r2.ZERO, I3 = r2.ZERO, N4 = r2.mul(x5, x5), D2 = r2.mul(E4, E4), P4 = r2.mul(A4, A4), $3 = r2.mul(x5, E4);
      return $3 = r2.add($3, $3), I3 = r2.mul(x5, A4), I3 = r2.add(I3, I3), w3 = r2.mul(p3, I3), B4 = r2.mul(g4, P4), B4 = r2.add(w3, B4), w3 = r2.sub(D2, B4), B4 = r2.add(D2, B4), B4 = r2.mul(w3, B4), w3 = r2.mul($3, w3), I3 = r2.mul(g4, I3), P4 = r2.mul(p3, P4), $3 = r2.sub(N4, P4), $3 = r2.mul(p3, $3), $3 = r2.add($3, I3), I3 = r2.add(N4, N4), N4 = r2.add(I3, N4), N4 = r2.add(N4, P4), N4 = r2.mul(N4, $3), B4 = r2.add(B4, N4), P4 = r2.mul(E4, A4), P4 = r2.add(P4, P4), N4 = r2.mul(P4, $3), w3 = r2.sub(w3, N4), I3 = r2.mul(P4, D2), I3 = r2.add(I3, I3), I3 = r2.add(I3, I3), new O5(w3, B4, I3);
    }
    add(p3) {
      Z2(p3);
      const { X: b4, Y: g4, Z: x5 } = this, { X: E4, Y: A4, Z: w3 } = p3;
      let B4 = r2.ZERO, I3 = r2.ZERO, N4 = r2.ZERO;
      const D2 = s2.a, P4 = r2.mul(s2.b, Ze);
      let $3 = r2.mul(b4, E4), V3 = r2.mul(g4, A4), q2 = r2.mul(x5, w3), G4 = r2.add(b4, g4), M5 = r2.add(E4, A4);
      G4 = r2.mul(G4, M5), M5 = r2.add($3, V3), G4 = r2.sub(G4, M5), M5 = r2.add(b4, x5);
      let Y2 = r2.add(E4, w3);
      return M5 = r2.mul(M5, Y2), Y2 = r2.add($3, q2), M5 = r2.sub(M5, Y2), Y2 = r2.add(g4, x5), B4 = r2.add(A4, w3), Y2 = r2.mul(Y2, B4), B4 = r2.add(V3, q2), Y2 = r2.sub(Y2, B4), N4 = r2.mul(D2, M5), B4 = r2.mul(P4, q2), N4 = r2.add(B4, N4), B4 = r2.sub(V3, N4), N4 = r2.add(V3, N4), I3 = r2.mul(B4, N4), V3 = r2.add($3, $3), V3 = r2.add(V3, $3), q2 = r2.mul(D2, q2), M5 = r2.mul(P4, M5), V3 = r2.add(V3, q2), q2 = r2.sub($3, q2), q2 = r2.mul(D2, q2), M5 = r2.add(M5, q2), $3 = r2.mul(V3, M5), I3 = r2.add(I3, $3), $3 = r2.mul(Y2, M5), B4 = r2.mul(G4, B4), B4 = r2.sub(B4, $3), $3 = r2.mul(G4, V3), N4 = r2.mul(Y2, N4), N4 = r2.add(N4, $3), new O5(B4, I3, N4);
    }
    subtract(p3) {
      return this.add(p3.negate());
    }
    is0() {
      return this.equals(O5.ZERO);
    }
    multiply(p3) {
      const { endo: b4 } = e;
      if (!o2.isValidNot0(p3)) throw new Error("invalid scalar: out of range");
      let g4, x5;
      const E4 = (A4) => C6.cached(this, A4, (w3) => Tn(O5, w3));
      if (b4) {
        const { k1neg: A4, k1: w3, k2neg: B4, k2: I3 } = H2(p3), { p: N4, f: D2 } = E4(w3), { p: P4, f: $3 } = E4(I3);
        x5 = D2.add($3), g4 = k4(b4.beta, N4, P4, A4, B4);
      } else {
        const { p: A4, f: w3 } = E4(p3);
        g4 = A4, x5 = w3;
      }
      return Tn(O5, [g4, x5])[0];
    }
    multiplyUnsafe(p3) {
      const { endo: b4 } = e, g4 = this;
      if (!o2.isValid(p3)) throw new Error("invalid scalar: out of range");
      if (p3 === Et || g4.is0()) return O5.ZERO;
      if (p3 === ne) return g4;
      if (C6.hasCache(this)) return this.multiply(p3);
      if (b4) {
        const { k1neg: x5, k1: E4, k2neg: A4, k2: w3 } = H2(p3), { p1: B4, p2: I3 } = Tf(O5, g4, E4, w3);
        return k4(b4.beta, B4, I3, x5, A4);
      } else return C6.unsafe(g4, p3);
    }
    multiplyAndAddUnsafe(p3, b4, g4) {
      const x5 = this.multiplyUnsafe(b4).add(p3.multiplyUnsafe(g4));
      return x5.is0() ? void 0 : x5;
    }
    toAffine(p3) {
      return j3(this, p3);
    }
    isTorsionFree() {
      const { isTorsionFree: p3 } = e;
      return i4 === ne ? true : p3 ? p3(O5, this) : C6.unsafe(this, c5).is0();
    }
    clearCofactor() {
      const { clearCofactor: p3 } = e;
      return i4 === ne ? this : p3 ? p3(O5, this) : this.multiplyUnsafe(i4);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i4).is0();
    }
    toBytes(p3 = true) {
      return He(p3, "isCompressed"), this.assertValidity(), h4(O5, this, p3);
    }
    toHex(p3 = true) {
      return Jt(this.toBytes(p3));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(p3 = true) {
      return this.toBytes(p3);
    }
    _setWindowSize(p3) {
      this.precompute(p3);
    }
    static normalizeZ(p3) {
      return Tn(O5, p3);
    }
    static msm(p3, b4) {
      return Cf(O5, o2, p3, b4);
    }
    static fromPrivateKey(p3) {
      return O5.BASE.multiply(re(o2, p3));
    }
  }
  O5.BASE = new O5(s2.Gx, s2.Gy, r2.ONE), O5.ZERO = new O5(r2.ZERO, r2.ONE, r2.ZERO), O5.Fp = r2, O5.Fn = o2;
  const T4 = o2.BITS, C6 = new $f(O5, e.endo ? Math.ceil(T4 / 2) : T4);
  return O5.BASE.precompute(8), O5;
}
function Yo(t) {
  return Uint8Array.of(t ? 2 : 3);
}
function Wo(t, e) {
  return { secretKey: e.BYTES, publicKey: 1 + t.BYTES, publicKeyUncompressed: 1 + 2 * t.BYTES, publicKeyHasPrefix: true, signature: 2 * e.BYTES };
}
function Wf(t, e = {}) {
  const { Fn: n3 } = t, r2 = e.randomBytes || Mt, o2 = Object.assign(Wo(t.Fp, n3), { seed: Ho(n3.ORDER) });
  function s2(h4) {
    try {
      return !!re(n3, h4);
    } catch {
      return false;
    }
  }
  function i4(h4, y5) {
    const { publicKey: m4, publicKeyUncompressed: v5 } = o2;
    try {
      const U4 = h4.length;
      return y5 === true && U4 !== m4 || y5 === false && U4 !== v5 ? false : !!t.fromBytes(h4);
    } catch {
      return false;
    }
  }
  function c5(h4 = r2(o2.seed)) {
    return Uf(Kt(h4, o2.seed, "seed"), n3.ORDER);
  }
  function f7(h4, y5 = true) {
    return t.BASE.multiply(re(n3, h4)).toBytes(y5);
  }
  function u2(h4) {
    const y5 = c5(h4);
    return { secretKey: y5, publicKey: f7(y5) };
  }
  function a2(h4) {
    if (typeof h4 == "bigint") return false;
    if (h4 instanceof t) return true;
    const { secretKey: y5, publicKey: m4, publicKeyUncompressed: v5 } = o2;
    if (n3.allowedLengths || y5 === m4) return;
    const U4 = tt("key", h4).length;
    return U4 === m4 || U4 === v5;
  }
  function l4(h4, y5, m4 = true) {
    if (a2(h4) === true) throw new Error("first arg must be private key");
    if (a2(y5) === false) throw new Error("second arg must be public key");
    const v5 = re(n3, h4);
    return t.fromHex(y5).multiply(v5).toBytes(m4);
  }
  return Object.freeze({ getPublicKey: f7, getSharedSecret: l4, keygen: u2, Point: t, utils: { isValidSecretKey: s2, isValidPublicKey: i4, randomSecretKey: c5, isValidPrivateKey: s2, randomPrivateKey: c5, normPrivateKeyToScalar: (h4) => re(n3, h4), precompute(h4 = 8, y5 = t.BASE) {
    return y5.precompute(h4, false);
  } }, lengths: o2 });
}
function Xf(t, e, n3 = {}) {
  Ue(e), Ke(n3, {}, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r2 = n3.randomBytes || Mt, o2 = n3.hmac || ((b4, ...g4) => ke(e, b4, _t(...g4))), { Fp: s2, Fn: i4 } = t, { ORDER: c5, BITS: f7 } = i4, { keygen: u2, getPublicKey: a2, getSharedSecret: l4, utils: d5, lengths: h4 } = Wf(t, n3), y5 = { prehash: false, lowS: typeof n3.lowS == "boolean" ? n3.lowS : false, format: void 0, extraEntropy: false }, m4 = "compact";
  function v5(b4) {
    const g4 = c5 >> ne;
    return b4 > g4;
  }
  function U4(b4, g4) {
    if (!i4.isValidNot0(g4)) throw new Error(`invalid signature ${b4}: out of range 1..Point.Fn.ORDER`);
    return g4;
  }
  function F3(b4, g4) {
    Pn(g4);
    const x5 = h4.signature, E4 = g4 === "compact" ? x5 : g4 === "recovered" ? x5 + 1 : void 0;
    return Kt(b4, E4, `${g4} signature`);
  }
  class R4 {
    constructor(g4, x5, E4) {
      this.r = U4("r", g4), this.s = U4("s", x5), E4 != null && (this.recovery = E4), Object.freeze(this);
    }
    static fromBytes(g4, x5 = m4) {
      F3(g4, x5);
      let E4;
      if (x5 === "der") {
        const { r: I3, s: N4 } = xt.toSig(Kt(g4));
        return new R4(I3, N4);
      }
      x5 === "recovered" && (E4 = g4[0], x5 = "compact", g4 = g4.subarray(1));
      const A4 = i4.BYTES, w3 = g4.subarray(0, A4), B4 = g4.subarray(A4, A4 * 2);
      return new R4(i4.fromBytes(w3), i4.fromBytes(B4), E4);
    }
    static fromHex(g4, x5) {
      return this.fromBytes(_e(g4), x5);
    }
    addRecoveryBit(g4) {
      return new R4(this.r, this.s, g4);
    }
    recoverPublicKey(g4) {
      const x5 = s2.ORDER, { r: E4, s: A4, recovery: w3 } = this;
      if (w3 == null || ![0, 1, 2, 3].includes(w3)) throw new Error("recovery id invalid");
      if (c5 * zo < x5 && w3 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const I3 = w3 === 2 || w3 === 3 ? E4 + c5 : E4;
      if (!s2.isValid(I3)) throw new Error("recovery id 2 or 3 invalid");
      const N4 = s2.toBytes(I3), D2 = t.fromBytes(_t(Yo((w3 & 1) === 0), N4)), P4 = i4.inv(I3), $3 = H2(tt("msgHash", g4)), V3 = i4.create(-$3 * P4), q2 = i4.create(A4 * P4), G4 = t.BASE.multiplyUnsafe(V3).add(D2.multiplyUnsafe(q2));
      if (G4.is0()) throw new Error("point at infinify");
      return G4.assertValidity(), G4;
    }
    hasHighS() {
      return v5(this.s);
    }
    toBytes(g4 = m4) {
      if (Pn(g4), g4 === "der") return _e(xt.hexFromSig(this));
      const x5 = i4.toBytes(this.r), E4 = i4.toBytes(this.s);
      if (g4 === "recovered") {
        if (this.recovery == null) throw new Error("recovery bit must be present");
        return _t(Uint8Array.of(this.recovery), x5, E4);
      }
      return _t(x5, E4);
    }
    toHex(g4) {
      return Jt(this.toBytes(g4));
    }
    assertValidity() {
    }
    static fromCompact(g4) {
      return R4.fromBytes(tt("sig", g4), "compact");
    }
    static fromDER(g4) {
      return R4.fromBytes(tt("sig", g4), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new R4(this.r, i4.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Jt(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Jt(this.toBytes("compact"));
    }
  }
  const Z2 = n3.bits2int || function(g4) {
    if (g4.length > 8192) throw new Error("input is too large");
    const x5 = Ve(g4), E4 = g4.length * 8 - f7;
    return E4 > 0 ? x5 >> BigInt(E4) : x5;
  }, H2 = n3.bits2int_modN || function(g4) {
    return i4.create(Z2(g4));
  }, j3 = ye(f7);
  function L3(b4) {
    return Rn("num < 2^" + f7, b4, Et, j3), i4.toBytes(b4);
  }
  function k4(b4, g4) {
    return Kt(b4, void 0, "message"), g4 ? Kt(e(b4), void 0, "prehashed message") : b4;
  }
  function O5(b4, g4, x5) {
    if (["recovered", "canonical"].some((V3) => V3 in x5)) throw new Error("sign() legacy options not supported");
    const { lowS: E4, prehash: A4, extraEntropy: w3 } = Hn(x5, y5);
    b4 = k4(b4, A4);
    const B4 = H2(b4), I3 = re(i4, g4), N4 = [L3(I3), L3(B4)];
    if (w3 != null && w3 !== false) {
      const V3 = w3 === true ? r2(h4.secretKey) : w3;
      N4.push(tt("extraEntropy", V3));
    }
    const D2 = _t(...N4), P4 = B4;
    function $3(V3) {
      const q2 = Z2(V3);
      if (!i4.isValidNot0(q2)) return;
      const G4 = i4.inv(q2), M5 = t.BASE.multiply(q2).toAffine(), Y2 = i4.create(M5.x);
      if (Y2 === Et) return;
      const Yt3 = i4.create(G4 * i4.create(P4 + Y2 * I3));
      if (Yt3 === Et) return;
      let ce3 = (M5.x === Y2 ? 0 : 2) | Number(M5.y & ne), fe4 = Yt3;
      return E4 && v5(Yt3) && (fe4 = i4.neg(Yt3), ce3 ^= 1), new R4(Y2, fe4, ce3);
    }
    return { seed: D2, k2sig: $3 };
  }
  function T4(b4, g4, x5 = {}) {
    b4 = tt("message", b4);
    const { seed: E4, k2sig: A4 } = O5(b4, g4, x5);
    return vf(e.outputLen, i4.BYTES, o2)(E4, A4);
  }
  function C6(b4) {
    let g4;
    const x5 = typeof b4 == "string" || Ne(b4), E4 = !x5 && b4 !== null && typeof b4 == "object" && typeof b4.r == "bigint" && typeof b4.s == "bigint";
    if (!x5 && !E4) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (E4) g4 = new R4(b4.r, b4.s);
    else if (x5) {
      try {
        g4 = R4.fromBytes(tt("sig", b4), "der");
      } catch (A4) {
        if (!(A4 instanceof xt.Err)) throw A4;
      }
      if (!g4) try {
        g4 = R4.fromBytes(tt("sig", b4), "compact");
      } catch {
        return false;
      }
    }
    return g4 || false;
  }
  function _4(b4, g4, x5, E4 = {}) {
    const { lowS: A4, prehash: w3, format: B4 } = Hn(E4, y5);
    if (x5 = tt("publicKey", x5), g4 = k4(tt("message", g4), w3), "strict" in E4) throw new Error("options.strict was renamed to lowS");
    const I3 = B4 === void 0 ? C6(b4) : R4.fromBytes(tt("sig", b4), B4);
    if (I3 === false) return false;
    try {
      const N4 = t.fromBytes(x5);
      if (A4 && I3.hasHighS()) return false;
      const { r: D2, s: P4 } = I3, $3 = H2(g4), V3 = i4.inv(P4), q2 = i4.create($3 * V3), G4 = i4.create(D2 * V3), M5 = t.BASE.multiplyUnsafe(q2).add(N4.multiplyUnsafe(G4));
      return M5.is0() ? false : i4.create(M5.x) === D2;
    } catch {
      return false;
    }
  }
  function p3(b4, g4, x5 = {}) {
    const { prehash: E4 } = Hn(x5, y5);
    return g4 = k4(g4, E4), R4.fromBytes(b4, "recovered").recoverPublicKey(g4).toBytes();
  }
  return Object.freeze({ keygen: u2, getPublicKey: a2, getSharedSecret: l4, utils: d5, lengths: h4, Point: t, sign: T4, verify: _4, recoverPublicKey: p3, Signature: R4, hash: e });
}
function Jf(t) {
  const e = { a: t.a, b: t.b, p: t.Fp.ORDER, n: t.n, h: t.h, Gx: t.Gx, Gy: t.Gy }, n3 = t.Fp;
  let r2 = t.allowedPrivateKeyLengths ? Array.from(new Set(t.allowedPrivateKeyLengths.map((i4) => Math.ceil(i4 / 2)))) : void 0;
  const o2 = Ht(e.n, { BITS: t.nBitLength, allowedLengths: r2, modFromBytes: t.wrapPrivateKey }), s2 = { Fp: n3, Fn: o2, allowInfinityPoint: t.allowInfinityPoint, endo: t.endo, isTorsionFree: t.isTorsionFree, clearCofactor: t.clearCofactor, fromBytes: t.fromBytes, toBytes: t.toBytes };
  return { CURVE: e, curveOpts: s2 };
}
function Qf(t) {
  const { CURVE: e, curveOpts: n3 } = Jf(t), r2 = { hmac: t.hmac, randomBytes: t.randomBytes, lowS: t.lowS, bits2int: t.bits2int, bits2int_modN: t.bits2int_modN };
  return { CURVE: e, curveOpts: n3, hash: t.hash, ecdsaOpts: r2 };
}
function ta(t, e) {
  const n3 = e.Point;
  return Object.assign({}, e, { ProjectivePoint: n3, CURVE: Object.assign({}, t, ko(n3.Fn.ORDER, n3.Fn.BITS)) });
}
function ea(t) {
  const { CURVE: e, curveOpts: n3, hash: r2, ecdsaOpts: o2 } = Qf(t), s2 = Yf(e, n3), i4 = Xf(s2, r2, o2);
  return ta(t, i4);
}
function Dn(t, e) {
  const n3 = (r2) => ea({ ...t, hash: r2 });
  return { ...n3(e), create: n3 };
}
var Xo = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Jo = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Qo2 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var na = Ht(Xo.p);
var ra = Ht(Jo.p);
var oa = Ht(Qo2.p);
var sa = Dn({ ...Xo, Fp: na, lowS: false }, $e);
Dn({ ...Jo, Fp: ra, lowS: false }, gc), Dn({ ...Qo2, Fp: oa, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, pc);
var ia = sa;
var Vn = "base10";
var rt = "base16";
var oe = "base64pad";
var Ge = "base64url";
var se = "utf8";
var Mn = 0;
var ie = 1;
var we = 2;
var ca = 0;
var ts = 1;
var ve = 12;
var Kn = 32;
function fa() {
  const t = kn.utils.randomPrivateKey(), e = kn.getPublicKey(t);
  return { privateKey: toString(t, rt), publicKey: toString(e, rt) };
}
function aa() {
  const t = Mt(Kn);
  return toString(t, rt);
}
function ua(t, e) {
  const n3 = kn.getSharedSecret(fromString(t, rt), fromString(e, rt)), r2 = mf(Pe, n3, void 0, void 0, Kn);
  return toString(r2, rt);
}
function la(t) {
  const e = Pe(fromString(t, rt));
  return toString(e, rt);
}
function da(t) {
  const e = Pe(fromString(t, se));
  return toString(e, rt);
}
function qn(t) {
  return fromString(`${t}`, Vn);
}
function Zt(t) {
  return Number(toString(t, Vn));
}
function es(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ns(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n3 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n3);
}
function ha(t) {
  const e = qn(typeof t.type < "u" ? t.type : Mn);
  if (Zt(e) === ie && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n3 = typeof t.senderPublicKey < "u" ? fromString(t.senderPublicKey, rt) : void 0, r2 = typeof t.iv < "u" ? fromString(t.iv, rt) : Mt(ve), o2 = fromString(t.symKey, rt), s2 = xo(o2, r2).encrypt(fromString(t.message, se)), i4 = Fn({ type: e, sealed: s2, iv: r2, senderPublicKey: n3 });
  return t.encoding === Ge ? es(i4) : i4;
}
function pa(t) {
  const e = fromString(t.symKey, rt), { sealed: n3, iv: r2 } = ze({ encoded: t.encoded, encoding: t.encoding }), o2 = xo(e, r2).decrypt(n3);
  if (o2 === null) throw new Error("Failed to decrypt");
  return toString(o2, se);
}
function ga(t, e) {
  const n3 = qn(we), r2 = Mt(ve), o2 = fromString(t, se), s2 = Fn({ type: n3, sealed: o2, iv: r2 });
  return e === Ge ? es(s2) : s2;
}
function ba(t, e) {
  const { sealed: n3 } = ze({ encoded: t, encoding: e });
  return toString(n3, se);
}
function Fn(t) {
  if (Zt(t.type) === we) return toString(concat([t.type, t.sealed]), oe);
  if (Zt(t.type) === ie) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([t.type, t.senderPublicKey, t.iv, t.sealed]), oe);
  }
  return toString(concat([t.type, t.iv, t.sealed]), oe);
}
function ze(t) {
  const e = (t.encoding || oe) === Ge ? ns(t.encoded) : t.encoded, n3 = fromString(e, oe), r2 = n3.slice(ca, ts), o2 = ts;
  if (Zt(r2) === ie) {
    const f7 = o2 + Kn, u2 = f7 + ve, a2 = n3.slice(o2, f7), l4 = n3.slice(f7, u2), d5 = n3.slice(u2);
    return { type: r2, sealed: d5, iv: l4, senderPublicKey: a2 };
  }
  if (Zt(r2) === we) {
    const f7 = n3.slice(o2), u2 = Mt(ve);
    return { type: r2, sealed: f7, iv: u2 };
  }
  const s2 = o2 + ve, i4 = n3.slice(o2, s2), c5 = n3.slice(s2);
  return { type: r2, sealed: c5, iv: i4 };
}
function ya(t, e) {
  const n3 = ze({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return rs({ type: Zt(n3.type), senderPublicKey: typeof n3.senderPublicKey < "u" ? toString(n3.senderPublicKey, rt) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function rs(t) {
  const e = (t == null ? void 0 : t.type) || Mn;
  if (e === ie) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function ma(t) {
  return t.type === ie && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function wa(t) {
  return t.type === we;
}
function os(t) {
  const e = Buffer.from(t.x, "base64"), n3 = Buffer.from(t.y, "base64");
  return concat([new Uint8Array([4]), e, n3]);
}
function va(t, e) {
  const [n3, r2, o2] = t.split("."), s2 = Buffer.from(ns(o2), "base64");
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32), c5 = s2.slice(32, 64), f7 = `${n3}.${r2}`, u2 = Pe(f7), a2 = os(e);
  if (!ia.verify(concat([i4, c5]), u2, a2)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var ss = "irn";
function xa(t) {
  return (t == null ? void 0 : t.relay) || { protocol: ss };
}
function Ea(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var Ba = Object.defineProperty;
var Aa = Object.defineProperties;
var Ia = Object.getOwnPropertyDescriptors;
var is = Object.getOwnPropertySymbols;
var Sa = Object.prototype.hasOwnProperty;
var Oa = Object.prototype.propertyIsEnumerable;
var cs = (t, e, n3) => e in t ? Ba(t, e, { enumerable: true, configurable: true, writable: true, value: n3 }) : t[e] = n3;
var Zn = (t, e) => {
  for (var n3 in e || (e = {})) Sa.call(e, n3) && cs(t, n3, e[n3]);
  if (is) for (var n3 of is(e)) Oa.call(e, n3) && cs(t, n3, e[n3]);
  return t;
};
var Na = (t, e) => Aa(t, Ia(e));
function fs(t, e = "-") {
  const n3 = {}, r2 = "relay" + e;
  return Object.keys(t).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s2 = o2.replace(r2, ""), i4 = t[o2];
      n3[s2] = i4;
    }
  }), n3;
}
function Ua(t) {
  if (!t.includes("wc:")) {
    const u2 = cn(t);
    u2 != null && u2.includes("wc:") && (t = u2);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n3 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r2 = t.substring(0, e), o2 = t.substring(e + 1, n3).split("@"), s2 = typeof n3 < "u" ? t.substring(n3) : "", i4 = new URLSearchParams(s2), c5 = Object.fromEntries(i4.entries()), f7 = typeof c5.methods == "string" ? c5.methods.split(",") : void 0;
  return { protocol: r2, topic: as(o2[0]), version: parseInt(o2[1], 10), symKey: c5.symKey, relay: fs(c5), methods: f7, expiryTimestamp: c5.expiryTimestamp ? parseInt(c5.expiryTimestamp, 10) : void 0 };
}
function as(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function us(t, e = "-") {
  const n3 = "relay", r2 = {};
  return Object.keys(t).forEach((o2) => {
    const s2 = o2, i4 = n3 + e + s2;
    t[s2] && (r2[i4] = t[s2]);
  }), r2;
}
function _a(t) {
  const e = new URLSearchParams(), n3 = Zn(Zn(Na(Zn({}, us(t.relay)), { symKey: t.symKey }), t.expiryTimestamp && { expiryTimestamp: t.expiryTimestamp.toString() }), t.methods && { methods: t.methods.join(",") });
  return Object.entries(n3).sort(([r2], [o2]) => r2.localeCompare(o2)).forEach(([r2, o2]) => {
    o2 !== void 0 && e.append(r2, String(o2));
  }), `${t.protocol}:${t.topic}@${t.version}?${e}`;
}
function Ra(t, e, n3) {
  return `${t}?wc_ev=${n3}&topic=${e}`;
}
var $a = Object.defineProperty;
var Ta = Object.defineProperties;
var Ca = Object.getOwnPropertyDescriptors;
var ls = Object.getOwnPropertySymbols;
var ja = Object.prototype.hasOwnProperty;
var La = Object.prototype.propertyIsEnumerable;
var ds = (t, e, n3) => e in t ? $a(t, e, { enumerable: true, configurable: true, writable: true, value: n3 }) : t[e] = n3;
var ka = (t, e) => {
  for (var n3 in e || (e = {})) ja.call(e, n3) && ds(t, n3, e[n3]);
  if (ls) for (var n3 of ls(e)) La.call(e, n3) && ds(t, n3, e[n3]);
  return t;
};
var Pa = (t, e) => Ta(t, Ca(e));
function Gt(t) {
  const e = [];
  return t.forEach((n3) => {
    const [r2, o2] = n3.split(":");
    e.push(`${r2}:${o2}`);
  }), e;
}
function hs(t) {
  const e = [];
  return Object.values(t).forEach((n3) => {
    e.push(...Gt(n3.accounts));
  }), e;
}
function ps(t, e) {
  const n3 = [];
  return Object.values(t).forEach((r2) => {
    Gt(r2.accounts).includes(e) && n3.push(...r2.methods);
  }), n3;
}
function gs(t, e) {
  const n3 = [];
  return Object.values(t).forEach((r2) => {
    Gt(r2.accounts).includes(e) && n3.push(...r2.events);
  }), n3;
}
function Gn(t) {
  return t.includes(":");
}
function bs(t) {
  return Gn(t) ? t.split(":")[0] : t;
}
function xe(t) {
  var e, n3, r2;
  const o2 = {};
  if (!Ye(t)) return o2;
  for (const [s2, i4] of Object.entries(t)) {
    const c5 = Gn(s2) ? [s2] : i4.chains, f7 = i4.methods || [], u2 = i4.events || [], a2 = bs(s2);
    o2[a2] = Pa(ka({}, o2[a2]), { chains: ut(c5, (e = o2[a2]) == null ? void 0 : e.chains), methods: ut(f7, (n3 = o2[a2]) == null ? void 0 : n3.methods), events: ut(u2, (r2 = o2[a2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
function ys(t) {
  const e = {};
  return t == null ? void 0 : t.forEach((n3) => {
    var r2;
    const [o2, s2] = n3.split(":");
    e[o2] || (e[o2] = { accounts: [], chains: [], events: [], methods: [] }), e[o2].accounts.push(n3), (r2 = e[o2].chains) == null || r2.push(`${o2}:${s2}`);
  }), e;
}
function Va(t, e) {
  e = e.map((r2) => r2.replace("did:pkh:", ""));
  const n3 = ys(e);
  for (const [r2, o2] of Object.entries(n3)) o2.methods ? o2.methods = ut(o2.methods, t) : o2.methods = t, o2.events = ["chainChanged", "accountsChanged"];
  return n3;
}
function Ma(t, e) {
  var n3, r2, o2, s2, i4, c5;
  const f7 = xe(t), u2 = xe(e), a2 = {}, l4 = Object.keys(f7).concat(Object.keys(u2));
  for (const d5 of l4) a2[d5] = { chains: ut((n3 = f7[d5]) == null ? void 0 : n3.chains, (r2 = u2[d5]) == null ? void 0 : r2.chains), methods: ut((o2 = f7[d5]) == null ? void 0 : o2.methods, (s2 = u2[d5]) == null ? void 0 : s2.methods), events: ut((i4 = f7[d5]) == null ? void 0 : i4.events, (c5 = u2[d5]) == null ? void 0 : c5.events) };
  return a2;
}
var ms = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var ws = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Bt(t, e) {
  const { message: n3, code: r2 } = ws[t];
  return { message: e ? `${n3} ${e}` : n3, code: r2 };
}
function zt(t, e) {
  const { message: n3, code: r2 } = ms[t];
  return { message: e ? `${n3} ${e}` : n3, code: r2 };
}
function Ee(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function Ye(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Dt(t) {
  return typeof t > "u";
}
function ft(t, e) {
  return e && Dt(t) ? true : typeof t == "string" && !!t.trim().length;
}
function We(t, e) {
  return e && Dt(t) ? true : typeof t == "number" && !isNaN(t);
}
function Ka(t, e) {
  const { requiredNamespaces: n3 } = e, r2 = Object.keys(t.namespaces), o2 = Object.keys(n3);
  let s2 = true;
  return It(o2, r2) ? (r2.forEach((i4) => {
    const { accounts: c5, methods: f7, events: u2 } = t.namespaces[i4], a2 = Gt(c5), l4 = n3[i4];
    (!It(Ie(i4, l4), a2) || !It(l4.methods, f7) || !It(l4.events, u2)) && (s2 = false);
  }), s2) : false;
}
function Be(t) {
  return ft(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function vs(t) {
  if (ft(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n3 = e[0] + ":" + e[1];
      return !!e[2] && Be(n3);
    }
  }
  return false;
}
function qa(t) {
  function e(n3) {
    try {
      return typeof new URL(n3) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (ft(t, false)) {
      if (e(t)) return true;
      const n3 = cn(t);
      return e(n3);
    }
  } catch {
  }
  return false;
}
function Fa(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function Za(t) {
  return t == null ? void 0 : t.topic;
}
function Ga(t, e) {
  let n3 = null;
  return ft(t == null ? void 0 : t.publicKey, false) || (n3 = Bt("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n3;
}
function zn(t) {
  let e = true;
  return Ee(t) ? t.length && (e = t.every((n3) => ft(n3, false))) : e = false, e;
}
function xs(t, e, n3) {
  let r2 = null;
  return Ee(e) && e.length ? e.forEach((o2) => {
    r2 || Be(o2) || (r2 = zt("UNSUPPORTED_CHAINS", `${n3}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : Be(t) || (r2 = zt("UNSUPPORTED_CHAINS", `${n3}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function Es(t, e, n3) {
  let r2 = null;
  return Object.entries(t).forEach(([o2, s2]) => {
    if (r2) return;
    const i4 = xs(o2, Ie(o2, s2), `${e} ${n3}`);
    i4 && (r2 = i4);
  }), r2;
}
function Bs(t, e) {
  let n3 = null;
  return Ee(t) ? t.forEach((r2) => {
    n3 || vs(r2) || (n3 = zt("UNSUPPORTED_ACCOUNTS", `${e}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n3 = zt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n3;
}
function As(t, e) {
  let n3 = null;
  return Object.values(t).forEach((r2) => {
    if (n3) return;
    const o2 = Bs(r2 == null ? void 0 : r2.accounts, `${e} namespace`);
    o2 && (n3 = o2);
  }), n3;
}
function Is(t, e) {
  let n3 = null;
  return zn(t == null ? void 0 : t.methods) ? zn(t == null ? void 0 : t.events) || (n3 = zt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n3 = zt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n3;
}
function Yn(t, e) {
  let n3 = null;
  return Object.values(t).forEach((r2) => {
    if (n3) return;
    const o2 = Is(r2, `${e}, namespace`);
    o2 && (n3 = o2);
  }), n3;
}
function za(t, e, n3) {
  let r2 = null;
  if (t && Ye(t)) {
    const o2 = Yn(t, e);
    o2 && (r2 = o2);
    const s2 = Es(t, e, n3);
    s2 && (r2 = s2);
  } else r2 = Bt("MISSING_OR_INVALID", `${e}, ${n3} should be an object with data`);
  return r2;
}
function Ss(t, e) {
  let n3 = null;
  if (t && Ye(t)) {
    const r2 = Yn(t, e);
    r2 && (n3 = r2);
    const o2 = As(t, e);
    o2 && (n3 = o2);
  } else n3 = Bt("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n3;
}
function Os(t) {
  return ft(t.protocol, true);
}
function Ya(t, e) {
  let n3 = false;
  return e && !t ? n3 = true : t && Ee(t) && t.length && t.forEach((r2) => {
    n3 = Os(r2);
  }), n3;
}
function Wa(t) {
  return typeof t == "number";
}
function Xa(t) {
  return typeof t < "u" && typeof t !== null;
}
function Ja(t) {
  return !(!t || typeof t != "object" || !t.code || !We(t.code, false) || !t.message || !ft(t.message, false));
}
function Qa(t) {
  return !(Dt(t) || !ft(t.method, false));
}
function tu(t) {
  return !(Dt(t) || Dt(t.result) && Dt(t.error) || !We(t.id, false) || !ft(t.jsonrpc, false));
}
function eu(t) {
  return !(Dt(t) || !ft(t.name, false));
}
function nu(t, e) {
  return !(!Be(e) || !hs(t).includes(e));
}
function ru(t, e, n3) {
  return ft(n3, false) ? ps(t, e).includes(n3) : false;
}
function ou(t, e, n3) {
  return ft(n3, false) ? gs(t, e).includes(n3) : false;
}
function Ns(t, e, n3) {
  let r2 = null;
  const o2 = su(t), s2 = iu(e), i4 = Object.keys(o2), c5 = Object.keys(s2), f7 = Us(Object.keys(t)), u2 = Us(Object.keys(e)), a2 = f7.filter((l4) => !u2.includes(l4));
  return a2.length && (r2 = Bt("NON_CONFORMING_NAMESPACES", `${n3} namespaces keys don't satisfy requiredNamespaces.
      Required: ${a2.toString()}
      Received: ${Object.keys(e).toString()}`)), It(i4, c5) || (r2 = Bt("NON_CONFORMING_NAMESPACES", `${n3} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${c5.toString()}`)), Object.keys(e).forEach((l4) => {
    if (!l4.includes(":") || r2) return;
    const d5 = Gt(e[l4].accounts);
    d5.includes(l4) || (r2 = Bt("NON_CONFORMING_NAMESPACES", `${n3} namespaces accounts don't satisfy namespace accounts for ${l4}
        Required: ${l4}
        Approved: ${d5.toString()}`));
  }), i4.forEach((l4) => {
    r2 || (It(o2[l4].methods, s2[l4].methods) ? It(o2[l4].events, s2[l4].events) || (r2 = Bt("NON_CONFORMING_NAMESPACES", `${n3} namespaces events don't satisfy namespace events for ${l4}`)) : r2 = Bt("NON_CONFORMING_NAMESPACES", `${n3} namespaces methods don't satisfy namespace methods for ${l4}`));
  }), r2;
}
function su(t) {
  const e = {};
  return Object.keys(t).forEach((n3) => {
    var r2;
    n3.includes(":") ? e[n3] = t[n3] : (r2 = t[n3].chains) == null || r2.forEach((o2) => {
      e[o2] = { methods: t[n3].methods, events: t[n3].events };
    });
  }), e;
}
function Us(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function iu(t) {
  const e = {};
  return Object.keys(t).forEach((n3) => {
    if (n3.includes(":")) e[n3] = t[n3];
    else {
      const r2 = Gt(t[n3].accounts);
      r2 == null ? void 0 : r2.forEach((o2) => {
        e[o2] = { accounts: t[n3].accounts.filter((s2) => s2.includes(`${o2}:`)), methods: t[n3].methods, events: t[n3].events };
      });
    }
  }), e;
}
function cu(t, e) {
  return We(t, false) && t <= e.max && t >= e.min;
}
function fu() {
  const t = Vt();
  return new Promise((e) => {
    switch (t) {
      case et.browser:
        e(_s());
        break;
      case et.reactNative:
        e(Rs());
        break;
      case et.node:
        e($s());
        break;
      default:
        e(true);
    }
  });
}
function _s() {
  return Wt() && (navigator == null ? void 0 : navigator.onLine);
}
async function Rs() {
  if (At() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return true;
}
function $s() {
  return true;
}
function au(t) {
  switch (Vt()) {
    case et.browser:
      Ts(t);
      break;
    case et.reactNative:
      Cs(t);
      break;
    case et.node:
      break;
  }
}
function Ts(t) {
  !At() && Wt() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function Cs(t) {
  At() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
function uu() {
  var t;
  return Wt() && (0, import_window_getters.getDocument)() ? ((t = (0, import_window_getters.getDocument)()) == null ? void 0 : t.visibilityState) === "visible" : true;
}
var Wn = {};
var lu = class {
  static get(e) {
    return Wn[e];
  }
  static set(e, n3) {
    Wn[e] = n3;
  }
  static delete(e) {
    delete Wn[e];
  }
};
function js(t) {
  const e = esm_default.decode(t);
  if (e.length < 33) throw new Error("Too short to contain a public key");
  return e.slice(1, 33);
}
function Ls({ publicKey: t, signature: e, payload: n3 }) {
  var r2;
  const o2 = Xn(n3.method), s2 = 128 | parseInt(((r2 = n3.version) == null ? void 0 : r2.toString()) || "4"), i4 = hu(n3.address), c5 = n3.era === "00" ? new Uint8Array([0]) : Xn(n3.era);
  if (c5.length !== 1 && c5.length !== 2) throw new Error("Invalid era length");
  const f7 = parseInt(n3.nonce, 16), u2 = new Uint8Array([f7 & 255, f7 >> 8 & 255]), a2 = BigInt(`0x${du(n3.tip)}`), l4 = gu(a2), d5 = new Uint8Array([0, ...t, i4, ...e, ...c5, ...u2, ...l4, ...o2]), h4 = pu(d5.length + 1);
  return new Uint8Array([...h4, s2, ...d5]);
}
function ks(t) {
  const e = Xn(t), n3 = (0, import_blakejs.blake2b)(e, void 0, 32);
  return "0x" + Buffer.from(n3).toString("hex");
}
function Xn(t) {
  return new Uint8Array(t.replace(/^0x/, "").match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
function du(t) {
  return t.startsWith("0x") ? t.slice(2) : t;
}
function hu(t) {
  const e = esm_default.decode(t)[0];
  return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function pu(t) {
  if (t < 64) return new Uint8Array([t << 2]);
  if (t < 16384) {
    const e = t << 2 | 1;
    return new Uint8Array([e & 255, e >> 8 & 255]);
  } else if (t < 1 << 30) {
    const e = t << 2 | 2;
    return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function gu(t) {
  if (t < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t << BigInt(2))]);
  if (t < BigInt(1) << BigInt(14)) {
    const e = t << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))]);
  } else if (t < BigInt(1) << BigInt(30)) {
    const e = t << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function bu(t) {
  const e = Uint8Array.from(Buffer.from(t.signature, "hex")), n3 = js(t.transaction.address), r2 = Ls({ publicKey: n3, signature: e, payload: t.transaction }), o2 = Buffer.from(r2).toString("hex");
  return ks(o2);
}

// node_modules/@reown/appkit/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var Ue2 = "wc";
var Fe2 = 2;
var pe2 = "core";
var W2 = `${Ue2}@2:${pe2}:`;
var It2 = { name: pe2, logger: "error" };
var Tt2 = { database: ":memory:" };
var Ct2 = "crypto";
var Me2 = "client_ed25519_seed";
var Pt2 = import_time2.ONE_DAY;
var St2 = "keychain";
var Ot2 = "0.3";
var Rt2 = "messages";
var At2 = "0.3";
var xt2 = import_time2.SIX_HOURS;
var Nt2 = "publisher";
var $t2 = "irn";
var zt2 = "error";
var Ke2 = "wss://relay.walletconnect.org";
var Lt2 = "relayer";
var C3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var kt2 = "_subscription";
var M2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var jt2 = 0.1;
var Pe2 = "2.21.9";
var ee2 = { link_mode: "link_mode", relay: "relay" };
var ye2 = { inbound: "inbound", outbound: "outbound" };
var Ut2 = "0.3";
var Ft2 = "WALLETCONNECT_CLIENT_ID";
var Be2 = "WALLETCONNECT_LINK_MODE_APPS";
var U2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Mt2 = "subscription";
var Kt2 = "0.3";
var Qs2 = import_time2.FIVE_SECONDS * 1e3;
var Bt2 = "pairing";
var Vt2 = "0.3";
var oe2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var ae2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var V2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var qt2 = "history";
var Gt2 = "0.3";
var Wt2 = "expirer";
var q = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ht2 = "0.3";
var Yt = "verify-api";
var ir = "https://verify.walletconnect.com";
var Jt2 = "https://verify.walletconnect.org";
var be2 = Jt2;
var Xt2 = `${be2}/v3`;
var Zt2 = [ir, Jt2];
var Qt2 = "echo";
var ei2 = "https://echo.walletconnect.com";
var Y = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var X2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var rr2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var nr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var or = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var ar2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var ti2 = 0.1;
var ii = "event-client";
var si = 86400;
var ri2 = "https://pulse.walletconnect.org/batch";
function cr(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i4 = 0; i4 < t.length; i4++) t[i4] = 255;
  for (var s2 = 0; s2 < r2.length; s2++) {
    var n3 = r2.charAt(s2), o2 = n3.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n3 + " is ambiguous");
    t[o2] = s2;
  }
  var a2 = r2.length, c5 = r2.charAt(0), h4 = Math.log(a2) / Math.log(256), l4 = Math.log(256) / Math.log(a2);
  function p3(u2) {
    if (u2 instanceof Uint8Array || (ArrayBuffer.isView(u2) ? u2 = new Uint8Array(u2.buffer, u2.byteOffset, u2.byteLength) : Array.isArray(u2) && (u2 = Uint8Array.from(u2))), !(u2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u2.length === 0) return "";
    for (var m4 = 0, D2 = 0, _4 = 0, E4 = u2.length; _4 !== E4 && u2[_4] === 0; ) _4++, m4++;
    for (var L3 = (E4 - _4) * l4 + 1 >>> 0, I3 = new Uint8Array(L3); _4 !== E4; ) {
      for (var k4 = u2[_4], T4 = 0, S5 = L3 - 1; (k4 !== 0 || T4 < D2) && S5 !== -1; S5--, T4++) k4 += 256 * I3[S5] >>> 0, I3[S5] = k4 % a2 >>> 0, k4 = k4 / a2 >>> 0;
      if (k4 !== 0) throw new Error("Non-zero carry");
      D2 = T4, _4++;
    }
    for (var O5 = L3 - D2; O5 !== L3 && I3[O5] === 0; ) O5++;
    for (var te3 = c5.repeat(m4); O5 < L3; ++O5) te3 += r2.charAt(I3[O5]);
    return te3;
  }
  function y5(u2) {
    if (typeof u2 != "string") throw new TypeError("Expected String");
    if (u2.length === 0) return new Uint8Array();
    var m4 = 0;
    if (u2[m4] !== " ") {
      for (var D2 = 0, _4 = 0; u2[m4] === c5; ) D2++, m4++;
      for (var E4 = (u2.length - m4) * h4 + 1 >>> 0, L3 = new Uint8Array(E4); u2[m4]; ) {
        var I3 = t[u2.charCodeAt(m4)];
        if (I3 === 255) return;
        for (var k4 = 0, T4 = E4 - 1; (I3 !== 0 || k4 < _4) && T4 !== -1; T4--, k4++) I3 += a2 * L3[T4] >>> 0, L3[T4] = I3 % 256 >>> 0, I3 = I3 / 256 >>> 0;
        if (I3 !== 0) throw new Error("Non-zero carry");
        _4 = k4, m4++;
      }
      if (u2[m4] !== " ") {
        for (var S5 = E4 - _4; S5 !== E4 && L3[S5] === 0; ) S5++;
        for (var O5 = new Uint8Array(D2 + (E4 - S5)), te3 = D2; S5 !== E4; ) O5[te3++] = L3[S5++];
        return O5;
      }
    }
  }
  function w3(u2) {
    var m4 = y5(u2);
    if (m4) return m4;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p3, decodeUnsafe: y5, decode: w3 };
}
var hr = cr;
var lr2 = hr;
var ni2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ur2 = (r2) => new TextEncoder().encode(r2);
var dr2 = (r2) => new TextDecoder().decode(r2);
var gr2 = class {
  constructor(e, t, i4) {
    this.name = e, this.prefix = t, this.baseEncode = i4;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var pr2 = class {
  constructor(e, t, i4) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i4;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oi2(this, e);
  }
};
var yr2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oi2(this, e);
  }
  decode(e) {
    const t = e[0], i4 = this.decoders[t];
    if (i4) return i4.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var oi2 = (r2, e) => new yr2({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var br2 = class {
  constructor(e, t, i4, s2) {
    this.name = e, this.prefix = t, this.baseEncode = i4, this.baseDecode = s2, this.encoder = new gr2(e, t, i4), this.decoder = new pr2(e, t, s2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Se = ({ name: r2, prefix: e, encode: t, decode: i4 }) => new br2(r2, e, t, i4);
var me2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i4, decode: s2 } = lr2(t, e);
  return Se({ prefix: r2, name: e, encode: i4, decode: (n3) => ni2(s2(n3)) });
};
var mr2 = (r2, e, t, i4) => {
  const s2 = {};
  for (let l4 = 0; l4 < e.length; ++l4) s2[e[l4]] = l4;
  let n3 = r2.length;
  for (; r2[n3 - 1] === "="; ) --n3;
  const o2 = new Uint8Array(n3 * t / 8 | 0);
  let a2 = 0, c5 = 0, h4 = 0;
  for (let l4 = 0; l4 < n3; ++l4) {
    const p3 = s2[r2[l4]];
    if (p3 === void 0) throw new SyntaxError(`Non-${i4} character`);
    c5 = c5 << t | p3, a2 += t, a2 >= 8 && (a2 -= 8, o2[h4++] = 255 & c5 >> a2);
  }
  if (a2 >= t || 255 & c5 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var fr = (r2, e, t) => {
  const i4 = e[e.length - 1] === "=", s2 = (1 << t) - 1;
  let n3 = "", o2 = 0, a2 = 0;
  for (let c5 = 0; c5 < r2.length; ++c5) for (a2 = a2 << 8 | r2[c5], o2 += 8; o2 > t; ) o2 -= t, n3 += e[s2 & a2 >> o2];
  if (o2 && (n3 += e[s2 & a2 << t - o2]), i4) for (; n3.length * t & 7; ) n3 += "=";
  return n3;
};
var A2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i4 }) => Se({ prefix: e, name: r2, encode(s2) {
  return fr(s2, i4, t);
}, decode(s2) {
  return mr2(s2, i4, t, r2);
} });
var Dr2 = Se({ prefix: "\0", name: "identity", encode: (r2) => dr2(r2), decode: (r2) => ur2(r2) });
var vr = Object.freeze({ __proto__: null, identity: Dr2 });
var wr2 = A2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var _r2 = Object.freeze({ __proto__: null, base2: wr2 });
var Er = A2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Ir2 = Object.freeze({ __proto__: null, base8: Er });
var Tr2 = me2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Cr2 = Object.freeze({ __proto__: null, base10: Tr2 });
var Pr2 = A2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Sr2 = A2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Or2 = Object.freeze({ __proto__: null, base16: Pr2, base16upper: Sr2 });
var Rr2 = A2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ar2 = A2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var xr = A2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Nr2 = A2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var $r2 = A2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var zr2 = A2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Lr2 = A2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var kr2 = A2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var jr2 = A2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Ur2 = Object.freeze({ __proto__: null, base32: Rr2, base32upper: Ar2, base32pad: xr, base32padupper: Nr2, base32hex: $r2, base32hexupper: zr2, base32hexpad: Lr2, base32hexpadupper: kr2, base32z: jr2 });
var Fr2 = me2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Mr2 = me2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Kr2 = Object.freeze({ __proto__: null, base36: Fr2, base36upper: Mr2 });
var Br2 = me2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Vr2 = me2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var qr2 = Object.freeze({ __proto__: null, base58btc: Br2, base58flickr: Vr2 });
var Gr2 = A2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Wr2 = A2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Hr2 = A2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Yr2 = A2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jr2 = Object.freeze({ __proto__: null, base64: Gr2, base64pad: Wr2, base64url: Hr2, base64urlpad: Yr2 });
var ai2 = Array.from("");
var Xr2 = ai2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Zr2 = ai2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Qr2(r2) {
  return r2.reduce((e, t) => (e += Xr2[t], e), "");
}
function en2(r2) {
  const e = [];
  for (const t of r2) {
    const i4 = Zr2[t.codePointAt(0)];
    if (i4 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i4);
  }
  return new Uint8Array(e);
}
var tn = Se({ prefix: "", name: "base256emoji", encode: Qr2, decode: en2 });
var sn2 = Object.freeze({ __proto__: null, base256emoji: tn });
var rn2 = hi;
var ci2 = 128;
var nn = 127;
var on2 = ~nn;
var an2 = Math.pow(2, 31);
function hi(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i4 = t; r2 >= an2; ) e[t++] = r2 & 255 | ci2, r2 /= 128;
  for (; r2 & on2; ) e[t++] = r2 & 255 | ci2, r2 >>>= 7;
  return e[t] = r2 | 0, hi.bytes = t - i4 + 1, e;
}
var cn2 = Ve2;
var hn2 = 128;
var li = 127;
function Ve2(r2, i4) {
  var t = 0, i4 = i4 || 0, s2 = 0, n3 = i4, o2, a2 = r2.length;
  do {
    if (n3 >= a2) throw Ve2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n3++], t += s2 < 28 ? (o2 & li) << s2 : (o2 & li) * Math.pow(2, s2), s2 += 7;
  } while (o2 >= hn2);
  return Ve2.bytes = n3 - i4, t;
}
var ln2 = Math.pow(2, 7);
var un2 = Math.pow(2, 14);
var dn2 = Math.pow(2, 21);
var gn2 = Math.pow(2, 28);
var pn2 = Math.pow(2, 35);
var yn2 = Math.pow(2, 42);
var bn2 = Math.pow(2, 49);
var mn2 = Math.pow(2, 56);
var fn2 = Math.pow(2, 63);
var Dn2 = function(r2) {
  return r2 < ln2 ? 1 : r2 < un2 ? 2 : r2 < dn2 ? 3 : r2 < gn2 ? 4 : r2 < pn2 ? 5 : r2 < yn2 ? 6 : r2 < bn2 ? 7 : r2 < mn2 ? 8 : r2 < fn2 ? 9 : 10;
};
var vn2 = { encode: rn2, decode: cn2, encodingLength: Dn2 };
var ui2 = vn2;
var di2 = (r2, e, t = 0) => (ui2.encode(r2, e, t), e);
var gi = (r2) => ui2.encodingLength(r2);
var qe2 = (r2, e) => {
  const t = e.byteLength, i4 = gi(r2), s2 = i4 + gi(t), n3 = new Uint8Array(s2 + t);
  return di2(r2, n3, 0), di2(t, n3, i4), n3.set(e, s2), new wn2(r2, t, e, n3);
};
var wn2 = class {
  constructor(e, t, i4, s2) {
    this.code = e, this.size = t, this.digest = i4, this.bytes = s2;
  }
};
var pi = ({ name: r2, code: e, encode: t }) => new _n2(r2, e, t);
var _n2 = class {
  constructor(e, t, i4) {
    this.name = e, this.code = t, this.encode = i4;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qe2(this.code, t) : t.then((i4) => qe2(this.code, i4));
    } else throw Error("Unknown type, must be binary type");
  }
};
var yi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var En2 = pi({ name: "sha2-256", code: 18, encode: yi2("SHA-256") });
var In2 = pi({ name: "sha2-512", code: 19, encode: yi2("SHA-512") });
var Tn2 = Object.freeze({ __proto__: null, sha256: En2, sha512: In2 });
var bi2 = 0;
var Cn2 = "identity";
var mi = ni2;
var Pn2 = (r2) => qe2(bi2, mi(r2));
var Sn2 = { code: bi2, name: Cn2, encode: mi, digest: Pn2 };
var On2 = Object.freeze({ __proto__: null, identity: Sn2 });
new TextEncoder(), new TextDecoder();
var fi2 = { ...vr, ..._r2, ...Ir2, ...Cr2, ...Or2, ...Ur2, ...Kr2, ...qr2, ...Jr2, ...sn2 };
({ ...Tn2, ...On2 });
function Di2(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function Rn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Di2(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function vi(r2, e, t, i4) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i4 } };
}
var wi = vi("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Ge2 = vi("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Rn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var An2 = { utf8: wi, "utf-8": wi, hex: fi2.base16, latin1: Ge2, ascii: Ge2, binary: Ge2, ...fi2 };
function xn2(r2, e = "utf8") {
  const t = An2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Di2(globalThis.Buffer.from(r2, "utf-8")) : t.decoder.decode(`${t.prefix}${r2}`);
}
var Nn2 = Object.defineProperty;
var $n2 = (r2, e, t) => e in r2 ? Nn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var J3 = (r2, e, t) => $n2(r2, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, J3(this, "keychain", /* @__PURE__ */ new Map()), J3(this, "name", St2), J3(this, "version", Ot2), J3(this, "initialized", false), J3(this, "storagePrefix", W2), J3(this, "init", async () => {
      if (!this.initialized) {
        const i4 = await this.getKeyChain();
        typeof i4 < "u" && (this.keychain = i4), this.initialized = true;
      }
    }), J3(this, "has", (i4) => (this.isInitialized(), this.keychain.has(i4))), J3(this, "set", async (i4, s2) => {
      this.isInitialized(), this.keychain.set(i4, s2), await this.persist();
    }), J3(this, "get", (i4) => {
      this.isInitialized();
      const s2 = this.keychain.get(i4);
      if (typeof s2 > "u") {
        const { message: n3 } = Bt("NO_MATCHING_KEY", `${this.name}: ${i4}`);
        throw new Error(n3);
      }
      return s2;
    }), J3(this, "del", async (i4) => {
      this.isInitialized(), this.keychain.delete(i4), await this.persist();
    }), this.core = e, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, bi(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? yi(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zn2 = Object.defineProperty;
var Ln2 = (r2, e, t) => e in r2 ? zn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var x3 = (r2, e, t) => Ln2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ei2 = class {
  constructor(e, t, i4) {
    this.core = e, this.logger = t, x3(this, "name", Ct2), x3(this, "keychain"), x3(this, "randomSessionIdentifier", aa()), x3(this, "initialized", false), x3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), x3(this, "hasKeys", (s2) => (this.isInitialized(), this.keychain.has(s2))), x3(this, "getClientId", async () => {
      this.isInitialized();
      const s2 = await this.getClientSeed(), n3 = Po(s2);
      return Qe(n3.publicKey);
    }), x3(this, "generateKeyPair", () => {
      this.isInitialized();
      const s2 = fa();
      return this.setPrivateKey(s2.publicKey, s2.privateKey);
    }), x3(this, "signJWT", async (s2) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), o2 = Po(n3), a2 = this.randomSessionIdentifier, c5 = Pt2;
      return await Qo(a2, s2, c5, o2);
    }), x3(this, "generateSharedKey", (s2, n3, o2) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(s2), c5 = ua(a2, n3);
      return this.setSymKey(c5, o2);
    }), x3(this, "setSymKey", async (s2, n3) => {
      this.isInitialized();
      const o2 = n3 || la(s2);
      return await this.keychain.set(o2, s2), o2;
    }), x3(this, "deleteKeyPair", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), x3(this, "deleteSymKey", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), x3(this, "encode", async (s2, n3, o2) => {
      this.isInitialized();
      const a2 = rs(o2), c5 = safeJsonStringify(n3);
      if (wa(a2)) return ga(c5, o2 == null ? void 0 : o2.encoding);
      if (ma(a2)) {
        const y5 = a2.senderPublicKey, w3 = a2.receiverPublicKey;
        s2 = await this.generateSharedKey(y5, w3);
      }
      const h4 = this.getSymKey(s2), { type: l4, senderPublicKey: p3 } = a2;
      return ha({ type: l4, symKey: h4, message: c5, senderPublicKey: p3, encoding: o2 == null ? void 0 : o2.encoding });
    }), x3(this, "decode", async (s2, n3, o2) => {
      this.isInitialized();
      const a2 = ya(n3, o2);
      if (wa(a2)) {
        const c5 = ba(n3, o2 == null ? void 0 : o2.encoding);
        return safeJsonParse(c5);
      }
      if (ma(a2)) {
        const c5 = a2.receiverPublicKey, h4 = a2.senderPublicKey;
        s2 = await this.generateSharedKey(c5, h4);
      }
      try {
        const c5 = this.getSymKey(s2), h4 = pa({ symKey: c5, encoded: n3, encoding: o2 == null ? void 0 : o2.encoding });
        return safeJsonParse(h4);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${s2}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }), x3(this, "getPayloadType", (s2, n3 = oe) => {
      const o2 = ze({ encoded: s2, encoding: n3 });
      return Zt(o2.type);
    }), x3(this, "getPayloadSenderPublicKey", (s2, n3 = oe) => {
      const o2 = ze({ encoded: s2, encoding: n3 });
      return o2.senderPublicKey ? toString(o2.senderPublicKey, rt) : void 0;
    }), this.core = e, this.logger = E2(t, this.name), this.keychain = i4 || new _i2(this.core, this.logger);
  }
  get context() {
    return y2(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Me2);
    } catch {
      e = aa(), await this.keychain.set(Me2, e);
    }
    return xn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var kn2 = Object.defineProperty;
var jn2 = Object.defineProperties;
var Un2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Fn2 = Object.prototype.hasOwnProperty;
var Mn2 = Object.prototype.propertyIsEnumerable;
var We2 = (r2, e, t) => e in r2 ? kn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Kn2 = (r2, e) => {
  for (var t in e || (e = {})) Fn2.call(e, t) && We2(r2, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Mn2.call(e, t) && We2(r2, t, e[t]);
  return r2;
};
var Bn2 = (r2, e) => jn2(r2, Un2(e));
var K4 = (r2, e, t) => We2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, K4(this, "messages", /* @__PURE__ */ new Map()), K4(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), K4(this, "name", Rt2), K4(this, "version", At2), K4(this, "initialized", false), K4(this, "storagePrefix", W2), K4(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i4 = await this.getRelayerMessages();
          typeof i4 < "u" && (this.messages = i4);
          const s2 = await this.getRelayerMessagesWithoutClientAck();
          typeof s2 < "u" && (this.messagesWithoutClientAck = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i4) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i4);
        } finally {
          this.initialized = true;
        }
      }
    }), K4(this, "set", async (i4, s2, n3) => {
      this.isInitialized();
      const o2 = da(s2);
      let a2 = this.messages.get(i4);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o2] < "u") return o2;
      if (a2[o2] = s2, this.messages.set(i4, a2), n3 === ye2.inbound) {
        const c5 = this.messagesWithoutClientAck.get(i4) || {};
        this.messagesWithoutClientAck.set(i4, Bn2(Kn2({}, c5), { [o2]: s2 }));
      }
      return await this.persist(), o2;
    }), K4(this, "get", (i4) => {
      this.isInitialized();
      let s2 = this.messages.get(i4);
      return typeof s2 > "u" && (s2 = {}), s2;
    }), K4(this, "getWithoutAck", (i4) => {
      this.isInitialized();
      const s2 = {};
      for (const n3 of i4) {
        const o2 = this.messagesWithoutClientAck.get(n3) || {};
        s2[n3] = Object.values(o2);
      }
      return s2;
    }), K4(this, "has", (i4, s2) => {
      this.isInitialized();
      const n3 = this.get(i4), o2 = da(s2);
      return typeof n3[o2] < "u";
    }), K4(this, "ack", async (i4, s2) => {
      this.isInitialized();
      const n3 = this.messagesWithoutClientAck.get(i4);
      if (typeof n3 > "u") return;
      const o2 = da(s2);
      delete n3[o2], Object.keys(n3).length === 0 ? this.messagesWithoutClientAck.delete(i4) : this.messagesWithoutClientAck.set(i4, n3), await this.persist();
    }), K4(this, "del", async (i4) => {
      this.isInitialized(), this.messages.delete(i4), this.messagesWithoutClientAck.delete(i4), await this.persist();
    }), this.logger = E2(e, this.name), this.core = t;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, bi(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, bi(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? yi(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? yi(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Vn2 = Object.defineProperty;
var qn2 = Object.defineProperties;
var Gn2 = Object.getOwnPropertyDescriptors;
var Ci2 = Object.getOwnPropertySymbols;
var Wn2 = Object.prototype.hasOwnProperty;
var Hn2 = Object.prototype.propertyIsEnumerable;
var He2 = (r2, e, t) => e in r2 ? Vn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ce = (r2, e) => {
  for (var t in e || (e = {})) Wn2.call(e, t) && He2(r2, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) Hn2.call(e, t) && He2(r2, t, e[t]);
  return r2;
};
var Pi2 = (r2, e) => qn2(r2, Gn2(e));
var G = (r2, e, t) => He2(r2, typeof e != "symbol" ? e + "" : e, t);
var Yn2 = class extends m2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, G(this, "events", new import_events3.EventEmitter()), G(this, "name", Nt2), G(this, "queue", /* @__PURE__ */ new Map()), G(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), G(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), G(this, "needsTransportRestart", false), G(this, "publish", async (i4, s2, n3) => {
      var o2, a2, c5, h4, l4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i4, message: s2, opts: n3 } });
      const p3 = (n3 == null ? void 0 : n3.ttl) || xt2, y5 = (n3 == null ? void 0 : n3.prompt) || false, w3 = (n3 == null ? void 0 : n3.tag) || 0, u2 = (n3 == null ? void 0 : n3.id) || getBigIntRpcId().toString(), m4 = Ea(xa().protocol), D2 = { id: u2, method: (n3 == null ? void 0 : n3.publishMethod) || m4.publish, params: ce({ topic: i4, message: s2, ttl: p3, prompt: y5, tag: w3, attestation: n3 == null ? void 0 : n3.attestation }, n3 == null ? void 0 : n3.tvf) }, _4 = `Failed to publish payload, please try again. id:${u2} tag:${w3}`;
      try {
        Dt((o2 = D2.params) == null ? void 0 : o2.prompt) && ((a2 = D2.params) == null || delete a2.prompt), Dt((c5 = D2.params) == null ? void 0 : c5.tag) && ((h4 = D2.params) == null || delete h4.tag);
        const E4 = new Promise(async (L3) => {
          const I3 = ({ id: T4 }) => {
            var S5;
            ((S5 = D2.id) == null ? void 0 : S5.toString()) === T4.toString() && (this.removeRequestFromQueue(T4), this.relayer.events.removeListener(C3.publish, I3), L3());
          };
          this.relayer.events.on(C3.publish, I3);
          const k4 = Ei(new Promise((T4, S5) => {
            this.rpcPublish(D2, n3).then(T4).catch((O5) => {
              this.logger.warn(O5, O5 == null ? void 0 : O5.message), S5(O5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${u2} tag:${w3}`);
          try {
            await k4, this.events.removeListener(C3.publish, I3);
          } catch (T4) {
            this.queue.set(u2, { request: D2, opts: n3, attempt: 1 }), this.logger.warn(T4, T4 == null ? void 0 : T4.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: u2, topic: i4, message: s2, opts: n3 } }), await Ei(E4, this.publishTimeout, _4);
      } catch (E4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(E4), (l4 = n3 == null ? void 0 : n3.internal) != null && l4.throwOnFailedPublish) throw E4;
      } finally {
        this.queue.delete(u2);
      }
    }), G(this, "publishCustom", async (i4) => {
      var s2, n3, o2, a2, c5;
      this.logger.debug("Publishing custom payload"), this.logger.trace({ type: "method", method: "publishCustom", params: i4 });
      const { payload: h4, opts: l4 = {} } = i4, { attestation: p3, tvf: y5, publishMethod: w3, prompt: u2, tag: m4, ttl: D2 = import_time2.FIVE_MINUTES } = l4, _4 = l4.id || getBigIntRpcId().toString(), E4 = Ea(xa().protocol), L3 = w3 || E4.publish, I3 = { id: _4, method: L3, params: ce(Pi2(ce({}, h4), { ttl: D2, prompt: u2, tag: m4, attestation: p3 }), y5) }, k4 = `Failed to publish custom payload, please try again. id:${_4} tag:${m4}`;
      try {
        Dt((s2 = I3.params) == null ? void 0 : s2.prompt) && ((n3 = I3.params) == null || delete n3.prompt), Dt((o2 = I3.params) == null ? void 0 : o2.tag) && ((a2 = I3.params) == null || delete a2.tag);
        const T4 = new Promise(async (S5) => {
          const O5 = ({ id: Z2 }) => {
            var _e3;
            ((_e3 = I3.id) == null ? void 0 : _e3.toString()) === Z2.toString() && (this.removeRequestFromQueue(Z2), this.relayer.events.removeListener(C3.publish, O5), S5());
          };
          this.relayer.events.on(C3.publish, O5);
          const te3 = Ei(new Promise((Z2, _e3) => {
            this.rpcPublish(I3, l4).then(Z2).catch((Ee3) => {
              this.logger.warn(Ee3, Ee3 == null ? void 0 : Ee3.message), _e3(Ee3);
            });
          }), this.initialPublishTimeout, `Failed initial custom payload publish, retrying.... method:${L3} id:${_4} tag:${m4}`);
          try {
            await te3, this.events.removeListener(C3.publish, O5);
          } catch (Z2) {
            this.queue.set(_4, { request: I3, opts: l4, attempt: 1 }), this.logger.warn(Z2, Z2 == null ? void 0 : Z2.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: _4, payload: h4, opts: l4 } }), await Ei(T4, this.publishTimeout, k4);
      } catch (T4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(T4), (c5 = l4 == null ? void 0 : l4.internal) != null && c5.throwOnFailedPublish) throw T4;
      } finally {
        this.queue.delete(_4);
      }
    }), G(this, "on", (i4, s2) => {
      this.events.on(i4, s2);
    }), G(this, "once", (i4, s2) => {
      this.events.once(i4, s2);
    }), G(this, "off", (i4, s2) => {
      this.events.off(i4, s2);
    }), G(this, "removeListener", (i4, s2) => {
      this.events.removeListener(i4, s2);
    }), this.relayer = e, this.logger = E2(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y2(this.logger);
  }
  async rpcPublish(e, t) {
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: e });
    const i4 = await this.relayer.request(e);
    return this.relayer.events.emit(C3.publish, ce(ce({}, e), t)), this.logger.debug("Successfully Published Payload"), i4;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      var i4;
      const s2 = e.attempt + 1;
      this.queue.set(t, Pi2(ce({}, e), { attempt: s2 })), this.logger.warn({}, `Publisher: queue->publishing: ${e.request.id}, tag: ${(i4 = e.request.params) == null ? void 0 : i4.tag}, attempt: ${s2}`), await this.rpcPublish(e.request, e.opts), this.logger.warn({}, `Publisher: queue->published: ${e.request.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Jn2 = Object.defineProperty;
var Xn2 = (r2, e, t) => e in r2 ? Jn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var he2 = (r2, e, t) => Xn2(r2, typeof e != "symbol" ? e + "" : e, t);
var Zn2 = class {
  constructor() {
    he2(this, "map", /* @__PURE__ */ new Map()), he2(this, "set", (e, t) => {
      const i4 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i4, t]);
    }), he2(this, "get", (e) => this.map.get(e) || []), he2(this, "exists", (e, t) => this.get(e).includes(t)), he2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i4 = this.get(e);
      if (!this.exists(e, t)) return;
      const s2 = i4.filter((n3) => n3 !== t);
      if (!s2.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s2);
    }), he2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Qn = Object.defineProperty;
var eo2 = Object.defineProperties;
var to2 = Object.getOwnPropertyDescriptors;
var Si2 = Object.getOwnPropertySymbols;
var io2 = Object.prototype.hasOwnProperty;
var so2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r2, e, t) => e in r2 ? Qn(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var fe = (r2, e) => {
  for (var t in e || (e = {})) io2.call(e, t) && Ye2(r2, t, e[t]);
  if (Si2) for (var t of Si2(e)) so2.call(e, t) && Ye2(r2, t, e[t]);
  return r2;
};
var Je2 = (r2, e) => eo2(r2, to2(e));
var f5 = (r2, e, t) => Ye2(r2, typeof e != "symbol" ? e + "" : e, t);
var Oi2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f5(this, "subscriptions", /* @__PURE__ */ new Map()), f5(this, "topicMap", new Zn2()), f5(this, "events", new import_events3.EventEmitter()), f5(this, "name", Mt2), f5(this, "version", Kt2), f5(this, "pending", /* @__PURE__ */ new Map()), f5(this, "cached", []), f5(this, "initialized", false), f5(this, "storagePrefix", W2), f5(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f5(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f5(this, "clientId"), f5(this, "batchSubscribeTopicsLimit", 500), f5(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f5(this, "subscribe", async (i4, s2) => {
      var n3;
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s2 } });
      try {
        const o2 = xa(s2), a2 = { topic: i4, relay: o2, transportType: s2 == null ? void 0 : s2.transportType };
        (n3 = s2 == null ? void 0 : s2.internal) != null && n3.skipSubscribe || this.pending.set(i4, a2);
        const c5 = await this.rpcSubscribe(i4, o2, s2);
        return typeof c5 == "string" && (this.onSubscribe(c5, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s2 } })), c5;
      } catch (o2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(o2), o2;
      }
    }), f5(this, "unsubscribe", async (i4, s2) => {
      this.isInitialized(), typeof (s2 == null ? void 0 : s2.id) < "u" ? await this.unsubscribeById(i4, s2.id, s2) : await this.unsubscribeByTopic(i4, s2);
    }), f5(this, "isSubscribed", (i4) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i4));
    })), f5(this, "isKnownTopic", (i4) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i4) || this.pending.has(i4) || this.cached.some((n3) => n3.topic === i4));
    })), f5(this, "on", (i4, s2) => {
      this.events.on(i4, s2);
    }), f5(this, "once", (i4, s2) => {
      this.events.once(i4, s2);
    }), f5(this, "off", (i4, s2) => {
      this.events.off(i4, s2);
    }), f5(this, "removeListener", (i4, s2) => {
      this.events.removeListener(i4, s2);
    }), f5(this, "start", async () => {
      await this.onConnect();
    }), f5(this, "stop", async () => {
      await this.onDisconnect();
    }), f5(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f5(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i4 = [];
      this.pending.forEach((s2) => {
        i4.push(s2);
      }), await this.batchSubscribe(i4);
    }), f5(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on(U2.created, async (i4) => {
        const s2 = U2.created;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i4 }), await this.persist();
      }), this.events.on(U2.deleted, async (i4) => {
        const s2 = U2.deleted;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i4 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E2(t, this.name), this.clientId = "";
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i4 = false;
    try {
      i4 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i4;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i4 = this.topicMap.get(e);
    await Promise.all(i4.map(async (s2) => await this.unsubscribeById(e, s2, t)));
  }
  async unsubscribeById(e, t, i4) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i4 } });
    try {
      const s2 = xa(i4);
      await this.restartToComplete({ topic: e, id: t, relay: s2 }), await this.rpcUnsubscribe(e, t, s2);
      const n3 = zt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i4 } });
    } catch (s2) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s2), s2;
    }
  }
  async rpcSubscribe(e, t, i4) {
    var s2, n3;
    const o2 = await this.getSubscriptionId(e);
    if ((s2 = i4 == null ? void 0 : i4.internal) != null && s2.skipSubscribe) return o2;
    (!i4 || (i4 == null ? void 0 : i4.transportType) === ee2.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const a2 = { method: Ea(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: a2 });
    const c5 = (n3 = i4 == null ? void 0 : i4.internal) == null ? void 0 : n3.throwOnFailedPublish;
    try {
      if ((i4 == null ? void 0 : i4.transportType) === ee2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(a2).catch((p3) => this.logger.warn(p3));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), o2;
      const h4 = new Promise(async (p3) => {
        const y5 = (w3) => {
          w3.topic === e && (this.events.removeListener(U2.created, y5), p3(w3.id));
        };
        this.events.on(U2.created, y5);
        try {
          const w3 = await Ei(new Promise((u2, m4) => {
            this.relayer.request(a2).catch((D2) => {
              this.logger.warn(D2, D2 == null ? void 0 : D2.message), m4(D2);
            }).then(u2);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(U2.created, y5), p3(w3);
        } catch {
        }
      }), l4 = await Ei(h4, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!l4 && c5) throw new Error(`Subscribing to ${e} failed, please try again`);
      return l4 ? o2 : null;
    } catch (h4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C3.connection_stalled), c5) throw h4;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i4 = { method: Ea(t.protocol).batchSubscribe, params: { topics: e.map((s2) => s2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    try {
      await await Ei(new Promise((s2) => {
        this.relayer.request(i4).catch((n3) => this.logger.warn(n3)).then(s2);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i4 = { method: Ea(t.protocol).batchFetchMessages, params: { topics: e.map((n3) => n3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    let s2;
    try {
      s2 = await await Ei(new Promise((n3, o2) => {
        this.relayer.request(i4).catch((a2) => {
          this.logger.warn(a2), o2(a2);
        }).then(n3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
    return s2;
  }
  rpcUnsubscribe(e, t, i4) {
    const s2 = { method: Ea(i4.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 }), this.relayer.request(s2);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Je2(fe({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, fe({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i4) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i4), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, fe({}, t)), this.topicMap.set(t.topic, e), this.events.emit(U2.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i4 } = Bt("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i4);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i4 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i4.topic, e), this.events.emit(U2.deleted, Je2(fe({}, i4), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(U2.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i4 = 0; i4 < t; i4++) {
        const s2 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s2);
      }
    }
    this.events.emit(U2.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size && !e.every((t) => {
        var i4;
        return t.topic === ((i4 = this.subscriptions.get(t.id)) == null ? void 0 : i4.topic);
      })) {
        const { message: t } = Bt("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Je2(fe({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await Ci((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return da(e + await this.getClientId());
  }
};
var ro = Object.defineProperty;
var Ri2 = Object.getOwnPropertySymbols;
var no = Object.prototype.hasOwnProperty;
var oo = Object.prototype.propertyIsEnumerable;
var Xe2 = (r2, e, t) => e in r2 ? ro(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ai2 = (r2, e) => {
  for (var t in e || (e = {})) no.call(e, t) && Xe2(r2, t, e[t]);
  if (Ri2) for (var t of Ri2(e)) oo.call(e, t) && Xe2(r2, t, e[t]);
  return r2;
};
var g2 = (r2, e, t) => Xe2(r2, typeof e != "symbol" ? e + "" : e, t);
var xi2 = class extends d2 {
  constructor(e) {
    super(e), g2(this, "protocol", "wc"), g2(this, "version", 2), g2(this, "core"), g2(this, "logger"), g2(this, "events", new import_events3.EventEmitter()), g2(this, "provider"), g2(this, "messages"), g2(this, "subscriber"), g2(this, "publisher"), g2(this, "name", Lt2), g2(this, "transportExplicitlyClosed", false), g2(this, "initialized", false), g2(this, "connectionAttemptInProgress", false), g2(this, "relayUrl"), g2(this, "projectId"), g2(this, "packageName"), g2(this, "bundleId"), g2(this, "hasExperiencedNetworkDisruption", false), g2(this, "pingTimeout"), g2(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), g2(this, "reconnectTimeout"), g2(this, "connectPromise"), g2(this, "reconnectInProgress", false), g2(this, "requestsInFlight", []), g2(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), g2(this, "request", async (t) => {
      var i4, s2;
      this.logger.debug("Publishing Request Payload");
      const n3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n3, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - publishing...");
        const o2 = `${n3}:${((s2 = t.params) == null ? void 0 : s2.tag) || ""}`;
        this.requestsInFlight.push(o2);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c5) => c5 !== o2), a2;
      } catch (o2) {
        throw this.logger.debug(`Failed to Publish Request: ${n3}`), o2;
      }
    }), g2(this, "resetPingTimeout", () => {
      rn() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i4, s2, n3;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n3 = (s2 = (i4 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i4.socket) == null ? void 0 : s2.terminate) == null || n3.call(s2);
        } catch (o2) {
          this.logger.warn(o2, o2 == null ? void 0 : o2.message);
        }
      }, this.heartBeatTimeout));
    }), g2(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), g2(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C3.connect);
    }), g2(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), g2(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C3.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), g2(this, "registerProviderListeners", () => {
      this.provider.on(M2.payload, this.onPayloadHandler), this.provider.on(M2.connect, this.onConnectHandler), this.provider.on(M2.disconnect, this.onDisconnectHandler), this.provider.on(M2.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E2(e.logger, this.name) : (0, import_pino2.default)(k2({ level: e.logger || zt2 })), this.messages = new Ti2(this.logger, e.core), this.subscriber = new Oi2(this, this.logger), this.publisher = new Yn2(this, this.logger), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ke2, ci() ? this.packageName = ai() : fi() && (this.bundleId = ai()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e) => this.logger.warn(e, e == null ? void 0 : e.message));
  }
  get context() {
    return y2(this.logger);
  }
  get connected() {
    var e, t, i4;
    return ((i4 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i4;
    return ((i4 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i4.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i4) {
    this.isInitialized(), await this.publisher.publish(e, t, i4), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: ee2.relay }, ye2.outbound);
  }
  async publishCustom(e) {
    this.isInitialized(), await this.publisher.publishCustom(e);
  }
  async subscribe(e, t) {
    var i4, s2, n3;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o2 = typeof ((i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish) > "u" ? true : (s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish;
    let a2 = ((n3 = this.subscriber.topicMap.get(e)) == null ? void 0 : n3[0]) || "", c5;
    const h4 = (l4) => {
      l4.topic === e && (this.subscriber.off(U2.created, h4), c5());
    };
    return await Promise.all([new Promise((l4) => {
      c5 = l4, this.subscriber.on(U2.created, h4);
    }), new Promise(async (l4, p3) => {
      a2 = await this.subscriber.subscribe(e, Ai2({ internal: { throwOnFailedPublish: o2 } }, t)).catch((y5) => {
        o2 && p3(y5);
      }) || a2, l4();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Ei(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i4) => {
      await this.connect(e).then(t).catch(i4).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await fu()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i4, s2) => i4.publishedAt - s2.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i4 of t) try {
      await this.onMessageEvent(i4);
    } catch (s2) {
      this.logger.warn(s2, "Error while processing batch message event: " + (s2 == null ? void 0 : s2.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i4 } = e;
    if (!t.sessionExists) {
      const s2 = Si(import_time2.FIVE_MINUTES), n3 = { topic: i4, expiry: s2, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i4, n3);
    }
    this.events.emit(C3.message, e), await this.recordMessageEvent(e, ye2.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i4, s2) => {
          const n3 = () => {
            s2(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(M2.disconnect, n3), await Ei(new Promise((o2, a2) => {
            this.provider.connect().then(o2).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o2) => {
            s2(o2);
          }).finally(() => {
            this.provider.off(M2.disconnect, n3), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o2, a2) => {
            const c5 = () => {
              s2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(M2.disconnect, c5), await this.subscriber.start().then(o2).catch(a2).finally(() => {
              this.provider.off(M2.disconnect, c5);
            });
          }), this.hasExperiencedNetworkDisruption = false, i4();
        });
      } catch (i4) {
        await this.subscriber.stop();
        const s2 = i4;
        this.logger.warn({}, s2.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i4) => setTimeout(i4, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i4, s2, n3;
    if (rn()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n3 = (s2 = (i4 = this.provider) == null ? void 0 : i4.connection) == null ? void 0 : s2.socket) == null || n3.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o2) {
      this.logger.warn(o2, o2 == null ? void 0 : o2.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(di({ sdkVersion: Pe2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i4, message: s2 } = e;
    await this.messages.set(i4, s2, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i4 } = e;
    if (!i4 || i4.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i4}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s2 = this.messages.has(t, i4);
    return s2 && this.logger.warn(`Ignoring duplicate message: ${i4}`), s2;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(kt2)) return;
      const t = e.params, { topic: i4, message: s2, publishedAt: n3, attestation: o2 } = t.data, a2 = { topic: i4, message: s2, publishedAt: n3, transportType: ee2.relay, attestation: o2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ai2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, ye2.inbound), this.events.emit(C3.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(M2.payload, this.onPayloadHandler), this.provider.off(M2.connect, this.onConnectHandler), this.provider.off(M2.disconnect, this.onDisconnectHandler), this.provider.off(M2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await fu();
    au(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i4) => this.logger.error(i4, i4 == null ? void 0 : i4.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && uu()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C3.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(jt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ao2(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ni2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function $i2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var co2 = "[object RegExp]";
var ho2 = "[object String]";
var lo2 = "[object Number]";
var uo = "[object Boolean]";
var zi2 = "[object Arguments]";
var go2 = "[object Symbol]";
var po2 = "[object Date]";
var yo2 = "[object Map]";
var bo2 = "[object Set]";
var mo2 = "[object Array]";
var fo = "[object Function]";
var Do2 = "[object ArrayBuffer]";
var Ze2 = "[object Object]";
var vo2 = "[object Error]";
var wo2 = "[object DataView]";
var _o2 = "[object Uint8Array]";
var Eo2 = "[object Uint8ClampedArray]";
var Io2 = "[object Uint16Array]";
var To2 = "[object Uint32Array]";
var Co2 = "[object BigUint64Array]";
var Po3 = "[object Int8Array]";
var So2 = "[object Int16Array]";
var Oo2 = "[object Int32Array]";
var Ro2 = "[object BigInt64Array]";
var Ao2 = "[object Float32Array]";
var xo2 = "[object Float64Array]";
function No2() {
}
function Li2(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function $o2(r2, e, t) {
  return De2(r2, e, void 0, void 0, void 0, void 0, t);
}
function De2(r2, e, t, i4, s2, n3, o2) {
  const a2 = o2(r2, e, t, i4, s2, n3);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ve2(r2, e, n3, o2);
  }
  return ve2(r2, e, n3, o2);
}
function ve2(r2, e, t, i4) {
  if (Object.is(r2, e)) return true;
  let s2 = $i2(r2), n3 = $i2(e);
  if (s2 === zi2 && (s2 = Ze2), n3 === zi2 && (n3 = Ze2), s2 !== n3) return false;
  switch (s2) {
    case ho2:
      return r2.toString() === e.toString();
    case lo2: {
      const c5 = r2.valueOf(), h4 = e.valueOf();
      return ao2(c5, h4);
    }
    case uo:
    case po2:
    case go2:
      return Object.is(r2.valueOf(), e.valueOf());
    case co2:
      return r2.source === e.source && r2.flags === e.flags;
    case fo:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o2 = t.get(r2), a2 = t.get(e);
  if (o2 != null && a2 != null) return o2 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (s2) {
      case yo2: {
        if (r2.size !== e.size) return false;
        for (const [c5, h4] of r2.entries()) if (!e.has(c5) || !De2(h4, e.get(c5), c5, r2, e, t, i4)) return false;
        return true;
      }
      case bo2: {
        if (r2.size !== e.size) return false;
        const c5 = Array.from(r2.values()), h4 = Array.from(e.values());
        for (let l4 = 0; l4 < c5.length; l4++) {
          const p3 = c5[l4], y5 = h4.findIndex((w3) => De2(p3, w3, void 0, r2, e, t, i4));
          if (y5 === -1) return false;
          h4.splice(y5, 1);
        }
        return true;
      }
      case mo2:
      case _o2:
      case Eo2:
      case Io2:
      case To2:
      case Co2:
      case Po3:
      case So2:
      case Oo2:
      case Ro2:
      case Ao2:
      case xo2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c5 = 0; c5 < r2.length; c5++) if (!De2(r2[c5], e[c5], c5, r2, e, t, i4)) return false;
        return true;
      }
      case Do2:
        return r2.byteLength !== e.byteLength ? false : ve2(new Uint8Array(r2), new Uint8Array(e), t, i4);
      case wo2:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ve2(new Uint8Array(r2), new Uint8Array(e), t, i4);
      case vo2:
        return r2.name === e.name && r2.message === e.message;
      case Ze2: {
        if (!(ve2(r2.constructor, e.constructor, t, i4) || Li2(r2) && Li2(e))) return false;
        const h4 = [...Object.keys(r2), ...Ni2(r2)], l4 = [...Object.keys(e), ...Ni2(e)];
        if (h4.length !== l4.length) return false;
        for (let p3 = 0; p3 < h4.length; p3++) {
          const y5 = h4[p3], w3 = r2[y5];
          if (!Object.hasOwn(e, y5)) return false;
          const u2 = e[y5];
          if (!De2(w3, u2, y5, r2, e, t, i4)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function zo2(r2, e) {
  return $o2(r2, e, No2);
}
var Lo2 = Object.defineProperty;
var ki2 = Object.getOwnPropertySymbols;
var ko2 = Object.prototype.hasOwnProperty;
var jo2 = Object.prototype.propertyIsEnumerable;
var Qe2 = (r2, e, t) => e in r2 ? Lo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ji2 = (r2, e) => {
  for (var t in e || (e = {})) ko2.call(e, t) && Qe2(r2, t, e[t]);
  if (ki2) for (var t of ki2(e)) jo2.call(e, t) && Qe2(r2, t, e[t]);
  return r2;
};
var F = (r2, e, t) => Qe2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends f4 {
  constructor(e, t, i4, s2 = W2, n3 = void 0) {
    super(e, t, i4, s2), this.core = e, this.logger = t, this.name = i4, F(this, "map", /* @__PURE__ */ new Map()), F(this, "version", Ut2), F(this, "cached", []), F(this, "initialized", false), F(this, "getKey"), F(this, "storagePrefix", W2), F(this, "recentlyDeleted", []), F(this, "recentlyDeletedLimit", 200), F(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
        this.getKey && o2 !== null && !Dt(o2) ? this.map.set(this.getKey(o2), o2) : Fa(o2) ? this.map.set(o2.id, o2) : Za(o2) && this.map.set(o2.topic, o2);
      }), this.cached = [], this.initialized = true);
    }), F(this, "set", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) ? await this.update(o2, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: a2 }), this.map.set(o2, a2), await this.persist());
    }), F(this, "get", (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2))), F(this, "getAll", (o2) => (this.isInitialized(), o2 ? this.values.filter((a2) => Object.keys(o2).every((c5) => zo2(a2[c5], o2[c5]))) : this.values)), F(this, "update", async (o2, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: a2 });
      const c5 = ji2(ji2({}, this.getData(o2)), a2);
      this.map.set(o2, c5), await this.persist();
    }), F(this, "delete", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: a2 }), this.map.delete(o2), this.addToRecentlyDeleted(o2), await this.persist());
    }), this.logger = E2(t, this.name), this.storagePrefix = s2, this.getKey = n3;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s2), new Error(s2);
      }
      const { message: i4 } = Bt("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i4), new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = Bt("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Uo2 = Object.defineProperty;
var Fo2 = (r2, e, t) => e in r2 ? Uo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var d3 = (r2, e, t) => Fo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Fi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, d3(this, "name", Bt2), d3(this, "version", Vt2), d3(this, "events", new import_events3.default()), d3(this, "pairings"), d3(this, "initialized", false), d3(this, "storagePrefix", W2), d3(this, "ignoredPayloadTypes", [ie]), d3(this, "registeredMethods", []), d3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d3(this, "register", ({ methods: i4 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i4])];
    }), d3(this, "create", async (i4) => {
      this.isInitialized();
      const s2 = aa(), n3 = await this.core.crypto.setSymKey(s2), o2 = Si(import_time2.FIVE_MINUTES), a2 = { protocol: $t2 }, c5 = { topic: n3, expiry: o2, relay: a2, active: false, methods: i4 == null ? void 0 : i4.methods }, h4 = _a({ protocol: this.core.protocol, version: this.core.version, topic: n3, symKey: s2, relay: a2, expiryTimestamp: o2, methods: i4 == null ? void 0 : i4.methods });
      return this.events.emit(ae2.create, c5), this.core.expirer.set(n3, o2), await this.pairings.set(n3, c5), await this.core.relayer.subscribe(n3, { transportType: i4 == null ? void 0 : i4.transportType, internal: i4 == null ? void 0 : i4.internal }), { topic: n3, uri: h4 };
    }), d3(this, "pair", async (i4) => {
      this.isInitialized();
      const s2 = this.core.eventClient.createEvent({ properties: { topic: i4 == null ? void 0 : i4.uri, trace: [Y.pairing_started] } });
      this.isValidPair(i4, s2);
      const { topic: n3, symKey: o2, relay: a2, expiryTimestamp: c5, methods: h4 } = Ua(i4.uri);
      s2.props.properties.topic = n3, s2.addTrace(Y.pairing_uri_validation_success), s2.addTrace(Y.pairing_uri_not_expired);
      let l4;
      if (this.pairings.keys.includes(n3)) {
        if (l4 = this.pairings.get(n3), s2.addTrace(Y.existing_pairing), l4.active) throw s2.setError(X2.active_pairing_already_exists), new Error(`Pairing already exists: ${n3}. Please try again with a new connection URI.`);
        s2.addTrace(Y.pairing_not_expired);
      }
      const p3 = c5 || Si(import_time2.FIVE_MINUTES), y5 = { topic: n3, relay: a2, expiry: p3, active: false, methods: h4 };
      this.core.expirer.set(n3, p3), await this.pairings.set(n3, y5), s2.addTrace(Y.store_new_pairing), i4.activatePairing && await this.activate({ topic: n3 }), this.events.emit(ae2.create, y5), s2.addTrace(Y.emit_inactive_pairing), this.core.crypto.keychain.has(n3) || await this.core.crypto.setSymKey(o2, n3), s2.addTrace(Y.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s2.setError(X2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n3, { relay: a2 });
      } catch (w3) {
        throw s2.setError(X2.subscribe_pairing_topic_failure), w3;
      }
      return s2.addTrace(Y.subscribe_pairing_topic_success), y5;
    }), d3(this, "activate", async ({ topic: i4 }) => {
      this.isInitialized();
      const s2 = Si(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i4, s2), await this.pairings.update(i4, { active: true, expiry: s2 });
    }), d3(this, "ping", async (i4) => {
      this.isInitialized(), await this.isValidPing(i4), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s2 } = i4;
      if (this.pairings.keys.includes(s2)) {
        const n3 = await this.sendRequest(s2, "wc_pairingPing", {}), { done: o2, resolve: a2, reject: c5 } = xi();
        this.events.once(Ni("pairing_ping", n3), ({ error: h4 }) => {
          h4 ? c5(h4) : a2();
        }), await o2();
      }
    }), d3(this, "updateExpiry", async ({ topic: i4, expiry: s2 }) => {
      this.isInitialized(), await this.pairings.update(i4, { expiry: s2 });
    }), d3(this, "updateMetadata", async ({ topic: i4, metadata: s2 }) => {
      this.isInitialized(), await this.pairings.update(i4, { peerMetadata: s2 });
    }), d3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d3(this, "disconnect", async (i4) => {
      this.isInitialized(), await this.isValidDisconnect(i4);
      const { topic: s2 } = i4;
      this.pairings.keys.includes(s2) && (await this.sendRequest(s2, "wc_pairingDelete", zt("USER_DISCONNECTED")), await this.deletePairing(s2));
    }), d3(this, "formatUriFromPairing", (i4) => {
      this.isInitialized();
      const { topic: s2, relay: n3, expiry: o2, methods: a2 } = i4, c5 = this.core.crypto.keychain.get(s2);
      return _a({ protocol: this.core.protocol, version: this.core.version, topic: s2, symKey: c5, relay: n3, expiryTimestamp: o2, methods: a2 });
    }), d3(this, "sendRequest", async (i4, s2, n3) => {
      const o2 = formatJsonRpcRequest(s2, n3), a2 = await this.core.crypto.encode(i4, o2), c5 = oe2[s2].req;
      return this.core.history.set(i4, o2), this.core.relayer.publish(i4, a2, c5), o2.id;
    }), d3(this, "sendResult", async (i4, s2, n3) => {
      const o2 = formatJsonRpcResult(i4, n3), a2 = await this.core.crypto.encode(s2, o2), c5 = (await this.core.history.get(s2, i4)).request.method, h4 = oe2[c5].res;
      await this.core.relayer.publish(s2, a2, h4), await this.core.history.resolve(o2);
    }), d3(this, "sendError", async (i4, s2, n3) => {
      const o2 = formatJsonRpcError(i4, n3), a2 = await this.core.crypto.encode(s2, o2), c5 = (await this.core.history.get(s2, i4)).request.method, h4 = oe2[c5] ? oe2[c5].res : oe2.unregistered_method.res;
      await this.core.relayer.publish(s2, a2, h4), await this.core.history.resolve(o2);
    }), d3(this, "deletePairing", async (i4, s2) => {
      await this.core.relayer.unsubscribe(i4), await Promise.all([this.pairings.delete(i4, zt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i4), s2 ? Promise.resolve() : this.core.expirer.del(i4)]);
    }), d3(this, "cleanup", async () => {
      const i4 = this.pairings.getAll().filter((s2) => Oi(s2.expiry));
      await Promise.all(i4.map((s2) => this.deletePairing(s2.topic)));
    }), d3(this, "onRelayEventRequest", async (i4) => {
      const { topic: s2, payload: n3 } = i4;
      switch (n3.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s2, n3);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s2, n3);
        default:
          return await this.onUnknownRpcMethodRequest(s2, n3);
      }
    }), d3(this, "onRelayEventResponse", async (i4) => {
      const { topic: s2, payload: n3 } = i4, o2 = (await this.core.history.get(s2, n3.id)).request.method;
      switch (o2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s2, n3);
        default:
          return this.onUnknownRpcMethodResponse(o2);
      }
    }), d3(this, "onPairingPingRequest", async (i4, s2) => {
      const { id: n3 } = s2;
      try {
        this.isValidPing({ topic: i4 }), await this.sendResult(n3, i4, true), this.events.emit(ae2.ping, { id: n3, topic: i4 });
      } catch (o2) {
        await this.sendError(n3, i4, o2), this.logger.error(o2);
      }
    }), d3(this, "onPairingPingResponse", (i4, s2) => {
      const { id: n3 } = s2;
      setTimeout(() => {
        isJsonRpcResult(s2) ? this.events.emit(Ni("pairing_ping", n3), {}) : isJsonRpcError(s2) && this.events.emit(Ni("pairing_ping", n3), { error: s2.error });
      }, 500);
    }), d3(this, "onPairingDeleteRequest", async (i4, s2) => {
      const { id: n3 } = s2;
      try {
        this.isValidDisconnect({ topic: i4 }), await this.deletePairing(i4), this.events.emit(ae2.delete, { id: n3, topic: i4 });
      } catch (o2) {
        await this.sendError(n3, i4, o2), this.logger.error(o2);
      }
    }), d3(this, "onUnknownRpcMethodRequest", async (i4, s2) => {
      const { id: n3, method: o2 } = s2;
      try {
        if (this.registeredMethods.includes(o2)) return;
        const a2 = zt("WC_METHOD_UNSUPPORTED", o2);
        await this.sendError(n3, i4, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n3, i4, a2), this.logger.error(a2);
      }
    }), d3(this, "onUnknownRpcMethodResponse", (i4) => {
      this.registeredMethods.includes(i4) || this.logger.error(zt("WC_METHOD_UNSUPPORTED", i4));
    }), d3(this, "isValidPair", (i4, s2) => {
      var n3;
      if (!Xa(i4)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `pair() params: ${i4}`);
        throw s2.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (!qa(i4.uri)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `pair() uri: ${i4.uri}`);
        throw s2.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      const o2 = Ua(i4 == null ? void 0 : i4.uri);
      if (!((n3 = o2 == null ? void 0 : o2.relay) != null && n3.protocol)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s2.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (!(o2 != null && o2.symKey)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s2.setError(X2.malformed_pairing_uri), new Error(a2);
      }
      if (o2 != null && o2.expiryTimestamp && (0, import_time2.toMiliseconds)(o2 == null ? void 0 : o2.expiryTimestamp) < Date.now()) {
        s2.setError(X2.pairing_expired);
        const { message: a2 } = Bt("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), d3(this, "isValidPing", async (i4) => {
      if (!Xa(i4)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `ping() params: ${i4}`);
        throw new Error(n3);
      }
      const { topic: s2 } = i4;
      await this.isValidPairingTopic(s2);
    }), d3(this, "isValidDisconnect", async (i4) => {
      if (!Xa(i4)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `disconnect() params: ${i4}`);
        throw new Error(n3);
      }
      const { topic: s2 } = i4;
      await this.isValidPairingTopic(s2);
    }), d3(this, "isValidPairingTopic", async (i4) => {
      if (!ft(i4, false)) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `pairing topic should be a string: ${i4}`);
        throw new Error(s2);
      }
      if (!this.pairings.keys.includes(i4)) {
        const { message: s2 } = Bt("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i4}`);
        throw new Error(s2);
      }
      if (Oi(this.pairings.get(i4).expiry)) {
        await this.deletePairing(i4);
        const { message: s2 } = Bt("EXPIRED", `pairing topic: ${i4}`);
        throw new Error(s2);
      }
    }), this.core = e, this.logger = E2(t, this.name), this.pairings = new Ui2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C3.message, async (e) => {
      const { topic: t, message: i4, transportType: s2 } = e;
      if (this.pairings.keys.includes(t) && s2 !== ee2.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i4))) try {
        const n3 = await this.core.crypto.decode(t, i4);
        isJsonRpcRequest(n3) ? (this.core.history.set(t, n3), await this.onRelayEventRequest({ topic: t, payload: n3 })) : isJsonRpcResponse(n3) && (await this.core.history.resolve(n3), await this.onRelayEventResponse({ topic: t, payload: n3 }), this.core.history.delete(t, n3.id)), await this.core.relayer.messages.ack(t, i4);
      } catch (n3) {
        this.logger.error(n3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(q.expired, async (e) => {
      const { topic: t } = Ii(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(ae2.expire, { topic: t }));
    });
  }
};
var Mo2 = Object.defineProperty;
var Ko2 = (r2, e, t) => e in r2 ? Mo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var N2 = (r2, e, t) => Ko2(r2, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends I2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, N2(this, "records", /* @__PURE__ */ new Map()), N2(this, "events", new import_events3.EventEmitter()), N2(this, "name", qt2), N2(this, "version", Gt2), N2(this, "cached", []), N2(this, "initialized", false), N2(this, "storagePrefix", W2), N2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.records.set(i4.id, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), N2(this, "set", (i4, s2, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i4, request: s2, chainId: n3 }), this.records.has(s2.id)) return;
      const o2 = { id: s2.id, topic: i4, request: { method: s2.method, params: s2.params || null }, chainId: n3, expiry: Si(import_time2.THIRTY_DAYS) };
      this.records.set(o2.id, o2), this.persist(), this.events.emit(V2.created, o2);
    }), N2(this, "resolve", async (i4) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i4 }), !this.records.has(i4.id)) return;
      const s2 = await this.getRecord(i4.id);
      typeof s2.response > "u" && (s2.response = isJsonRpcError(i4) ? { error: i4.error } : { result: i4.result }, this.records.set(s2.id, s2), this.persist(), this.events.emit(V2.updated, s2));
    }), N2(this, "get", async (i4, s2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i4, id: s2 }), await this.getRecord(s2))), N2(this, "delete", (i4, s2) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s2 }), this.values.forEach((n3) => {
        if (n3.topic === i4) {
          if (typeof s2 < "u" && n3.id !== s2) return;
          this.records.delete(n3.id), this.events.emit(V2.deleted, n3);
        }
      }), this.persist();
    }), N2(this, "exists", async (i4, s2) => (this.isInitialized(), this.records.has(s2) ? (await this.getRecord(s2)).topic === i4 : false)), N2(this, "on", (i4, s2) => {
      this.events.on(i4, s2);
    }), N2(this, "once", (i4, s2) => {
      this.events.once(i4, s2);
    }), N2(this, "off", (i4, s2) => {
      this.events.off(i4, s2);
    }), N2(this, "removeListener", (i4, s2) => {
      this.events.removeListener(i4, s2);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i4 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i4);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i4 } = Bt("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i4);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(V2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = Bt("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(V2.created, (e) => {
      const t = V2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(V2.updated, (e) => {
      const t = V2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(V2.deleted, (e) => {
      const t = V2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(V2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Bo2 = Object.defineProperty;
var Vo2 = (r2, e, t) => e in r2 ? Bo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var z4 = (r2, e, t) => Vo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ki2 = class extends S2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, z4(this, "expirations", /* @__PURE__ */ new Map()), z4(this, "events", new import_events3.EventEmitter()), z4(this, "name", Wt2), z4(this, "version", Ht2), z4(this, "cached", []), z4(this, "initialized", false), z4(this, "storagePrefix", W2), z4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.expirations.set(i4.target, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), z4(this, "has", (i4) => {
      try {
        const s2 = this.formatTarget(i4);
        return typeof this.getExpiration(s2) < "u";
      } catch {
        return false;
      }
    }), z4(this, "set", (i4, s2) => {
      this.isInitialized();
      const n3 = this.formatTarget(i4), o2 = { target: n3, expiry: s2 };
      this.expirations.set(n3, o2), this.checkExpiry(n3, o2), this.events.emit(q.created, { target: n3, expiration: o2 });
    }), z4(this, "get", (i4) => {
      this.isInitialized();
      const s2 = this.formatTarget(i4);
      return this.getExpiration(s2);
    }), z4(this, "del", (i4) => {
      if (this.isInitialized(), this.has(i4)) {
        const s2 = this.formatTarget(i4), n3 = this.getExpiration(s2);
        this.expirations.delete(s2), this.events.emit(q.deleted, { target: s2, expiration: n3 });
      }
    }), z4(this, "on", (i4, s2) => {
      this.events.on(i4, s2);
    }), z4(this, "once", (i4, s2) => {
      this.events.once(i4, s2);
    }), z4(this, "off", (i4, s2) => {
      this.events.off(i4, s2);
    }), z4(this, "removeListener", (i4, s2) => {
      this.events.removeListener(i4, s2);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Bi(e);
    if (typeof e == "number") return Ai(e);
    const { message: t } = Bt("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(q.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = Bt("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i4 } = Bt("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i4), new Error(i4);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i4 } = t;
    (0, import_time2.toMiliseconds)(i4) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(q.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(q.created, (e) => {
      const t = q.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(q.expired, (e) => {
      const t = q.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(q.deleted, (e) => {
      const t = q.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var qo2 = Object.defineProperty;
var Go2 = (r2, e, t) => e in r2 ? qo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var P2 = (r2, e, t) => Go2(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends M {
  constructor(e, t, i4) {
    super(e, t, i4), this.core = e, this.logger = t, this.store = i4, P2(this, "name", Yt), P2(this, "abortController"), P2(this, "isDevEnv"), P2(this, "verifyUrlV3", Xt2), P2(this, "storagePrefix", W2), P2(this, "version", Fe2), P2(this, "publicKey"), P2(this, "fetchPromise"), P2(this, "init", async () => {
      var s2;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s2 = this.publicKey) == null ? void 0 : s2.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), P2(this, "register", async (s2) => {
      if (!Wt() || this.isDevEnv) return;
      const n3 = window.location.origin, { id: o2, decryptedId: a2 } = s2, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n3}&id=${o2}&decryptedId=${a2}`;
      try {
        const h4 = (0, import_window_getters2.getDocument)(), l4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), p3 = await new Promise((y5, w3) => {
          const u2 = () => {
            window.removeEventListener("message", D2), h4.body.removeChild(m4), w3("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u2);
          const m4 = h4.createElement("iframe");
          m4.src = c5, m4.style.display = "none", m4.addEventListener("error", u2, { signal: this.abortController.signal });
          const D2 = (_4) => {
            if (_4.data && typeof _4.data == "string") try {
              const E4 = JSON.parse(_4.data);
              if (E4.type === "verify_attestation") {
                if (sn(E4.attestation).payload.id !== o2) return;
                clearInterval(l4), h4.body.removeChild(m4), this.abortController.signal.removeEventListener("abort", u2), window.removeEventListener("message", D2), y5(E4.attestation === null ? "" : E4.attestation);
              }
            } catch (E4) {
              this.logger.warn(E4);
            }
          };
          h4.body.appendChild(m4), window.addEventListener("message", D2, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p3), p3;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }), P2(this, "resolve", async (s2) => {
      if (this.isDevEnv) return "";
      const { attestationId: n3, hash: o2, encryptedId: a2 } = s2;
      if (n3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n3) {
        if (sn(n3).payload.id !== a2) return;
        const h4 = await this.isValidJwtAttestation(n3);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!o2) return;
      const c5 = this.getVerifyUrl(s2 == null ? void 0 : s2.verifyUrl);
      return this.fetchAttestation(o2, c5);
    }), P2(this, "fetchAttestation", async (s2, n3) => {
      this.logger.debug(`resolving attestation: ${s2} from url: ${n3}`);
      const o2 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a2 = await fetch(`${n3}/attestation/${s2}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o2), a2.status === 200 ? await a2.json() : void 0;
    }), P2(this, "getVerifyUrl", (s2) => {
      let n3 = s2 || be2;
      return Zt2.includes(n3) || (this.logger.info(`verify url: ${n3}, not included in trusted list, assigning default: ${be2}`), n3 = be2), n3;
    }), P2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s2 = this.startAbortTimer(import_time2.FIVE_SECONDS), n3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s2), await n3.json();
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), P2(this, "persistPublicKey", async (s2) => {
      this.logger.debug("persisting public key to local storage", s2), await this.store.setItem(this.storeKey, s2), this.publicKey = s2;
    }), P2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), P2(this, "isValidJwtAttestation", async (s2) => {
      const n3 = await this.getPublicKey();
      try {
        if (n3) return this.validateAttestation(s2, n3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o2 = await this.fetchAndPersistPublicKey();
      try {
        if (o2) return this.validateAttestation(s2, o2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), P2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), P2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n3) => {
        const o2 = await this.fetchPublicKey();
        o2 && (await this.persistPublicKey(o2), n3(o2));
      });
      const s2 = await this.fetchPromise;
      return this.fetchPromise = void 0, s2;
    }), P2(this, "validateAttestation", (s2, n3) => {
      const o2 = va(s2, n3.publicKey), a2 = { hasExpired: (0, import_time2.toMiliseconds)(o2.exp) < Date.now(), payload: o2 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E2(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Ti(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y2(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Wo2 = Object.defineProperty;
var Ho2 = (r2, e, t) => e in r2 ? Wo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Vi2 = (r2, e, t) => Ho2(r2, typeof e != "symbol" ? e + "" : e, t);
var qi2 = class extends O3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Vi2(this, "context", Qt2), Vi2(this, "registerDeviceToken", async (i4) => {
      const { clientId: s2, token: n3, notificationType: o2, enableEncrypted: a2 = false } = i4, c5 = `${ei2}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s2, type: o2, token: n3, always_raw: a2 }) });
    }), this.logger = E2(t, this.context);
  }
};
var Yo2 = Object.defineProperty;
var Gi2 = Object.getOwnPropertySymbols;
var Jo2 = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var et2 = (r2, e, t) => e in r2 ? Yo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var we2 = (r2, e) => {
  for (var t in e || (e = {})) Jo2.call(e, t) && et2(r2, t, e[t]);
  if (Gi2) for (var t of Gi2(e)) Xo2.call(e, t) && et2(r2, t, e[t]);
  return r2;
};
var R2 = (r2, e, t) => et2(r2, typeof e != "symbol" ? e + "" : e, t);
var Wi2 = class extends R {
  constructor(e, t, i4 = true) {
    super(e, t, i4), this.core = e, this.logger = t, R2(this, "context", ii), R2(this, "storagePrefix", W2), R2(this, "storageVersion", ti2), R2(this, "events", /* @__PURE__ */ new Map()), R2(this, "shouldPersist", false), R2(this, "init", async () => {
      if (!Ti()) try {
        const s2 = { eventId: $i(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: wr(this.core.relayer.protocol, this.core.relayer.version, Pe2) } } };
        await this.sendEvent([s2]);
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), R2(this, "createEvent", (s2) => {
      const { event: n3 = "ERROR", type: o2 = "", properties: { topic: a2, trace: c5 } } = s2, h4 = $i(), l4 = this.core.projectId || "", p3 = Date.now(), y5 = we2({ eventId: h4, timestamp: p3, props: { event: n3, type: o2, properties: { topic: a2, trace: c5 } }, bundleId: l4, domain: this.getAppDomain() }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, y5), this.shouldPersist = true), y5;
    }), R2(this, "getEvent", (s2) => {
      const { eventId: n3, topic: o2 } = s2;
      if (n3) return this.events.get(n3);
      const a2 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === o2);
      if (a2) return we2(we2({}, a2), this.setMethods(a2.eventId));
    }), R2(this, "deleteEvent", (s2) => {
      const { eventId: n3 } = s2;
      this.events.delete(n3), this.shouldPersist = true;
    }), R2(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s2) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s2.timestamp) > si && (this.events.delete(s2.eventId), this.shouldPersist = true);
        });
      });
    }), R2(this, "setMethods", (s2) => ({ addTrace: (n3) => this.addTrace(s2, n3), setError: (n3) => this.setError(s2, n3) })), R2(this, "addTrace", (s2, n3) => {
      const o2 = this.events.get(s2);
      o2 && (o2.props.properties.trace.push(n3), this.events.set(s2, o2), this.shouldPersist = true);
    }), R2(this, "setError", (s2, n3) => {
      const o2 = this.events.get(s2);
      o2 && (o2.props.type = n3, o2.timestamp = Date.now(), this.events.set(s2, o2), this.shouldPersist = true);
    }), R2(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), R2(this, "restore", async () => {
      try {
        const s2 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s2.length) return;
        s2.forEach((n3) => {
          this.events.set(n3.eventId, we2(we2({}, n3), this.setMethods(n3.eventId)));
        });
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), R2(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s2 = [];
      for (const [n3, o2] of this.events) o2.props.type && s2.push(o2);
      if (s2.length !== 0) try {
        if ((await this.sendEvent(s2)).ok) for (const n3 of s2) this.events.delete(n3.eventId), this.shouldPersist = true;
      } catch (n3) {
        this.logger.warn(n3);
      }
    }), R2(this, "sendEvent", async (s2) => {
      const n3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ri2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Pe2}${n3}`, { method: "POST", body: JSON.stringify(s2) });
    }), R2(this, "getAppDomain", () => br().url), this.logger = E2(t, this.context), this.telemetryEnabled = i4, i4 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Zo2 = Object.defineProperty;
var Hi2 = Object.getOwnPropertySymbols;
var Qo3 = Object.prototype.hasOwnProperty;
var ea2 = Object.prototype.propertyIsEnumerable;
var tt2 = (r2, e, t) => e in r2 ? Zo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Yi2 = (r2, e) => {
  for (var t in e || (e = {})) Qo3.call(e, t) && tt2(r2, t, e[t]);
  if (Hi2) for (var t of Hi2(e)) ea2.call(e, t) && tt2(r2, t, e[t]);
  return r2;
};
var v3 = (r2, e, t) => tt2(r2, typeof e != "symbol" ? e + "" : e, t);
var Oe2 = class _Oe extends h3 {
  constructor(e) {
    var t;
    super(e), v3(this, "protocol", Ue2), v3(this, "version", Fe2), v3(this, "name", pe2), v3(this, "relayUrl"), v3(this, "projectId"), v3(this, "customStoragePrefix"), v3(this, "events", new import_events3.EventEmitter()), v3(this, "logger"), v3(this, "heartbeat"), v3(this, "relayer"), v3(this, "crypto"), v3(this, "storage"), v3(this, "history"), v3(this, "expirer"), v3(this, "pairing"), v3(this, "verify"), v3(this, "echoClient"), v3(this, "linkModeSupportedApps"), v3(this, "eventClient"), v3(this, "initialized", false), v3(this, "logChunkController"), v3(this, "on", (a2, c5) => this.events.on(a2, c5)), v3(this, "once", (a2, c5) => this.events.once(a2, c5)), v3(this, "off", (a2, c5) => this.events.off(a2, c5)), v3(this, "removeListener", (a2, c5) => this.events.removeListener(a2, c5)), v3(this, "dispatchEnvelope", ({ topic: a2, message: c5, sessionExists: h4 }) => {
      if (!a2 || !c5) return;
      const l4 = { topic: a2, message: c5, publishedAt: Date.now(), transportType: ee2.link_mode };
      this.relayer.onLinkMessageEvent(l4, { sessionExists: h4 });
    });
    const i4 = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (i4) try {
      return this.customStoragePrefix = i4.customStoragePrefix, this.logger = i4.logger, this.heartbeat = i4.heartbeat, this.crypto = i4.crypto, this.history = i4.history, this.expirer = i4.expirer, this.storage = i4.storage, this.relayer = i4.relayer, this.pairing = i4.pairing, this.verify = i4.verify, this.echoClient = i4.echoClient, this.linkModeSupportedApps = i4.linkModeSupportedApps, this.eventClient = i4.eventClient, this.initialized = i4.initialized, this.logChunkController = i4.logChunkController, i4;
    } catch (a2) {
      console.warn("Failed to copy global core", a2);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ke2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k2({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : It2.logger, name: pe2 }), { logger: n3, chunkLoggerController: o2 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a2, c5;
      (a2 = this.logChunkController) != null && a2.downloadLogsBlobInBrowser && ((c5 = this.logChunkController) == null || c5.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E2(n3, this.name), this.heartbeat = new i(), this.crypto = new Ei2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new Mi2(this, this.logger), this.expirer = new Ki2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Yi2(Yi2({}, Tt2), e == null ? void 0 : e.storageOptions)), this.relayer = new xi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Fi2(this, this.logger), this.verify = new Bi2(this, this.logger, this.storage), this.echoClient = new qi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Wi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Oe(e);
    await t.initialize();
    const i4 = await t.crypto.getClientId();
    return await t.storage.setItem(Ft2, i4), t;
  }
  get context() {
    return y2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Be2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Be2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i4 = `${t}_count`;
      return globalThis[i4] = (globalThis[i4] || 0) + 1, globalThis[i4] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i4]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i4 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i4] = e;
    } catch (i4) {
      console.warn("Failed to set global WalletConnect core", i4);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var ta2 = Oe2;

// node_modules/@reown/appkit/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var Ve3 = "wc";
var ke2 = 2;
var De3 = "client";
var we3 = `${Ve3}@${ke2}:${De3}:`;
var me3 = { name: De3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var dt2 = "proposal";
var Me3 = "Proposal expired";
var ut2 = "session";
var B2 = import_time3.SEVEN_DAYS;
var gt2 = "engine";
var P3 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e2 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var M3 = { idle: "IDLE", active: "ACTIVE" };
var yt2 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var wt2 = "request";
var mt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var _t2 = "wc";
var ft2 = "auth";
var St3 = "authKeys";
var Et2 = "pairingTopics";
var Rt3 = "requests";
var le2 = `${_t2}@${1.5}:${ft2}:`;
var pe3 = `${le2}:PUB_KEY`;
var bs2 = Object.defineProperty;
var As2 = Object.defineProperties;
var xs2 = Object.getOwnPropertyDescriptors;
var vt2 = Object.getOwnPropertySymbols;
var Cs2 = Object.prototype.hasOwnProperty;
var Vs = Object.prototype.propertyIsEnumerable;
var $e2 = (S5, o2, t) => o2 in S5 ? bs2(S5, o2, { enumerable: true, configurable: true, writable: true, value: t }) : S5[o2] = t;
var R3 = (S5, o2) => {
  for (var t in o2 || (o2 = {})) Cs2.call(o2, t) && $e2(S5, t, o2[t]);
  if (vt2) for (var t of vt2(o2)) Vs.call(o2, t) && $e2(S5, t, o2[t]);
  return S5;
};
var O4 = (S5, o2) => As2(S5, xs2(o2));
var c4 = (S5, o2, t) => $e2(S5, typeof o2 != "symbol" ? o2 + "" : o2, t);
var ks2 = class extends V {
  constructor(o2) {
    super(o2), c4(this, "name", gt2), c4(this, "events", new import_events4.default()), c4(this, "initialized", false), c4(this, "requestQueue", { state: M3.idle, queue: [] }), c4(this, "sessionRequestQueue", { state: M3.idle, queue: [] }), c4(this, "emittedSessionRequests", new ji({ limit: 500 })), c4(this, "requestQueueDelay", import_time3.ONE_SECOND), c4(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c4(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c4(this, "recentlyDeletedLimit", 200), c4(this, "relayMessageCache", []), c4(this, "pendingSessions", /* @__PURE__ */ new Map()), c4(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(P3) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c4(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e = O4(R3({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(e), e.optionalNamespaces = Ma(e.requiredNamespaces, e.optionalNamespaces), e.requiredNamespaces = {};
      const { pairingTopic: s2, requiredNamespaces: i4, optionalNamespaces: r2, sessionProperties: n3, scopedProperties: a2, relays: l4 } = e;
      let p3 = s2, h4, u2 = false;
      try {
        if (p3) {
          const T4 = this.client.core.pairing.pairings.get(p3);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u2 = T4.active;
        }
      } catch (T4) {
        throw this.client.logger.error(`connect() -> pairing.get(${p3}) failed`), T4;
      }
      if (!p3 || !u2) {
        const { topic: T4, uri: $3 } = await this.client.core.pairing.create({ internal: { skipSubscribe: true } });
        p3 = T4, h4 = $3;
      }
      if (!p3) {
        const { message: T4 } = Bt("NO_MATCHING_KEY", `connect() pairing topic: ${p3}`);
        throw new Error(T4);
      }
      const d5 = await this.client.core.crypto.generateKeyPair(), y5 = P3.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, w3 = Si(y5), m4 = O4(R3(R3({ requiredNamespaces: i4, optionalNamespaces: r2, relays: l4 ?? [{ protocol: $t2 }], proposer: { publicKey: d5, metadata: this.client.metadata }, expiryTimestamp: w3, pairingTopic: p3 }, n3 && { sessionProperties: n3 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), E4 = Ni("session_connect", m4.id), { reject: _4, resolve: b4, done: V3 } = xi(y5, Me3), I3 = ({ id: T4 }) => {
        T4 === m4.id && (this.client.events.off("proposal_expire", I3), this.pendingSessions.delete(m4.id), this.events.emit(E4, { error: { message: Me3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I3), this.events.once(E4, ({ error: T4, session: $3 }) => {
        this.client.events.off("proposal_expire", I3), T4 ? _4(T4) : $3 && b4($3);
      }), await this.sendProposeSession({ proposal: m4, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: m4.id } } }), await this.setProposal(m4.id, m4), { uri: h4, approval: V3 };
    }), c4(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (e) {
        throw this.client.logger.error("pair() failed"), e;
      }
    }), c4(this, "approve", async (t) => {
      var e, s2, i4;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (e = t == null ? void 0 : t.id) == null ? void 0 : e.toString(), trace: [rr2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N4) {
        throw r2.setError(nr2.no_internet_connection), N4;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch (N4) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), r2.setError(nr2.proposal_not_found), N4;
      }
      try {
        await this.isValidApprove(t);
      } catch (N4) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(nr2.session_approve_namespace_validation_failure), N4;
      }
      const { id: n3, relayProtocol: a2, namespaces: l4, sessionProperties: p3, scopedProperties: h4, sessionConfig: u2 } = t, d5 = this.client.proposal.get(n3);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: y5, proposer: w3, requiredNamespaces: m4, optionalNamespaces: E4 } = d5;
      let _4 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: y5 });
      _4 || (_4 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: rr2.session_approve_started, properties: { topic: y5, trace: [rr2.session_approve_started, rr2.session_namespaces_validation_success] } }));
      const b4 = await this.client.core.crypto.generateKeyPair(), V3 = w3.publicKey, I3 = await this.client.core.crypto.generateSharedKey(b4, V3), T4 = R3(R3(R3({ relay: { protocol: a2 ?? "irn" }, namespaces: l4, controller: { publicKey: b4, metadata: this.client.metadata }, expiry: Si(B2) }, p3 && { sessionProperties: p3 }), h4 && { scopedProperties: h4 }), u2 && { sessionConfig: u2 }), $3 = ee2.relay;
      _4.addTrace(rr2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I3, { transportType: $3, internal: { skipSubscribe: true } });
      } catch (N4) {
        throw _4.setError(nr2.subscribe_session_topic_failure), N4;
      }
      _4.addTrace(rr2.subscribe_session_topic_success);
      const Se3 = O4(R3({}, T4), { topic: I3, requiredNamespaces: m4, optionalNamespaces: E4, pairingTopic: y5, acknowledged: false, self: T4.controller, peer: { publicKey: w3.publicKey, metadata: w3.metadata }, controller: b4, transportType: ee2.relay });
      await this.client.session.set(I3, Se3), _4.addTrace(rr2.store_session);
      try {
        await this.sendApproveSession({ sessionTopic: I3, proposal: d5, pairingProposalResponse: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: b4 }, sessionSettleRequest: T4, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: n3 } } }), _4.addTrace(rr2.session_approve_publish_success);
      } catch (N4) {
        throw this.client.logger.error(N4), this.client.session.delete(I3, zt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I3), N4;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _4.eventId }), await this.client.core.pairing.updateMetadata({ topic: y5, metadata: w3.metadata }), await this.deleteProposal(n3), await this.client.core.pairing.activate({ topic: y5 }), await this.setExpiry(I3, Si(B2)), { topic: I3, acknowledged: () => Promise.resolve(this.client.session.get(I3)) };
    }), c4(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: e, reason: s2 } = t;
      let i4;
      try {
        i4 = this.client.proposal.get(e).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`), r2;
      }
      i4 && await this.sendError({ id: e, topic: i4, error: s2, rpcOpts: P3.wc_sessionPropose.reject }), await this.deleteProposal(e);
    }), c4(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (h4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h4;
      }
      const { topic: e, namespaces: s2 } = t, { done: i4, resolve: r2, reject: n3 } = xi(), a2 = payloadId(), l4 = getBigIntRpcId().toString(), p3 = this.client.session.get(e).namespaces;
      return this.events.once(Ni("session_update", a2), ({ error: h4 }) => {
        h4 ? n3(h4) : r2();
      }), await this.client.session.update(e, { namespaces: s2 }), await this.sendRequest({ topic: e, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l4 }).catch((h4) => {
        this.client.logger.error(h4), this.client.session.update(e, { namespaces: p3 }), n3(h4);
      }), { acknowledged: i4 };
    }), c4(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: e } = t, s2 = payloadId(), { done: i4, resolve: r2, reject: n3 } = xi();
      return this.events.once(Ni("session_extend", s2), ({ error: a2 }) => {
        a2 ? n3(a2) : r2();
      }), await this.setExpiry(e, Si(B2)), this.sendRequest({ topic: e, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a2) => {
        n3(a2);
      }), { acknowledged: i4 };
    }), c4(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (m4) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), m4;
      }
      const { chainId: e, request: s2, topic: i4, expiry: r2 = P3.wc_sessionRequest.req.ttl } = t, n3 = this.client.session.get(i4);
      (n3 == null ? void 0 : n3.transportType) === ee2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l4 = getBigIntRpcId().toString(), { done: p3, resolve: h4, reject: u2 } = xi(r2, "Request expired. Please try again.");
      this.events.once(Ni("session_request", a2), ({ error: m4, result: E4 }) => {
        m4 ? u2(m4) : h4(E4);
      });
      const d5 = "wc_sessionRequest", y5 = this.getAppLinkIfEnabled(n3.peer.metadata, n3.transportType);
      if (y5) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l4, topic: i4, method: d5, params: { request: O4(R3({}, s2), { expiryTimestamp: Si(r2) }), chainId: e }, expiry: r2, throwOnFailedPublish: true, appLink: y5 }).catch((m4) => u2(m4)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: e, id: a2 }), await p3();
      const w3 = { request: O4(R3({}, s2), { expiryTimestamp: Si(r2) }), chainId: e };
      return await Promise.all([new Promise(async (m4) => {
        await this.sendRequest({ clientRpcId: a2, relayRpcId: l4, topic: i4, method: d5, params: w3, expiry: r2, throwOnFailedPublish: true, tvf: this.getTVFParams(a2, w3) }).catch((E4) => u2(E4)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: e, id: a2 }), m4();
      }), new Promise(async (m4) => {
        var E4;
        if (!((E4 = n3.sessionConfig) != null && E4.disableDeepLink)) {
          const _4 = await _i(this.client.core.storage, Le2);
          await Ui({ id: a2, topic: i4, wcDeepLink: _4 });
        }
        m4();
      }), p3()]).then((m4) => m4[2]);
    }), c4(this, "respond", async (t) => {
      this.isInitialized(), await this.isValidRespond(t);
      const { topic: e, response: s2 } = t, { id: i4 } = s2, r2 = this.client.session.get(e);
      r2.transportType === ee2.relay && await this.confirmOnlineStateOrThrow();
      const n3 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i4, topic: e, result: s2.result, throwOnFailedPublish: true, appLink: n3 }) : isJsonRpcError(s2) && await this.sendError({ id: i4, topic: e, error: s2.error, appLink: n3 }), this.cleanupAfterResponse(t);
    }), c4(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: e } = t;
      if (this.client.session.keys.includes(e)) {
        const s2 = payloadId(), i4 = getBigIntRpcId().toString(), { done: r2, resolve: n3, reject: a2 } = xi();
        this.events.once(Ni("session_ping", s2), ({ error: l4 }) => {
          l4 ? a2(l4) : n3();
        }), await Promise.all([this.sendRequest({ topic: e, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i4 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(e) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e }));
    }), c4(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: e, event: s2, chainId: i4 } = t, r2 = getBigIntRpcId().toString(), n3 = payloadId();
      await this.sendRequest({ topic: e, method: "wc_sessionEvent", params: { event: s2, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: n3 });
    }), c4(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: e } = t;
      if (this.client.session.keys.includes(e)) await this.sendRequest({ topic: e, method: "wc_sessionDelete", params: zt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e)) await this.client.core.pairing.disconnect({ topic: e });
      else {
        const { message: s2 } = Bt("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e}`);
        throw new Error(s2);
      }
    }), c4(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((e) => Ka(e, t)))), c4(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c4(this, "authenticate", async (t, e) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i4 = e && this.client.core.linkModeSupportedApps.includes(e) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r2 = i4 ? ee2.link_mode : ee2.relay;
      r2 === ee2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n3, statement: a2 = "", uri: l4, domain: p3, nonce: h4, type: u2, exp: d5, nbf: y5, methods: w3 = [], expiry: m4 } = t, E4 = [...t.resources || []], { topic: _4, uri: b4 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _4, uri: b4 } });
      const V3 = await this.client.core.crypto.generateKeyPair(), I3 = la(V3);
      if (await Promise.all([this.client.auth.authKeys.set(pe3, { responseTopic: I3, publicKey: V3 }), this.client.auth.pairingTopics.set(I3, { topic: I3, pairingTopic: _4 })]), await this.client.core.relayer.subscribe(I3, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${_4}`), w3.length > 0) {
        const { namespace: A4 } = Je(n3[0]);
        let k4 = Vc(A4, "request", w3);
        je(E4) && (k4 = Mc(k4, E4.pop())), E4.push(k4);
      }
      const T4 = m4 && m4 > P3.wc_sessionAuthenticate.req.ttl ? m4 : P3.wc_sessionAuthenticate.req.ttl, $3 = { authPayload: { type: u2 ?? "caip122", chains: n3, statement: a2, aud: l4, domain: p3, version: "1", nonce: h4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d5, nbf: y5, resources: E4 }, requester: { publicKey: V3, metadata: this.client.metadata }, expiryTimestamp: Si(T4) }, Se3 = { eip155: { chains: n3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...w3])], events: ["chainChanged", "accountsChanged"] } }, N4 = { requiredNamespaces: {}, optionalNamespaces: Se3, relays: [{ protocol: "irn" }], pairingTopic: _4, proposer: { publicKey: V3, metadata: this.client.metadata }, expiryTimestamp: Si(P3.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Tt4, resolve: Ue4, reject: Ee3 } = xi(T4, "Request expired"), se3 = payloadId(), he4 = Ni("session_connect", N4.id), Re3 = Ni("session_request", se3), de3 = async ({ error: A4, session: k4 }) => {
        this.events.off(Re3, ve4), A4 ? Ee3(A4) : k4 && Ue4({ session: k4 });
      }, ve4 = async (A4) => {
        var k4, Ge4, je2;
        if (await this.deletePendingAuthRequest(se3, { message: "fulfilled", code: 0 }), A4.error) {
          const re4 = zt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return A4.error.code === re4.code ? void 0 : (this.events.off(he4, de3), Ee3(A4.error.message));
        }
        await this.deleteProposal(N4.id), this.events.off(he4, de3);
        const { cacaos: Fe4, responder: H2 } = A4.result, Te3 = [], Qe4 = [];
        for (const re4 of Fe4) {
          await Lc({ cacao: re4, projectId: this.client.core.projectId }) || (this.client.logger.error(re4, "Signature verification failed"), Ee3(zt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe3 } = re4, Pe4 = je(qe3.resources), He4 = [to(qe3.iss)], qt4 = bn(qe3.iss);
          if (Pe4) {
            const Ne2 = Kc(Pe4), Pt4 = qc(Pe4);
            Te3.push(...Ne2), He4.push(...Pt4);
          }
          for (const Ne2 of He4) Qe4.push(`${Ne2}:${qt4}`);
        }
        const ie4 = await this.client.core.crypto.generateSharedKey(V3, H2.publicKey);
        let ue2;
        Te3.length > 0 && (ue2 = { topic: ie4, acknowledged: true, self: { publicKey: V3, metadata: this.client.metadata }, peer: H2, controller: H2.publicKey, expiry: Si(B2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _4, namespaces: Va([...new Set(Te3)], [...new Set(Qe4)]), transportType: r2 }, await this.client.core.relayer.subscribe(ie4, { transportType: r2 }), await this.client.session.set(ie4, ue2), _4 && await this.client.core.pairing.updateMetadata({ topic: _4, metadata: H2.metadata }), ue2 = this.client.session.get(ie4)), (k4 = this.client.metadata.redirect) != null && k4.linkMode && (Ge4 = H2.metadata.redirect) != null && Ge4.linkMode && (je2 = H2.metadata.redirect) != null && je2.universal && e && (this.client.core.addLinkModeSupportedApp(H2.metadata.redirect.universal), this.client.session.update(ie4, { transportType: ee2.link_mode })), Ue4({ auths: Fe4, session: ue2 });
      };
      this.events.once(he4, de3), this.events.once(Re3, ve4);
      let Ie3;
      try {
        if (i4) {
          const A4 = formatJsonRpcRequest("wc_sessionAuthenticate", $3, se3);
          this.client.core.history.set(_4, A4);
          const k4 = await this.client.core.crypto.encode("", A4, { type: we, encoding: Ge });
          Ie3 = Ra(e, _4, k4);
        } else await Promise.all([this.sendRequest({ topic: _4, method: "wc_sessionAuthenticate", params: $3, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: se3 }), this.sendRequest({ topic: _4, method: "wc_sessionPropose", params: N4, expiry: P3.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: N4.id })]);
      } catch (A4) {
        throw this.events.off(he4, de3), this.events.off(Re3, ve4), A4;
      }
      return await this.setProposal(N4.id, N4), await this.setAuthRequest(se3, { request: O4(R3({}, $3), { verifyContext: {} }), pairingTopic: _4, transportType: r2 }), { uri: Ie3 ?? b4, response: Tt4 };
    }), c4(this, "approveSessionAuthenticate", async (t) => {
      const { id: e, auths: s2 } = t, i4 = this.client.core.eventClient.createEvent({ properties: { topic: e.toString(), trace: [or.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (m4) {
        throw i4.setError(ar2.no_internet_connection), m4;
      }
      const r2 = this.getPendingAuthRequest(e);
      if (!r2) throw i4.setError(ar2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e}`);
      const n3 = r2.transportType || ee2.relay;
      n3 === ee2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l4 = await this.client.core.crypto.generateKeyPair(), p3 = la(a2), h4 = { type: ie, receiverPublicKey: a2, senderPublicKey: l4 }, u2 = [], d5 = [];
      for (const m4 of s2) {
        if (!await Lc({ cacao: m4, projectId: this.client.core.projectId })) {
          i4.setError(ar2.invalid_cacao);
          const I3 = zt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e, topic: p3, error: I3, encodeOpts: h4 }), new Error(I3.message);
        }
        i4.addTrace(or.cacaos_verified);
        const { p: E4 } = m4, _4 = je(E4.resources), b4 = [to(E4.iss)], V3 = bn(E4.iss);
        if (_4) {
          const I3 = Kc(_4), T4 = qc(_4);
          u2.push(...I3), b4.push(...T4);
        }
        for (const I3 of b4) d5.push(`${I3}:${V3}`);
      }
      const y5 = await this.client.core.crypto.generateSharedKey(l4, a2);
      i4.addTrace(or.create_authenticated_session_topic);
      let w3;
      if ((u2 == null ? void 0 : u2.length) > 0) {
        w3 = { topic: y5, acknowledged: true, self: { publicKey: l4, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: Si(B2), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: Va([...new Set(u2)], [...new Set(d5)]), transportType: n3 }, i4.addTrace(or.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(y5, { transportType: n3 });
        } catch (m4) {
          throw i4.setError(ar2.subscribe_authenticated_session_topic_failure), m4;
        }
        i4.addTrace(or.subscribe_authenticated_session_topic_success), await this.client.session.set(y5, w3), i4.addTrace(or.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i4.addTrace(or.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p3, id: e, result: { cacaos: s2, responder: { publicKey: l4, metadata: this.client.metadata } }, encodeOpts: h4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, n3) });
      } catch (m4) {
        throw i4.setError(ar2.authenticated_session_approve_publish_failure), m4;
      }
      return await this.client.auth.requests.delete(e, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: w3 };
    }), c4(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: e, reason: s2 } = t, i4 = this.getPendingAuthRequest(e);
      if (!i4) throw new Error(`Could not find pending auth request with id ${e}`);
      i4.transportType === ee2.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i4.requester.publicKey, n3 = await this.client.core.crypto.generateKeyPair(), a2 = la(r2), l4 = { type: ie, receiverPublicKey: r2, senderPublicKey: n3 };
      await this.sendError({ id: e, topic: a2, error: s2, encodeOpts: l4, rpcOpts: P3.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(e, { message: "rejected", code: 0 }), await this.deleteProposal(e);
    }), c4(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: e, iss: s2 } = t;
      return eo(e, s2);
    }), c4(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t = this.relayMessageCache.shift();
          t && await this.onRelayMessage(t);
        } catch (t) {
          this.client.logger.error(t);
        }
      }, 50);
    }), c4(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic) try {
        const e = this.client.core.pairing.pairings.get(t.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i4) => {
          var r2, n3;
          return ((r2 = i4.peerMetadata) == null ? void 0 : r2.url) && ((n3 = i4.peerMetadata) == null ? void 0 : n3.url) === t.peer.metadata.url && i4.topic && i4.topic !== e.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (e) {
        this.client.logger.error(e);
      }
    }), c4(this, "deleteSession", async (t) => {
      var e;
      const { topic: s2, expirerHasDeleted: i4 = false, emitEvent: r2 = true, id: n3 = 0 } = t, { self: a2 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, zt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i4 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(Le2).catch((l4) => this.client.logger.warn(l4)), this.getPendingSessionRequests().forEach((l4) => {
        l4.topic === s2 && this.deletePendingSessionRequest(l4.id, zt("USER_DISCONNECTED"));
      }), s2 === ((e = this.sessionRequestQueue.queue[0]) == null ? void 0 : e.topic) && (this.sessionRequestQueue.state = M3.idle), r2 && this.client.events.emit("session_delete", { id: n3, topic: s2 });
    }), c4(this, "deleteProposal", async (t, e) => {
      if (e) try {
        const s2 = this.client.proposal.get(t), i4 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i4 == null ? void 0 : i4.setError(nr2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t, zt("USER_DISCONNECTED")), e ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), c4(this, "deletePendingSessionRequest", async (t, e, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(t, e), s2 ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== t), s2 && (this.sessionRequestQueue.state = M3.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), c4(this, "deletePendingAuthRequest", async (t, e, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(t, e), s2 ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), c4(this, "setExpiry", async (t, e) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, e), await this.client.session.update(t, { expiry: e }));
    }), c4(this, "setProposal", async (t, e) => {
      this.client.core.expirer.set(t, Si(P3.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, e);
    }), c4(this, "setAuthRequest", async (t, e) => {
      const { request: s2, pairingTopic: i4, transportType: r2 = ee2.relay } = e;
      this.client.core.expirer.set(t, s2.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: t, pairingTopic: i4, verifyContext: s2.verifyContext, transportType: r2 });
    }), c4(this, "setPendingSessionRequest", async (t) => {
      const { id: e, topic: s2, params: i4, verifyContext: r2 } = t, n3 = i4.request.expiryTimestamp || Si(P3.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e, n3), await this.client.pendingRequest.set(e, { id: e, topic: s2, params: i4, verifyContext: r2 });
    }), c4(this, "sendRequest", async (t) => {
      const { topic: e, method: s2, params: i4, expiry: r2, relayRpcId: n3, clientRpcId: a2, throwOnFailedPublish: l4, appLink: p3, tvf: h4, publishOpts: u2 = {} } = t, d5 = formatJsonRpcRequest(s2, i4, a2);
      let y5;
      const w3 = !!p3;
      try {
        const _4 = w3 ? Ge : oe;
        y5 = await this.client.core.crypto.encode(e, d5, { encoding: _4 });
      } catch (_4) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`), _4;
      }
      let m4;
      if (mt2.includes(s2)) {
        const _4 = da(JSON.stringify(d5)), b4 = da(y5);
        m4 = await this.client.core.verify.register({ id: b4, decryptedId: _4 });
      }
      const E4 = R3(R3({}, P3[s2].req), u2);
      if (E4.attestation = m4, r2 && (E4.ttl = r2), n3 && (E4.id = n3), this.client.core.history.set(e, d5), w3) {
        const _4 = Ra(p3, e, y5);
        await global.Linking.openURL(_4, this.client.name);
      } else E4.tvf = O4(R3({}, h4), { correlationId: d5.id }), l4 ? (E4.internal = O4(R3({}, E4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e, y5, E4)) : this.client.core.relayer.publish(e, y5, E4).catch((_4) => this.client.logger.error(_4));
      return d5.id;
    }), c4(this, "sendProposeSession", async (t) => {
      const { proposal: e, publishOpts: s2 } = t, i4 = formatJsonRpcRequest("wc_sessionPropose", e, e.id);
      this.client.core.history.set(e.pairingTopic, i4);
      const r2 = await this.client.core.crypto.encode(e.pairingTopic, i4, { encoding: oe }), n3 = da(JSON.stringify(i4)), a2 = da(r2), l4 = await this.client.core.verify.register({ id: a2, decryptedId: n3 });
      await this.client.core.relayer.publishCustom({ payload: { pairingTopic: e.pairingTopic, sessionProposal: r2 }, opts: O4(R3({}, s2), { publishMethod: "wc_proposeSession", attestation: l4 }) });
    }), c4(this, "sendApproveSession", async (t) => {
      const { sessionTopic: e, pairingProposalResponse: s2, proposal: i4, sessionSettleRequest: r2, publishOpts: n3 } = t, a2 = formatJsonRpcResult(i4.id, s2), l4 = await this.client.core.crypto.encode(i4.pairingTopic, a2, { encoding: oe }), p3 = formatJsonRpcRequest("wc_sessionSettle", r2, n3 == null ? void 0 : n3.id), h4 = await this.client.core.crypto.encode(e, p3, { encoding: oe });
      this.client.core.history.set(e, p3), await this.client.core.relayer.publishCustom({ payload: { sessionTopic: e, pairingTopic: i4.pairingTopic, sessionProposalResponse: l4, sessionSettlementRequest: h4 }, opts: O4(R3({}, n3), { publishMethod: "wc_approveSession" }) });
    }), c4(this, "sendResult", async (t) => {
      const { id: e, topic: s2, result: i4, throwOnFailedPublish: r2, encodeOpts: n3, appLink: a2 } = t, l4 = formatJsonRpcResult(e, i4);
      let p3;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const y5 = h4 ? Ge : oe;
        p3 = await this.client.core.crypto.encode(s2, l4, O4(R3({}, n3 || {}), { encoding: y5 }));
      } catch (y5) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), y5;
      }
      let u2, d5;
      try {
        u2 = await this.client.core.history.get(s2, e);
        const y5 = u2.request;
        try {
          d5 = this.getTVFParams(e, y5.params, i4);
        } catch (w3) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${w3 == null ? void 0 : w3.message}`);
        }
      } catch (y5) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${e}) failed`), y5;
      }
      if (h4) {
        const y5 = Ra(a2, s2, p3);
        await global.Linking.openURL(y5, this.client.name);
      } else {
        const y5 = u2.request.method, w3 = P3[y5].res;
        w3.tvf = O4(R3({}, d5), { correlationId: e }), r2 ? (w3.internal = O4(R3({}, w3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, p3, w3)) : this.client.core.relayer.publish(s2, p3, w3).catch((m4) => this.client.logger.error(m4));
      }
      await this.client.core.history.resolve(l4);
    }), c4(this, "sendError", async (t) => {
      const { id: e, topic: s2, error: i4, encodeOpts: r2, rpcOpts: n3, appLink: a2 } = t, l4 = formatJsonRpcError(e, i4);
      let p3;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d5 = h4 ? Ge : oe;
        p3 = await this.client.core.crypto.encode(s2, l4, O4(R3({}, r2 || {}), { encoding: d5 }));
      } catch (d5) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), d5;
      }
      let u2;
      try {
        u2 = await this.client.core.history.get(s2, e);
      } catch (d5) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${e}) failed`), d5;
      }
      if (h4) {
        const d5 = Ra(a2, s2, p3);
        await global.Linking.openURL(d5, this.client.name);
      } else {
        const d5 = u2.request.method, y5 = n3 || P3[d5].res;
        this.client.core.relayer.publish(s2, p3, y5);
      }
      await this.client.core.history.resolve(l4);
    }), c4(this, "cleanup", async () => {
      const t = [], e = [];
      this.client.session.getAll().forEach((s2) => {
        let i4 = false;
        Oi(s2.expiry) && (i4 = true), this.client.core.crypto.keychain.has(s2.topic) || (i4 = true), i4 && t.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        Oi(s2.expiryTimestamp) && e.push(s2.id);
      }), await Promise.all([...t.map((s2) => this.deleteSession({ topic: s2 })), ...e.map((s2) => this.deleteProposal(s2))]);
    }), c4(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), c4(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), c4(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === M3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = M3.active;
        const t = this.requestQueue.queue.shift();
        if (t) try {
          await this.processRequest(t);
        } catch (e) {
          this.client.logger.warn(e);
        }
      }
      this.requestQueue.state = M3.idle;
    }), c4(this, "processRequest", async (t) => {
      const { topic: e, payload: s2, attestation: i4, transportType: r2, encryptedId: n3 } = t, a2 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: e, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: e, payload: s2, attestation: i4, encryptedId: n3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(e, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(e, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(e, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(e, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(e, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: e, payload: s2, attestation: i4, encryptedId: n3, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(e, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: e, payload: s2, attestation: i4, encryptedId: n3, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c4(this, "onRelayEventResponse", async (t) => {
      const { topic: e, payload: s2, transportType: i4 } = t, r2 = (await this.client.core.history.get(e, s2.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e, s2, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c4(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: e } = t, { message: s2 } = Bt("MISSING_OR_INVALID", `Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }), c4(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: e, requestMethod: s2 } = t, i4 = this.expectedPairingMethodMap.get(e);
      return !i4 || i4.includes(s2) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c4(this, "onSessionProposeRequest", async (t) => {
      const { topic: e, payload: s2, attestation: i4, encryptedId: r2 } = t, { params: n3, id: a2 } = s2;
      try {
        const l4 = this.client.core.eventClient.getEvent({ topic: e });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l4 == null ? void 0 : l4.setError(X2.proposal_listener_not_found)), this.isValidConnect(R3({}, s2.params));
        const p3 = n3.expiryTimestamp || Si(P3.wc_sessionPropose.req.ttl), h4 = R3({ id: a2, pairingTopic: e, expiryTimestamp: p3, attestation: i4, encryptedId: r2 }, n3);
        await this.setProposal(a2, h4);
        const u2 = await this.getVerifyContext({ attestationId: i4, hash: da(JSON.stringify(s2)), encryptedId: r2, metadata: h4.proposer.metadata });
        l4 == null ? void 0 : l4.addTrace(Y.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h4, verifyContext: u2 });
      } catch (l4) {
        await this.sendError({ id: a2, topic: e, error: l4, rpcOpts: P3.wc_sessionPropose.autoReject }), this.client.logger.error(l4);
      }
    }), c4(this, "onSessionProposeResponse", async (t, e, s2) => {
      const { id: i4 } = e;
      if (isJsonRpcResult(e)) {
        const { result: r2 } = e;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const n3 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n3 });
        const a2 = n3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l4 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l4 });
        const p3 = await this.client.core.crypto.generateSharedKey(a2, l4);
        this.pendingSessions.set(i4, { sessionTopic: p3, pairingTopic: t, proposalId: i4, publicKey: a2 });
        const h4 = await this.client.core.relayer.subscribe(p3, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h4 }), await this.client.core.pairing.activate({ topic: t });
      } else if (isJsonRpcError(e)) {
        await this.deleteProposal(i4);
        const r2 = Ni("session_connect", i4);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: e.error });
      }
    }), c4(this, "onSessionSettleRequest", async (t, e) => {
      const { id: s2, params: i4 } = e;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: r2, controller: n3, expiry: a2, namespaces: l4, sessionProperties: p3, scopedProperties: h4, sessionConfig: u2 } = e.params, d5 = [...this.pendingSessions.values()].find((m4) => m4.sessionTopic === t);
        if (!d5) return this.client.logger.error(`Pending session not found for topic ${t}`);
        const y5 = this.client.proposal.get(d5.proposalId), w3 = O4(R3(R3(R3({ topic: t, relay: r2, expiry: a2, namespaces: l4, acknowledged: true, pairingTopic: d5.pairingTopic, requiredNamespaces: y5.requiredNamespaces, optionalNamespaces: y5.optionalNamespaces, controller: n3.publicKey, self: { publicKey: d5.publicKey, metadata: this.client.metadata }, peer: { publicKey: n3.publicKey, metadata: n3.metadata } }, p3 && { sessionProperties: p3 }), h4 && { scopedProperties: h4 }), u2 && { sessionConfig: u2 }), { transportType: ee2.relay });
        await this.client.session.set(w3.topic, w3), await this.setExpiry(w3.topic, w3.expiry), await this.client.core.pairing.updateMetadata({ topic: d5.pairingTopic, metadata: w3.peer.metadata }), this.client.events.emit("session_connect", { session: w3 }), this.events.emit(Ni("session_connect", d5.proposalId), { session: w3 }), this.pendingSessions.delete(d5.proposalId), this.deleteProposal(d5.proposalId, false), this.cleanupDuplicatePairings(w3), await this.sendResult({ id: e.id, topic: t, result: true });
      } catch (r2) {
        await this.sendError({ id: s2, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c4(this, "onSessionSettleResponse", async (t, e) => {
      const { id: s2 } = e;
      isJsonRpcResult(e) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(Ni("session_approve", s2), {})) : isJsonRpcError(e) && (await this.client.session.delete(t, zt("USER_DISCONNECTED")), this.events.emit(Ni("session_approve", s2), { error: e.error }));
    }), c4(this, "onSessionUpdateRequest", async (t, e) => {
      const { params: s2, id: i4 } = e;
      try {
        const r2 = `${t}_session_update`, n3 = lu.get(r2);
        if (n3 && this.isRequestOutOfSync(n3, i4)) {
          this.client.logger.warn(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: t, error: zt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(R3({ topic: t }, s2));
        try {
          lu.set(r2, i4), await this.client.session.update(t, { namespaces: s2.namespaces }), await this.sendResult({ id: i4, topic: t, result: true });
        } catch (a2) {
          throw lu.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i4, topic: t, params: s2 });
      } catch (r2) {
        await this.sendError({ id: i4, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c4(this, "isRequestOutOfSync", (t, e) => e.toString().slice(0, -3) < t.toString().slice(0, -3)), c4(this, "onSessionUpdateResponse", (t, e) => {
      const { id: s2 } = e, i4 = Ni("session_update", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(Ni("session_update", s2), {}) : isJsonRpcError(e) && this.events.emit(Ni("session_update", s2), { error: e.error });
    }), c4(this, "onSessionExtendRequest", async (t, e) => {
      const { id: s2 } = e;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, Si(B2)), await this.sendResult({ id: s2, topic: t, result: true }), this.client.events.emit("session_extend", { id: s2, topic: t });
      } catch (i4) {
        await this.sendError({ id: s2, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c4(this, "onSessionExtendResponse", (t, e) => {
      const { id: s2 } = e, i4 = Ni("session_extend", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(Ni("session_extend", s2), {}) : isJsonRpcError(e) && this.events.emit(Ni("session_extend", s2), { error: e.error });
    }), c4(this, "onSessionPingRequest", async (t, e) => {
      const { id: s2 } = e;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s2, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: t });
      } catch (i4) {
        await this.sendError({ id: s2, topic: t, error: i4 }), this.client.logger.error(i4);
      }
    }), c4(this, "onSessionPingResponse", (t, e) => {
      const { id: s2 } = e, i4 = Ni("session_ping", s2);
      setTimeout(() => {
        if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners 2176`);
        isJsonRpcResult(e) ? this.events.emit(Ni("session_ping", s2), {}) : isJsonRpcError(e) && this.events.emit(Ni("session_ping", s2), { error: e.error });
      }, 500);
    }), c4(this, "onSessionDeleteRequest", async (t, e) => {
      const { id: s2 } = e;
      try {
        this.isValidDisconnect({ topic: t, reason: e.params }), await Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(C3.publish, async () => {
            i4(await this.deleteSession({ topic: t, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: t, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: zt("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }), c4(this, "onSessionRequest", async (t) => {
      var e, s2, i4;
      const { topic: r2, payload: n3, attestation: a2, encryptedId: l4, transportType: p3 } = t, { id: h4, params: u2 } = n3;
      try {
        await this.isValidRequest(R3({ topic: r2 }, u2));
        const d5 = this.client.session.get(r2), y5 = await this.getVerifyContext({ attestationId: a2, hash: da(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u2, h4))), encryptedId: l4, metadata: d5.peer.metadata, transportType: p3 }), w3 = { id: h4, topic: r2, params: u2, verifyContext: y5 };
        await this.setPendingSessionRequest(w3), p3 === ee2.link_mode && (e = d5.peer.metadata.redirect) != null && e.universal && this.client.core.addLinkModeSupportedApp((s2 = d5.peer.metadata.redirect) == null ? void 0 : s2.universal), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(w3) : (this.addSessionRequestToSessionRequestQueue(w3), this.processSessionRequestQueue());
      } catch (d5) {
        await this.sendError({ id: h4, topic: r2, error: d5 }), this.client.logger.error(d5);
      }
    }), c4(this, "onSessionRequestResponse", (t, e) => {
      const { id: s2 } = e, i4 = Ni("session_request", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(e) ? this.events.emit(Ni("session_request", s2), { result: e.result }) : isJsonRpcError(e) && this.events.emit(Ni("session_request", s2), { error: e.error });
    }), c4(this, "onSessionEventRequest", async (t, e) => {
      const { id: s2, params: i4 } = e;
      try {
        const r2 = `${t}_session_event_${i4.event.name}`, n3 = lu.get(r2);
        if (n3 && this.isRequestOutOfSync(n3, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(R3({ topic: t }, i4)), this.client.events.emit("session_event", { id: s2, topic: t, params: i4 }), lu.set(r2, s2);
      } catch (r2) {
        await this.sendError({ id: s2, topic: t, error: r2 }), this.client.logger.error(r2);
      }
    }), c4(this, "onSessionAuthenticateResponse", (t, e) => {
      const { id: s2 } = e;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: e }), isJsonRpcResult(e) ? this.events.emit(Ni("session_request", s2), { result: e.result }) : isJsonRpcError(e) && this.events.emit(Ni("session_request", s2), { error: e.error });
    }), c4(this, "onSessionAuthenticateRequest", async (t) => {
      var e;
      const { topic: s2, payload: i4, attestation: r2, encryptedId: n3, transportType: a2 } = t;
      try {
        const { requester: l4, authPayload: p3, expiryTimestamp: h4 } = i4.params, u2 = await this.getVerifyContext({ attestationId: r2, hash: da(JSON.stringify(i4)), encryptedId: n3, metadata: l4.metadata, transportType: a2 }), d5 = { requester: l4, pairingTopic: s2, id: i4.id, authPayload: p3, verifyContext: u2, expiryTimestamp: h4 };
        await this.setAuthRequest(i4.id, { request: d5, pairingTopic: s2, transportType: a2 }), a2 === ee2.link_mode && (e = l4.metadata.redirect) != null && e.universal && this.client.core.addLinkModeSupportedApp(l4.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i4.params, id: i4.id, verifyContext: u2 });
      } catch (l4) {
        this.client.logger.error(l4);
        const p3 = i4.params.requester.publicKey, h4 = await this.client.core.crypto.generateKeyPair(), u2 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a2), d5 = { type: ie, receiverPublicKey: p3, senderPublicKey: h4 };
        await this.sendError({ id: i4.id, topic: s2, error: l4, encodeOpts: d5, rpcOpts: P3.wc_sessionAuthenticate.autoReject, appLink: u2 });
      }
    }), c4(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), c4(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = M3.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c4(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: e }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i4) => i4.topic === t && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const r2 = i4.request.id, n3 = Ni("session_request", r2);
        if (this.events.listenerCount(n3) === 0) throw new Error(`emitting ${n3} without any listeners`);
        this.events.emit(Ni("session_request", i4.request.id), { error: e });
      });
    }), c4(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === M3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t);
      } catch (e) {
        this.client.logger.error(e);
      }
    }), c4(this, "emitSessionRequest", (t) => {
      if (this.emittedSessionRequests.has(t.id)) {
        this.client.logger.warn({ id: t.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
        return;
      }
      this.sessionRequestQueue.state = M3.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
    }), c4(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
      const e = this.client.proposal.getAll().find((s2) => s2.pairingTopic === t.topic);
      e && this.onSessionProposeRequest({ topic: t.topic, payload: formatJsonRpcRequest("wc_sessionPropose", O4(R3({}, e), { requiredNamespaces: e.requiredNamespaces, optionalNamespaces: e.optionalNamespaces, relays: e.relays, proposer: e.proposer, sessionProperties: e.sessionProperties, scopedProperties: e.scopedProperties }), e.id), attestation: e.attestation, encryptedId: e.encryptedId });
    }), c4(this, "isValidConnect", async (t) => {
      if (!Xa(t)) {
        const { message: l4 } = Bt("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(l4);
      }
      const { pairingTopic: e, requiredNamespaces: s2, optionalNamespaces: i4, sessionProperties: r2, scopedProperties: n3, relays: a2 } = t;
      if (Dt(e) || await this.isValidPairingTopic(e), !Ya(a2, true)) {
        const { message: l4 } = Bt("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l4);
      }
      if (!Dt(s2) && Ye(s2) !== 0) {
        const l4 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l4) : this.client.logger.warn(l4), this.validateNamespaces(s2, "requiredNamespaces");
      }
      if (!Dt(i4) && Ye(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), Dt(r2) || this.validateSessionProps(r2, "sessionProperties"), !Dt(n3)) {
        this.validateSessionProps(n3, "scopedProperties");
        const l4 = Object.keys(s2 || {}).concat(Object.keys(i4 || {}));
        if (!Object.keys(n3).every((p3) => l4.includes(p3.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n3)}, required/optional namespaces: ${JSON.stringify(l4)}`);
      }
    }), c4(this, "validateNamespaces", (t, e) => {
      const s2 = za(t, "connect()", e);
      if (s2) throw new Error(s2.message);
    }), c4(this, "isValidApprove", async (t) => {
      if (!Xa(t)) throw new Error(Bt("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: e, namespaces: s2, relayProtocol: i4, sessionProperties: r2, scopedProperties: n3 } = t;
      this.checkRecentlyDeleted(e), await this.isValidProposalId(e);
      const a2 = this.client.proposal.get(e), l4 = Ss(s2, "approve()");
      if (l4) throw new Error(l4.message);
      const p3 = Ns(a2.requiredNamespaces, s2, "approve()");
      if (p3) throw new Error(p3.message);
      if (!ft(i4, true)) {
        const { message: h4 } = Bt("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h4);
      }
      if (Dt(r2) || this.validateSessionProps(r2, "sessionProperties"), !Dt(n3)) {
        this.validateSessionProps(n3, "scopedProperties");
        const h4 = new Set(Object.keys(s2));
        if (!Object.keys(n3).every((u2) => h4.has(u2.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n3)}, approved namespaces: ${Array.from(h4).join(", ")}`);
      }
    }), c4(this, "isValidReject", async (t) => {
      if (!Xa(t)) {
        const { message: i4 } = Bt("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i4);
      }
      const { id: e, reason: s2 } = t;
      if (this.checkRecentlyDeleted(e), await this.isValidProposalId(e), !Ja(s2)) {
        const { message: i4 } = Bt("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i4);
      }
    }), c4(this, "isValidSessionSettleRequest", (t) => {
      if (!Xa(t)) {
        const { message: l4 } = Bt("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(l4);
      }
      const { relay: e, controller: s2, namespaces: i4, expiry: r2 } = t;
      if (!Os(e)) {
        const { message: l4 } = Bt("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l4);
      }
      const n3 = Ga(s2, "onSessionSettleRequest()");
      if (n3) throw new Error(n3.message);
      const a2 = Ss(i4, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (Oi(r2)) {
        const { message: l4 } = Bt("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l4);
      }
    }), c4(this, "isValidUpdate", async (t) => {
      if (!Xa(t)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(a2);
      }
      const { topic: e, namespaces: s2 } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const i4 = this.client.session.get(e), r2 = Ss(s2, "update()");
      if (r2) throw new Error(r2.message);
      const n3 = Ns(i4.requiredNamespaces, s2, "update()");
      if (n3) throw new Error(n3.message);
    }), c4(this, "isValidExtend", async (t) => {
      if (!Xa(t)) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s2);
      }
      const { topic: e } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
    }), c4(this, "isValidRequest", async (t) => {
      if (!Xa(t)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(a2);
      }
      const { topic: e, request: s2, chainId: i4, expiry: r2 } = t;
      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);
      const { namespaces: n3 } = this.client.session.get(e);
      if (!nu(n3, i4)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a2);
      }
      if (!Qa(s2)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a2);
      }
      if (!ru(n3, i4, s2.method)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a2);
      }
      if (r2 && !cu(r2, _e2)) {
        const { message: a2 } = Bt("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e2.min} and ${_e2.max}`);
        throw new Error(a2);
      }
    }), c4(this, "isValidRespond", async (t) => {
      var e;
      if (!Xa(t)) {
        const { message: r2 } = Bt("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(r2);
      }
      const { topic: s2, response: i4 } = t;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r2) {
        throw (e = t == null ? void 0 : t.response) != null && e.id && this.cleanupAfterResponse(t), r2;
      }
      if (!tu(i4)) {
        const { message: r2 } = Bt("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(r2);
      }
    }), c4(this, "isValidPing", async (t) => {
      if (!Xa(t)) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s2);
      }
      const { topic: e } = t;
      await this.isValidSessionOrPairingTopic(e);
    }), c4(this, "isValidEmit", async (t) => {
      if (!Xa(t)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(n3);
      }
      const { topic: e, event: s2, chainId: i4 } = t;
      await this.isValidSessionTopic(e);
      const { namespaces: r2 } = this.client.session.get(e);
      if (!nu(r2, i4)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(n3);
      }
      if (!eu(s2)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n3);
      }
      if (!ou(r2, i4, s2.name)) {
        const { message: n3 } = Bt("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n3);
      }
    }), c4(this, "isValidDisconnect", async (t) => {
      if (!Xa(t)) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s2);
      }
      const { topic: e } = t;
      await this.isValidSessionOrPairingTopic(e);
    }), c4(this, "isValidAuthenticate", (t) => {
      const { chains: e, uri: s2, domain: i4, nonce: r2 } = t;
      if (!Array.isArray(e) || e.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!ft(s2, false)) throw new Error("uri is required parameter");
      if (!ft(i4, false)) throw new Error("domain is required parameter");
      if (!ft(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(e.map((a2) => Je(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n3 } = Je(e[0]);
      if (n3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c4(this, "getVerifyContext", async (t) => {
      const { attestationId: e, hash: s2, encryptedId: i4, metadata: r2, transportType: n3 } = t, a2 = { verified: { verifyUrl: r2.verifyUrl || be2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (n3 === ee2.link_mode) {
          const p3 = this.getAppLinkIfEnabled(r2, n3);
          return a2.verified.validation = p3 && new URL(p3).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l4 = await this.client.core.verify.resolve({ attestationId: e, hash: s2, encryptedId: i4, verifyUrl: r2.verifyUrl });
        l4 && (a2.verified.origin = l4.origin, a2.verified.isScam = l4.isScam, a2.verified.validation = l4.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l4) {
        this.client.logger.warn(l4);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c4(this, "validateSessionProps", (t, e) => {
      Object.values(t).forEach((s2, i4) => {
        if (s2 == null) {
          const { message: r2 } = Bt("MISSING_OR_INVALID", `${e} must contain an existing value for each key. Received: ${s2} for key ${Object.keys(t)[i4]}`);
          throw new Error(r2);
        }
      });
    }), c4(this, "getPendingAuthRequest", (t) => {
      const e = this.client.auth.requests.get(t);
      return typeof e == "object" ? e : void 0;
    }), c4(this, "addToRecentlyDeleted", (t, e) => {
      if (this.recentlyDeletedMap.set(t, e), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i4) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c4(this, "checkRecentlyDeleted", (t) => {
      const e = this.recentlyDeletedMap.get(t);
      if (e) {
        const { message: s2 } = Bt("MISSING_OR_INVALID", `Record was recently deleted - ${e}: ${t}`);
        throw new Error(s2);
      }
    }), c4(this, "isLinkModeEnabled", (t, e) => {
      var s2, i4, r2, n3, a2, l4, p3, h4, u2;
      return !t || e !== ee2.link_mode ? false : ((i4 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i4.linkMode) === true && ((n3 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : n3.universal) !== void 0 && ((l4 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l4.universal) !== "" && ((p3 = t == null ? void 0 : t.redirect) == null ? void 0 : p3.universal) !== void 0 && ((h4 = t == null ? void 0 : t.redirect) == null ? void 0 : h4.universal) !== "" && ((u2 = t == null ? void 0 : t.redirect) == null ? void 0 : u2.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c4(this, "getAppLinkIfEnabled", (t, e) => {
      var s2;
      return this.isLinkModeEnabled(t, e) ? (s2 = t == null ? void 0 : t.redirect) == null ? void 0 : s2.universal : void 0;
    }), c4(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
      const e = Ri(t, "topic") || "", s2 = decodeURIComponent(Ri(t, "wc_ev") || ""), i4 = this.client.session.keys.includes(e);
      i4 && this.client.session.update(e, { transportType: ee2.link_mode }), this.client.core.dispatchEnvelope({ topic: e, message: s2, sessionExists: i4 });
    }), c4(this, "registerLinkModeListeners", async () => {
      var t;
      if (Ti() || At() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const e = global == null ? void 0 : global.Linking;
        if (typeof e < "u") {
          e.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await e.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    }), c4(this, "getTVFParams", (t, e, s2) => {
      var i4, r2, n3;
      if (!((i4 = e.request) != null && i4.method)) return {};
      const a2 = { correlationId: t, rpcMethods: [e.request.method], chainId: e.chainId };
      try {
        const l4 = this.extractTxHashesFromResult(e.request, s2);
        a2.txHashes = l4, a2.contractAddresses = this.isValidContractData(e.request.params) ? [(n3 = (r2 = e.request.params) == null ? void 0 : r2[0]) == null ? void 0 : n3.to] : [];
      } catch (l4) {
        this.client.logger.warn("Error getting TVF params", l4);
      }
      return a2;
    }), c4(this, "isValidContractData", (t) => {
      var e;
      if (!t) return false;
      try {
        const s2 = (t == null ? void 0 : t.data) || ((e = t == null ? void 0 : t[0]) == null ? void 0 : e.data);
        if (!s2.startsWith("0x")) return false;
        const i4 = s2.slice(2);
        return /^[0-9a-fA-F]*$/.test(i4) ? i4.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c4(this, "extractTxHashesFromResult", (t, e) => {
      var s2;
      try {
        if (!e) return [];
        const i4 = t.method, r2 = yt2[i4];
        if (i4 === "sui_signTransaction") return [Ic(e.transactionBytes)];
        if (i4 === "near_signTransaction") return [Sc(e)];
        if (i4 === "near_signTransactions") return e.map((a2) => Sc(a2));
        if (i4 === "xrpl_signTransactionFor" || i4 === "xrpl_signTransaction") return [(s2 = e.tx_json) == null ? void 0 : s2.hash];
        if (i4 === "polkadot_signTransaction") return [bu({ transaction: t.params.transactionPayload, signature: e.signature })];
        if (i4 === "algo_signTxn") return Ee(e) ? e.map((a2) => Oc(a2)) : [Oc(e)];
        if (i4 === "cosmos_signDirect") return [Nc(e)];
        if (i4 === "wallet_sendCalls") return Uc(e);
        if (typeof e == "string") return [e];
        const n3 = e[r2.key];
        if (Ee(n3)) return i4 === "solana_signAllTransactions" ? n3.map((a2) => Ac(a2)) : n3;
        if (typeof n3 == "string") return [n3];
      } catch (i4) {
        this.client.logger.warn("Error extracting tx hashes from result", i4);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o2 = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(o2);
      for (const [e, s2] of Object.entries(t)) for (const i4 of s2) try {
        await this.onProviderMessageEvent({ topic: e, message: i4, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${e}, message: ${i4}`);
      }
    } catch (o2) {
      this.client.logger.warn("processPendingMessageEvents failed", o2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o2 } = Bt("NOT_INITIALIZED", this.name);
      throw new Error(o2);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C3.message, (o2) => {
      this.onProviderMessageEvent(o2);
    });
  }
  async onRelayMessage(o2) {
    const { topic: t, message: e, attestation: s2, transportType: i4 } = o2, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(pe3) ? this.client.auth.authKeys.get(pe3) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n3 = await this.client.core.crypto.decode(t, e, { receiverPublicKey: r2, encoding: i4 === ee2.link_mode ? Ge : oe });
      isJsonRpcRequest(n3) ? (this.client.core.history.set(t, n3), await this.onRelayEventRequest({ topic: t, payload: n3, attestation: s2, transportType: i4, encryptedId: da(e) })) : isJsonRpcResponse(n3) ? (await this.client.core.history.resolve(n3), await this.onRelayEventResponse({ topic: t, payload: n3, transportType: i4 }), this.client.core.history.delete(t, n3.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: n3, transportType: i4 }), await this.client.core.relayer.messages.ack(t, e);
    } catch (n3) {
      this.client.logger.error(n3);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(q.expired, async (o2) => {
      const { topic: t, id: e } = Ii(o2.target);
      if (e && this.client.pendingRequest.keys.includes(e)) return await this.deletePendingSessionRequest(e, Bt("EXPIRED"), true);
      if (e && this.client.auth.requests.keys.includes(e)) return await this.deletePendingAuthRequest(e, Bt("EXPIRED"), true);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : e && (await this.deleteProposal(e, true), this.client.events.emit("proposal_expire", { id: e }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(ae2.create, (o2) => this.onPairingCreated(o2)), this.client.core.pairing.events.on(ae2.delete, (o2) => {
      this.addToRecentlyDeleted(o2.topic, "pairing");
    });
  }
  isValidPairingTopic(o2) {
    if (!ft(o2, false)) {
      const { message: t } = Bt("MISSING_OR_INVALID", `pairing topic should be a string: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o2)) {
      const { message: t } = Bt("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (Oi(this.client.core.pairing.pairings.get(o2).expiry)) {
      const { message: t } = Bt("EXPIRED", `pairing topic: ${o2}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(o2) {
    if (!ft(o2, false)) {
      const { message: t } = Bt("MISSING_OR_INVALID", `session topic should be a string: ${o2}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(o2), !this.client.session.keys.includes(o2)) {
      const { message: t } = Bt("NO_MATCHING_KEY", `session topic doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (Oi(this.client.session.get(o2).expiry)) {
      await this.deleteSession({ topic: o2 });
      const { message: t } = Bt("EXPIRED", `session topic: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(o2)) {
      const { message: t } = Bt("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o2}`);
      throw await this.deleteSession({ topic: o2 }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(o2) {
    if (this.checkRecentlyDeleted(o2), this.client.session.keys.includes(o2)) await this.isValidSessionTopic(o2);
    else if (this.client.core.pairing.pairings.keys.includes(o2)) this.isValidPairingTopic(o2);
    else if (ft(o2, false)) {
      const { message: t } = Bt("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o2}`);
      throw new Error(t);
    } else {
      const { message: t } = Bt("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o2}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(o2) {
    if (!Wa(o2)) {
      const { message: t } = Bt("MISSING_OR_INVALID", `proposal id should be a number: ${o2}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(o2)) {
      const { message: t } = Bt("NO_MATCHING_KEY", `proposal id doesn't exist: ${o2}`);
      throw new Error(t);
    }
    if (Oi(this.client.proposal.get(o2).expiryTimestamp)) {
      await this.deleteProposal(o2);
      const { message: t } = Bt("EXPIRED", `proposal id: ${o2}`);
      throw new Error(t);
    }
  }
};
var Ds2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, dt2, we3), this.core = o2, this.logger = t;
  }
};
var It3 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, ut2, we3), this.core = o2, this.logger = t;
  }
};
var Ls2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, wt2, we3, (e) => e.id), this.core = o2, this.logger = t;
  }
};
var Ms = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, St3, le2, () => pe3), this.core = o2, this.logger = t;
  }
};
var $s2 = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, Et2, le2), this.core = o2, this.logger = t;
  }
};
var Ks = class extends Ui2 {
  constructor(o2, t) {
    super(o2, t, Rt3, le2, (e) => e.id), this.core = o2, this.logger = t;
  }
};
var Us2 = Object.defineProperty;
var Gs2 = (S5, o2, t) => o2 in S5 ? Us2(S5, o2, { enumerable: true, configurable: true, writable: true, value: t }) : S5[o2] = t;
var Ke3 = (S5, o2, t) => Gs2(S5, typeof o2 != "symbol" ? o2 + "" : o2, t);
var js2 = class {
  constructor(o2, t) {
    this.core = o2, this.logger = t, Ke3(this, "authKeys"), Ke3(this, "pairingTopics"), Ke3(this, "requests"), this.authKeys = new Ms(this.core, this.logger), this.pairingTopics = new $s2(this.core, this.logger), this.requests = new Ks(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var Fs = Object.defineProperty;
var Qs3 = (S5, o2, t) => o2 in S5 ? Fs(S5, o2, { enumerable: true, configurable: true, writable: true, value: t }) : S5[o2] = t;
var f6 = (S5, o2, t) => Qs3(S5, typeof o2 != "symbol" ? o2 + "" : o2, t);
var fe2 = class _fe extends J {
  constructor(o2) {
    super(o2), f6(this, "protocol", Ve3), f6(this, "version", ke2), f6(this, "name", me3.name), f6(this, "metadata"), f6(this, "core"), f6(this, "logger"), f6(this, "events", new import_events4.EventEmitter()), f6(this, "engine"), f6(this, "session"), f6(this, "proposal"), f6(this, "pendingRequest"), f6(this, "auth"), f6(this, "signConfig"), f6(this, "on", (e, s2) => this.events.on(e, s2)), f6(this, "once", (e, s2) => this.events.once(e, s2)), f6(this, "off", (e, s2) => this.events.off(e, s2)), f6(this, "removeListener", (e, s2) => this.events.removeListener(e, s2)), f6(this, "removeAllListeners", (e) => this.events.removeAllListeners(e)), f6(this, "connect", async (e) => {
      try {
        return await this.engine.connect(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "pair", async (e) => {
      try {
        return await this.engine.pair(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "approve", async (e) => {
      try {
        return await this.engine.approve(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "reject", async (e) => {
      try {
        return await this.engine.reject(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "update", async (e) => {
      try {
        return await this.engine.update(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "extend", async (e) => {
      try {
        return await this.engine.extend(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "request", async (e) => {
      try {
        return await this.engine.request(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "respond", async (e) => {
      try {
        return await this.engine.respond(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "ping", async (e) => {
      try {
        return await this.engine.ping(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "emit", async (e) => {
      try {
        return await this.engine.emit(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "disconnect", async (e) => {
      try {
        return await this.engine.disconnect(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "find", (e) => {
      try {
        return this.engine.find(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }), f6(this, "authenticate", async (e, s2) => {
      try {
        return await this.engine.authenticate(e, s2);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }), f6(this, "formatAuthMessage", (e) => {
      try {
        return this.engine.formatAuthMessage(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "approveSessionAuthenticate", async (e) => {
      try {
        return await this.engine.approveSessionAuthenticate(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), f6(this, "rejectSessionAuthenticate", async (e) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), this.name = (o2 == null ? void 0 : o2.name) || me3.name, this.metadata = ui(o2 == null ? void 0 : o2.metadata), this.signConfig = o2 == null ? void 0 : o2.signConfig;
    const t = typeof (o2 == null ? void 0 : o2.logger) < "u" && typeof (o2 == null ? void 0 : o2.logger) != "string" ? o2.logger : (0, import_pino2.default)(k2({ level: (o2 == null ? void 0 : o2.logger) || me3.logger }));
    this.core = (o2 == null ? void 0 : o2.core) || new ta2(o2), this.logger = E2(t, this.name), this.session = new It3(this.core, this.logger), this.proposal = new Ds2(this.core, this.logger), this.pendingRequest = new Ls2(this.core, this.logger), this.engine = new ks2(this), this.auth = new js2(this.core, this.logger);
  }
  static async init(o2) {
    const t = new _fe(o2);
    return await t.initialize(), t;
  }
  get context() {
    return y2(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o2.message), o2;
    }
  }
};

// node_modules/@reown/appkit/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var Z = "error";
var Fe3 = "wss://relay.walletconnect.org";
var He3 = "wc";
var Ue3 = "universal_provider";
var $2 = `${He3}@2:${Ue3}:`;
var T3 = "https://rpc.walletconnect.org/v1/";
var ee3 = "generic";
var Be3 = `${T3}bundler`;
var y4 = "call_status";
var Le3 = 86400;
var _3 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function x4(t) {
  return t == null || typeof t != "object" && typeof t != "function";
}
function te2(t) {
  return Object.getOwnPropertySymbols(t).filter((e) => Object.prototype.propertyIsEnumerable.call(t, e));
}
function se2(t) {
  return t == null ? t === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t);
}
var Me4 = "[object RegExp]";
var ie3 = "[object String]";
var ne2 = "[object Number]";
var re3 = "[object Boolean]";
var ae3 = "[object Arguments]";
var ze2 = "[object Symbol]";
var Ge3 = "[object Date]";
var We3 = "[object Map]";
var Je3 = "[object Set]";
var Ke4 = "[object Array]";
var Ve4 = "[object ArrayBuffer]";
var Ye3 = "[object Object]";
var Xe3 = "[object DataView]";
var ke3 = "[object Uint8Array]";
var Qe3 = "[object Uint8ClampedArray]";
var Ze3 = "[object Uint16Array]";
var Te2 = "[object Uint32Array]";
var et3 = "[object Int8Array]";
var tt3 = "[object Int16Array]";
var st3 = "[object Int32Array]";
var it = "[object Float32Array]";
var nt2 = "[object Float64Array]";
function F2(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function rt3(t, e) {
  return v4(t, void 0, t, /* @__PURE__ */ new Map(), e);
}
function v4(t, e, s2, i4 = /* @__PURE__ */ new Map(), r2 = void 0) {
  const a2 = r2 == null ? void 0 : r2(t, e, s2, i4);
  if (a2 != null) return a2;
  if (x4(t)) return t;
  if (i4.has(t)) return i4.get(t);
  if (Array.isArray(t)) {
    const n3 = new Array(t.length);
    i4.set(t, n3);
    for (let c5 = 0; c5 < t.length; c5++) n3[c5] = v4(t[c5], c5, s2, i4, r2);
    return Object.hasOwn(t, "index") && (n3.index = t.index), Object.hasOwn(t, "input") && (n3.input = t.input), n3;
  }
  if (t instanceof Date) return new Date(t.getTime());
  if (t instanceof RegExp) {
    const n3 = new RegExp(t.source, t.flags);
    return n3.lastIndex = t.lastIndex, n3;
  }
  if (t instanceof Map) {
    const n3 = /* @__PURE__ */ new Map();
    i4.set(t, n3);
    for (const [c5, o2] of t) n3.set(c5, v4(o2, c5, s2, i4, r2));
    return n3;
  }
  if (t instanceof Set) {
    const n3 = /* @__PURE__ */ new Set();
    i4.set(t, n3);
    for (const c5 of t) n3.add(v4(c5, void 0, s2, i4, r2));
    return n3;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(t)) return t.subarray();
  if (F2(t)) {
    const n3 = new (Object.getPrototypeOf(t)).constructor(t.length);
    i4.set(t, n3);
    for (let c5 = 0; c5 < t.length; c5++) n3[c5] = v4(t[c5], c5, s2, i4, r2);
    return n3;
  }
  if (t instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer) return t.slice(0);
  if (t instanceof DataView) {
    const n3 = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength);
    return i4.set(t, n3), m3(n3, t, s2, i4, r2), n3;
  }
  if (typeof File < "u" && t instanceof File) {
    const n3 = new File([t], t.name, { type: t.type });
    return i4.set(t, n3), m3(n3, t, s2, i4, r2), n3;
  }
  if (t instanceof Blob) {
    const n3 = new Blob([t], { type: t.type });
    return i4.set(t, n3), m3(n3, t, s2, i4, r2), n3;
  }
  if (t instanceof Error) {
    const n3 = new t.constructor();
    return i4.set(t, n3), n3.message = t.message, n3.name = t.name, n3.stack = t.stack, n3.cause = t.cause, m3(n3, t, s2, i4, r2), n3;
  }
  if (typeof t == "object" && at(t)) {
    const n3 = Object.create(Object.getPrototypeOf(t));
    return i4.set(t, n3), m3(n3, t, s2, i4, r2), n3;
  }
  return t;
}
function m3(t, e, s2 = t, i4, r2) {
  const a2 = [...Object.keys(e), ...te2(e)];
  for (let n3 = 0; n3 < a2.length; n3++) {
    const c5 = a2[n3], o2 = Object.getOwnPropertyDescriptor(t, c5);
    (o2 == null || o2.writable) && (t[c5] = v4(e[c5], c5, s2, i4, r2));
  }
}
function at(t) {
  switch (se2(t)) {
    case ae3:
    case Ke4:
    case Ve4:
    case Xe3:
    case re3:
    case Ge3:
    case it:
    case nt2:
    case et3:
    case tt3:
    case st3:
    case We3:
    case ne2:
    case Ye3:
    case Me4:
    case Je3:
    case ie3:
    case ze2:
    case ke3:
    case Qe3:
    case Ze3:
    case Te2:
      return true;
    default:
      return false;
  }
}
function ct3(t, e) {
  return rt3(t, (s2, i4, r2, a2) => {
    const n3 = e == null ? void 0 : e(s2, i4, r2, a2);
    if (n3 != null) return n3;
    if (typeof t == "object") switch (Object.prototype.toString.call(t)) {
      case ne2:
      case ie3:
      case re3: {
        const c5 = new t.constructor(t == null ? void 0 : t.valueOf());
        return m3(c5, t), c5;
      }
      case ae3: {
        const c5 = {};
        return m3(c5, t), c5.length = t.length, c5[Symbol.iterator] = t[Symbol.iterator], c5;
      }
      default:
        return;
    }
  });
}
function ce2(t) {
  return ct3(t);
}
function oe3(t) {
  return t !== null && typeof t == "object" && se2(t) === "[object Arguments]";
}
function pe4(t) {
  return typeof t == "object" && t !== null;
}
function ot2() {
}
function pt3(t) {
  return F2(t);
}
function ht2(t) {
  var _a2;
  if (typeof t != "object" || t == null) return false;
  if (Object.getPrototypeOf(t) === null) return true;
  if (Object.prototype.toString.call(t) !== "[object Object]") {
    const s2 = t[Symbol.toStringTag];
    return s2 == null || !((_a2 = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) == null ? void 0 : _a2.writable) ? false : t.toString() === `[object ${s2}]`;
  }
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
function lt3(t) {
  if (x4(t)) return t;
  if (Array.isArray(t) || F2(t) || t instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer) return t.slice(0);
  const e = Object.getPrototypeOf(t), s2 = e.constructor;
  if (t instanceof Date || t instanceof Map || t instanceof Set) return new s2(t);
  if (t instanceof RegExp) {
    const i4 = new s2(t);
    return i4.lastIndex = t.lastIndex, i4;
  }
  if (t instanceof DataView) return new s2(t.buffer.slice(0));
  if (t instanceof Error) {
    const i4 = new s2(t.message);
    return i4.stack = t.stack, i4.name = t.name, i4.cause = t.cause, i4;
  }
  if (typeof File < "u" && t instanceof File) return new s2([t], t.name, { type: t.type, lastModified: t.lastModified });
  if (typeof t == "object") {
    const i4 = Object.create(e);
    return Object.assign(i4, t);
  }
  return t;
}
function ut3(t, ...e) {
  const s2 = e.slice(0, -1), i4 = e[e.length - 1];
  let r2 = t;
  for (let a2 = 0; a2 < s2.length; a2++) {
    const n3 = s2[a2];
    r2 = A3(r2, n3, i4, /* @__PURE__ */ new Map());
  }
  return r2;
}
function A3(t, e, s2, i4) {
  if (x4(t) && (t = Object(t)), e == null || typeof e != "object") return t;
  if (i4.has(e)) return lt3(i4.get(e));
  if (i4.set(e, t), Array.isArray(e)) {
    e = e.slice();
    for (let a2 = 0; a2 < e.length; a2++) e[a2] = e[a2] ?? void 0;
  }
  const r2 = [...Object.keys(e), ...te2(e)];
  for (let a2 = 0; a2 < r2.length; a2++) {
    const n3 = r2[a2];
    let c5 = e[n3], o2 = t[n3];
    if (oe3(c5) && (c5 = { ...c5 }), oe3(o2) && (o2 = { ...o2 }), typeof Buffer < "u" && Buffer.isBuffer(c5) && (c5 = ce2(c5)), Array.isArray(c5)) if (typeof o2 == "object" && o2 != null) {
      const l4 = [], p3 = Reflect.ownKeys(o2);
      for (let f7 = 0; f7 < p3.length; f7++) {
        const u2 = p3[f7];
        l4[u2] = o2[u2];
      }
      o2 = l4;
    } else o2 = [];
    const h4 = s2(o2, c5, n3, t, e, i4);
    h4 != null ? t[n3] = h4 : Array.isArray(c5) || pe4(o2) && pe4(c5) ? t[n3] = A3(o2, c5, s2, i4) : o2 == null && ht2(c5) ? t[n3] = A3({}, c5, s2, i4) : o2 == null && pt3(c5) ? t[n3] = ce2(c5) : (o2 === void 0 || c5 !== void 0) && (t[n3] = c5);
  }
  return t;
}
function dt3(t, ...e) {
  return ut3(t, ...e, ot2);
}
var ft3 = Object.defineProperty;
var mt3 = Object.defineProperties;
var gt3 = Object.getOwnPropertyDescriptors;
var he3 = Object.getOwnPropertySymbols;
var yt3 = Object.prototype.hasOwnProperty;
var vt3 = Object.prototype.propertyIsEnumerable;
var le3 = (t, e, s2) => e in t ? ft3(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var E3 = (t, e) => {
  for (var s2 in e || (e = {})) yt3.call(e, s2) && le3(t, s2, e[s2]);
  if (he3) for (var s2 of he3(e)) vt3.call(e, s2) && le3(t, s2, e[s2]);
  return t;
};
var wt3 = (t, e) => mt3(t, gt3(e));
function ue(t, e, s2) {
  var i4;
  const r2 = Je(t);
  return ((i4 = e.rpcMap) == null ? void 0 : i4[r2.reference]) || `${T3}?chainId=${r2.namespace}:${r2.reference}&projectId=${s2}`;
}
function bt2(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function de2(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function Pt3(t, e) {
  const s2 = Object.keys(e.namespaces).filter((r2) => r2.includes(t));
  if (!s2.length) return [];
  const i4 = [];
  return s2.forEach((r2) => {
    const a2 = e.namespaces[r2].accounts;
    i4.push(...a2);
  }), i4;
}
function fe3(t) {
  return Object.fromEntries(Object.entries(t).filter(([e, s2]) => {
    var i4, r2;
    return ((i4 = s2 == null ? void 0 : s2.chains) == null ? void 0 : i4.length) && ((r2 = s2 == null ? void 0 : s2.chains) == null ? void 0 : r2.length) > 0;
  }));
}
function j2(t = {}, e = {}) {
  const s2 = fe3(me4(t)), i4 = fe3(me4(e));
  return dt3(s2, i4);
}
function me4(t) {
  var e, s2, i4, r2, a2;
  const n3 = {};
  if (!Ye(t)) return n3;
  for (const [c5, o2] of Object.entries(t)) {
    const h4 = Gn(c5) ? [c5] : o2.chains, l4 = o2.methods || [], p3 = o2.events || [], f7 = o2.rpcMap || {}, u2 = bs(c5);
    n3[u2] = wt3(E3(E3({}, n3[u2]), o2), { chains: ut(h4, (e = n3[u2]) == null ? void 0 : e.chains), methods: ut(l4, (s2 = n3[u2]) == null ? void 0 : s2.methods), events: ut(p3, (i4 = n3[u2]) == null ? void 0 : i4.events) }), (Ye(f7) || Ye(((r2 = n3[u2]) == null ? void 0 : r2.rpcMap) || {})) && (n3[u2].rpcMap = E3(E3({}, f7), (a2 = n3[u2]) == null ? void 0 : a2.rpcMap));
  }
  return n3;
}
function ge2(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function ye3(t) {
  const e = {};
  for (const [s2, i4] of Object.entries(t)) {
    const r2 = i4.methods || [], a2 = i4.events || [], n3 = i4.accounts || [], c5 = Gn(s2) ? [s2] : i4.chains ? i4.chains : de2(i4.accounts);
    e[s2] = { chains: c5, methods: r2, events: a2, accounts: n3 };
  }
  return e;
}
function H(t) {
  return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t));
}
function Ot3(t) {
  try {
    const e = JSON.parse(t);
    return typeof e == "object" && e !== null && !Array.isArray(e);
  } catch {
    return false;
  }
}
var ve3 = {};
var w2 = (t) => ve3[t];
var U3 = (t, e) => {
  ve3[t] = e;
};
var It4 = Object.defineProperty;
var we4 = Object.getOwnPropertySymbols;
var St4 = Object.prototype.hasOwnProperty;
var $t3 = Object.prototype.propertyIsEnumerable;
var be3 = (t, e, s2) => e in t ? It4(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var Pe3 = (t, e) => {
  for (var s2 in e || (e = {})) St4.call(e, s2) && be3(t, s2, e[s2]);
  if (we4) for (var s2 of we4(e)) $t3.call(e, s2) && be3(t, s2, e[s2]);
  return t;
};
var Oe3 = "eip155";
var At3 = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"];
var Et3 = (t) => t && t.startsWith("0x") ? BigInt(t).toString(10) : t;
var B3 = (t) => t && t.startsWith("0x") ? t : `0x${BigInt(t).toString(16)}`;
var Ie2 = (t) => Object.keys(t).filter((e) => At3.includes(e)).reduce((e, s2) => (e[s2] = jt3(t[s2]), e), {});
var jt3 = (t) => typeof t == "string" && Ot3(t) ? JSON.parse(t) : t;
var Ct3 = (t, e, s2) => {
  const { sessionProperties: i4 = {}, scopedProperties: r2 = {} } = t, a2 = {};
  if (!Ye(r2) && !Ye(i4)) return;
  const n3 = Ie2(i4);
  for (const c5 of s2) {
    const o2 = Et3(c5);
    if (!o2) continue;
    a2[B3(o2)] = n3;
    const h4 = r2 == null ? void 0 : r2[`${Oe3}:${o2}`];
    if (h4) {
      const l4 = h4 == null ? void 0 : h4[`${Oe3}:${o2}:${e}`];
      a2[B3(o2)] = Pe3(Pe3({}, a2[B3(o2)]), Ie2(l4 || h4));
    }
  }
  for (const [c5, o2] of Object.entries(a2)) Object.keys(o2).length === 0 && delete a2[c5];
  return Object.keys(a2).length > 0 ? a2 : void 0;
};
var Nt3 = Object.defineProperty;
var Dt2 = (t, e, s2) => e in t ? Nt3(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var qt3 = (t, e, s2) => Dt2(t, typeof e != "symbol" ? e + "" : e, s2);
var L2;
var J4 = class _J {
  constructor(e) {
    qt3(this, "storage"), this.storage = e;
  }
  async getItem(e) {
    return await this.storage.getItem(e);
  }
  async setItem(e, s2) {
    return await this.storage.setItem(e, s2);
  }
  async removeItem(e) {
    return await this.storage.removeItem(e);
  }
  static getStorage(e) {
    return L2 || (L2 = new _J(e)), L2;
  }
};
var Rt4 = Object.defineProperty;
var _t3 = Object.defineProperties;
var xt3 = Object.getOwnPropertyDescriptors;
var Se2 = Object.getOwnPropertySymbols;
var Ft3 = Object.prototype.hasOwnProperty;
var Ht3 = Object.prototype.propertyIsEnumerable;
var $e3 = (t, e, s2) => e in t ? Rt4(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var Ut3 = (t, e) => {
  for (var s2 in e || (e = {})) Ft3.call(e, s2) && $e3(t, s2, e[s2]);
  if (Se2) for (var s2 of Se2(e)) Ht3.call(e, s2) && $e3(t, s2, e[s2]);
  return t;
};
var Bt3 = (t, e) => _t3(t, xt3(e));
async function Lt3(t, e) {
  const s2 = Je(t.result.capabilities.caip345.caip2), i4 = t.result.capabilities.caip345.transactionHashes, r2 = await Promise.allSettled(i4.map((p3) => Mt3(s2.reference, p3, e))), a2 = r2.filter((p3) => p3.status === "fulfilled").map((p3) => p3.value).filter((p3) => p3);
  r2.filter((p3) => p3.status === "rejected").forEach((p3) => console.warn("Failed to fetch transaction receipt:", p3.reason));
  const n3 = !a2.length || a2.some((p3) => !p3), c5 = a2.every((p3) => (p3 == null ? void 0 : p3.status) === "0x1"), o2 = a2.every((p3) => (p3 == null ? void 0 : p3.status) === "0x0"), h4 = a2.some((p3) => (p3 == null ? void 0 : p3.status) === "0x0");
  let l4;
  return n3 ? l4 = 100 : c5 ? l4 = 200 : o2 ? l4 = 500 : h4 && (l4 = 600), { id: t.result.id, version: t.request.version, atomic: t.request.atomicRequired, chainId: t.request.chainId, capabilities: t.result.capabilities, receipts: a2, status: l4 };
}
async function Mt3(t, e, s2) {
  return await s2(parseInt(t)).request(formatJsonRpcRequest("eth_getTransactionReceipt", [e]));
}
async function zt3({ sendCalls: t, storage: e }) {
  const s2 = await e.getItem(y4);
  await e.setItem(y4, Bt3(Ut3({}, s2), { [t.result.id]: { request: t.request, result: t.result, expiry: Si(Le3) } }));
}
async function Gt3({ resultId: t, storage: e }) {
  const s2 = await e.getItem(y4);
  if (s2) {
    delete s2[t], await e.setItem(y4, s2);
    for (const i4 in s2) Oi(s2[i4].expiry) && delete s2[i4];
    await e.setItem(y4, s2);
  }
}
async function Wt3({ resultId: t, storage: e }) {
  const s2 = await e.getItem(y4), i4 = s2 == null ? void 0 : s2[t];
  if (i4 && !Oi(i4.expiry)) return i4;
  await Gt3({ resultId: t, storage: e });
}
var Jt3 = Object.defineProperty;
var Kt3 = Object.defineProperties;
var Vt3 = Object.getOwnPropertyDescriptors;
var Ae3 = Object.getOwnPropertySymbols;
var Yt2 = Object.prototype.hasOwnProperty;
var Xt3 = Object.prototype.propertyIsEnumerable;
var M4 = (t, e, s2) => e in t ? Jt3(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var z5 = (t, e) => {
  for (var s2 in e || (e = {})) Yt2.call(e, s2) && M4(t, s2, e[s2]);
  if (Ae3) for (var s2 of Ae3(e)) Xt3.call(e, s2) && M4(t, s2, e[s2]);
  return t;
};
var G3 = (t, e) => Kt3(t, Vt3(e));
var g3 = (t, e, s2) => M4(t, typeof e != "symbol" ? e + "" : e, s2);
var kt3 = class {
  constructor(e) {
    g3(this, "name", "eip155"), g3(this, "client"), g3(this, "chainId"), g3(this, "namespace"), g3(this, "httpProviders"), g3(this, "events"), g3(this, "storage"), this.namespace = e.namespace, this.events = w2("events"), this.client = w2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain()), this.storage = J4.getStorage(this.client.core.storage);
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
      case "wallet_sendCalls":
        return await this.sendCalls(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, s2) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), s2);
    const i4 = this.chainId;
    this.chainId = parseInt(e), this.events.emit(_3.DEFAULT_CHAIN_CHANGED, { currentCaipChainId: `${this.name}:${e}`, previousCaipChainId: `${this.name}:${i4}` });
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, s2) {
    const i4 = s2 || ue(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i4, w2("disableProviderPing")));
  }
  setHttpProvider(e, s2) {
    const i4 = this.createHttpProvider(e, s2);
    i4 && (this.httpProviders[e] = i4);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((s2) => {
      var i4;
      const r2 = parseInt(bt2(s2));
      e[r2] = this.createHttpProvider(r2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[s2]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((s2) => s2.split(":")[1] === this.chainId.toString()).map((s2) => s2.split(":")[2]))] : [];
  }
  getHttpProvider(e) {
    const s2 = e || this.chainId;
    return this.httpProviders[s2] || (this.httpProviders = G3(z5({}, this.httpProviders), { [s2]: this.createHttpProvider(s2) }), this.httpProviders[s2]);
  }
  async handleSwitchChain(e) {
    var s2, i4;
    let r2 = e.request.params ? (s2 = e.request.params[0]) == null ? void 0 : s2.chainId : "0x0";
    r2 = r2.startsWith("0x") ? r2 : `0x${r2}`;
    const a2 = parseInt(r2, 16);
    if (this.isChainApproved(a2)) this.setDefaultChain(`${a2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: r2 }] }, chainId: (i4 = this.namespace.chains) == null ? void 0 : i4[0] }), this.setDefaultChain(`${a2}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var s2, i4, r2, a2, n3;
    const c5 = (i4 = (s2 = e.request) == null ? void 0 : s2.params) == null ? void 0 : i4[0], o2 = ((a2 = (r2 = e.request) == null ? void 0 : r2.params) == null ? void 0 : a2[1]) || [];
    if (!c5) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const h4 = this.client.session.get(e.topic), l4 = ((n3 = h4 == null ? void 0 : h4.sessionProperties) == null ? void 0 : n3.capabilities) || {}, p3 = `${c5}${o2.join(",")}`, f7 = l4 == null ? void 0 : l4[p3];
    if (f7) return f7;
    let u2;
    try {
      u2 = Ct3(h4, c5, o2);
    } catch (D2) {
      console.warn("Failed to extract capabilities from session", D2);
    }
    if (u2) return u2;
    const K5 = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: G3(z5({}, h4.sessionProperties || {}), { capabilities: G3(z5({}, l4 || {}), { [p3]: K5 }) }) });
    } catch (D2) {
      console.warn("Failed to update session with capabilities", D2);
    }
    return K5;
  }
  async getCallStatus(e) {
    var s2, i4, r2;
    const a2 = this.client.session.get(e.topic), n3 = (s2 = a2.sessionProperties) == null ? void 0 : s2.bundler_name;
    if (n3) {
      const h4 = this.getBundlerUrl(e.chainId, n3);
      try {
        return await this.getUserOperationReceipt(h4, e);
      } catch (l4) {
        console.warn("Failed to fetch call status from bundler", l4, h4);
      }
    }
    const c5 = (i4 = a2.sessionProperties) == null ? void 0 : i4.bundler_url;
    if (c5) try {
      return await this.getUserOperationReceipt(c5, e);
    } catch (h4) {
      console.warn("Failed to fetch call status from custom bundler", h4, c5);
    }
    const o2 = await Wt3({ resultId: (r2 = e.request.params) == null ? void 0 : r2[0], storage: this.storage });
    if (o2) try {
      return await Lt3(o2, this.getHttpProvider.bind(this));
    } catch (h4) {
      console.warn("Failed to fetch call status from stored send calls", h4, o2);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, s2) {
    var i4;
    const r2 = new URL(e), a2 = await fetch(r2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i4 = s2.request.params) == null ? void 0 : i4[0]])) });
    if (!a2.ok) throw new Error(`Failed to fetch user operation receipt - ${a2.status}`);
    return await a2.json();
  }
  getBundlerUrl(e, s2) {
    return `${Be3}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${s2}`;
  }
  async sendCalls(e) {
    var s2, i4, r2;
    const a2 = await this.client.request(e), n3 = (s2 = e.request.params) == null ? void 0 : s2[0], c5 = a2 == null ? void 0 : a2.id, o2 = (a2 == null ? void 0 : a2.capabilities) || {}, h4 = (i4 = o2 == null ? void 0 : o2.caip345) == null ? void 0 : i4.caip2, l4 = (r2 = o2 == null ? void 0 : o2.caip345) == null ? void 0 : r2.transactionHashes;
    return !c5 || !h4 || !(l4 != null && l4.length) || await zt3({ sendCalls: { request: n3, result: a2 }, storage: this.storage }), a2;
  }
};
var Qt3 = Object.defineProperty;
var Zt3 = (t, e, s2) => e in t ? Qt3(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var b3 = (t, e, s2) => Zt3(t, typeof e != "symbol" ? e + "" : e, s2);
var Tt3 = class {
  constructor(e) {
    b3(this, "name", ee3), b3(this, "client"), b3(this, "httpProviders"), b3(this, "events"), b3(this, "namespace"), b3(this, "chainId"), this.namespace = e.namespace, this.events = w2("events"), this.client = w2("client"), this.chainId = this.getDefaultChain(), this.name = this.getNamespaceName(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, s2) {
    this.httpProviders[e] || this.setHttpProvider(e, s2);
    const i4 = this.chainId;
    this.chainId = e, this.events.emit(_3.DEFAULT_CHAIN_CHANGED, { currentCaipChainId: `${this.name}:${e}`, previousCaipChainId: `${this.name}:${i4}` });
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getNamespaceName() {
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return Je(e).namespace;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((s2) => s2.split(":")[1] === this.chainId.toString()).map((s2) => s2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, s2;
    const i4 = {};
    return (s2 = (e = this.namespace) == null ? void 0 : e.accounts) == null || s2.forEach((r2) => {
      var a2, n3;
      const c5 = Je(r2), o2 = (n3 = (a2 = this.namespace) == null ? void 0 : a2.rpcMap) == null ? void 0 : n3[`${c5.namespace}:${c5.reference}`];
      i4[c5.reference] = this.createHttpProvider(r2, o2);
    }), i4;
  }
  getHttpProvider(e) {
    const s2 = Je(e).reference, i4 = this.httpProviders[s2];
    if (typeof i4 > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return i4;
  }
  setHttpProvider(e, s2) {
    const i4 = this.createHttpProvider(e, s2);
    i4 && (this.httpProviders[e] = i4);
  }
  createHttpProvider(e, s2) {
    const i4 = s2 || ue(e, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new o(new f2(i4, w2("disableProviderPing")));
  }
};
var es2 = Object.defineProperty;
var ts2 = Object.defineProperties;
var ss2 = Object.getOwnPropertyDescriptors;
var Ee2 = Object.getOwnPropertySymbols;
var is2 = Object.prototype.hasOwnProperty;
var ns2 = Object.prototype.propertyIsEnumerable;
var W3 = (t, e, s2) => e in t ? es2(t, e, { enumerable: true, configurable: true, writable: true, value: s2 }) : t[e] = s2;
var S4 = (t, e) => {
  for (var s2 in e || (e = {})) is2.call(e, s2) && W3(t, s2, e[s2]);
  if (Ee2) for (var s2 of Ee2(e)) ns2.call(e, s2) && W3(t, s2, e[s2]);
  return t;
};
var C5 = (t, e) => ts2(t, ss2(e));
var d4 = (t, e, s2) => W3(t, typeof e != "symbol" ? e + "" : e, s2);
var N3 = class _N {
  constructor(e) {
    d4(this, "client"), d4(this, "namespaces"), d4(this, "optionalNamespaces"), d4(this, "sessionProperties"), d4(this, "scopedProperties"), d4(this, "events", new import_events5.default()), d4(this, "rpcProviders", {}), d4(this, "session"), d4(this, "providerOpts"), d4(this, "logger"), d4(this, "uri"), d4(this, "disableProviderPing", false), this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : (0, import_pino2.default)(k2({ level: (e == null ? void 0 : e.logger) || Z })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || false;
  }
  static async init(e) {
    const s2 = new _N(e);
    return await s2.initialize(), s2;
  }
  async request(e, s2, i4) {
    const [r2, a2] = this.validateChain(s2);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(r2).request({ request: S4({}, e), chainId: `${r2}:${a2}`, topic: this.session.topic, expiry: i4 });
  }
  sendAsync(e, s2, i4, r2) {
    const a2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, i4, r2).then((n3) => s2(null, formatJsonRpcResult(a2, n3))).catch((n3) => s2(n3, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: zt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, s2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: i4, response: r2 } = await this.client.authenticate(e, s2);
    i4 && (this.uri = i4, this.events.emit("display_uri", i4));
    const a2 = await r2();
    if (this.session = a2.session, this.session) {
      const n3 = ye3(this.session.namespaces);
      this.namespaces = j2(this.namespaces, n3), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a2;
  }
  on(e, s2) {
    this.events.on(e, s2);
  }
  once(e, s2) {
    this.events.once(e, s2);
  }
  removeListener(e, s2) {
    this.events.removeListener(e, s2);
  }
  off(e, s2) {
    this.events.off(e, s2);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(e) {
    const { uri: s2, approval: i4 } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    s2 && (this.uri = s2, this.events.emit("display_uri", s2));
    const r2 = await i4();
    this.session = r2;
    const a2 = ye3(r2.namespaces);
    return this.namespaces = j2(this.namespaces, a2), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(e, s2) {
    try {
      if (!this.session) return;
      const [i4, r2] = this.validateChain(e);
      this.getProvider(i4).setDefaultChain(r2, s2);
    } catch (i4) {
      if (!/Please call connect/.test(i4.message)) throw i4;
    }
  }
  async cleanupPendingPairings(e = {}) {
    try {
      this.logger.info("Cleaning up inactive pairings...");
      const s2 = this.client.pairing.getAll();
      if (!Ee(s2)) return;
      for (const i4 of s2) e.deletePairings ? this.client.core.expirer.set(i4.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i4.topic);
      this.logger.info(`Inactive pairings cleared: ${s2.length}`);
    } catch (s2) {
      this.logger.warn("Failed to cleanup pending pairings", s2);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var e, s2;
    if (this.client = this.providerOpts.client || await fe2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || Z, relayUrl: this.providerOpts.relayUrl || Fe3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i4) {
      throw this.logger.error("Failed to get session", i4), new Error(`The provided session: ${(s2 = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : s2.topic} doesn't exist in the Sign client`);
    }
    else {
      const i4 = this.client.session.getAll();
      this.session = i4[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((s2) => bs(s2)))];
    U3("client", this.client), U3("events", this.events), U3("disableProviderPing", this.disableProviderPing), e.forEach((s2) => {
      if (!this.session) return;
      const i4 = Pt3(s2, this.session);
      if ((i4 == null ? void 0 : i4.length) === 0) return;
      const r2 = de2(i4), a2 = j2(this.namespaces, this.optionalNamespaces), n3 = C5(S4({}, a2[s2]), { accounts: i4, chains: r2 });
      switch (s2) {
        case "eip155":
          this.rpcProviders[s2] = new kt3({ namespace: n3 });
          break;
        default:
          this.rpcProviders[s2] = new Tt3({ namespace: n3 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      var s2;
      const { topic: i4 } = e;
      i4 === ((s2 = this.session) == null ? void 0 : s2.topic) && this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      var s2;
      const { params: i4, topic: r2 } = e;
      if (r2 !== ((s2 = this.session) == null ? void 0 : s2.topic)) return;
      const { event: a2 } = i4;
      if (a2.name === "accountsChanged") {
        const n3 = a2.data;
        n3 && Ee(n3) && this.events.emit("accountsChanged", n3.map(ge2));
      } else if (a2.name === "chainChanged") {
        const n3 = i4.chainId, c5 = i4.event.data, o2 = bs(n3), h4 = H(n3) !== H(c5) ? `${o2}:${H(c5)}` : n3;
        this.onChainChanged({ currentCaipChainId: h4 });
      } else this.events.emit(a2.name, a2.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: s2 }) => {
      var i4, r2;
      if (e !== ((i4 = this.session) == null ? void 0 : i4.topic)) return;
      const { namespaces: a2 } = s2, n3 = (r2 = this.client) == null ? void 0 : r2.session.get(e);
      this.session = C5(S4({}, n3), { namespaces: a2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: s2 });
    }), this.client.on("session_delete", async (e) => {
      var s2;
      e.topic === ((s2 = this.session) == null ? void 0 : s2.topic) && (await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", C5(S4({}, zt("USER_DISCONNECTED")), { data: e.topic })));
    }), this.on(_3.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(C5(S4({}, e), { internal: true }));
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[ee3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var s2;
      this.getProvider(e).updateNamespace((s2 = this.session) == null ? void 0 : s2.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: s2 = {}, optionalNamespaces: i4 = {}, sessionProperties: r2, scopedProperties: a2 } = e;
    this.optionalNamespaces = j2(s2, i4), this.sessionProperties = r2, this.scopedProperties = a2;
  }
  validateChain(e) {
    const [s2, i4] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [s2, i4];
    if (s2 && !Object.keys(this.namespaces || {}).map((n3) => bs(n3)).includes(s2)) throw new Error(`Namespace '${s2}' is not configured. Please call connect() first with namespace config.`);
    if (s2 && i4) return [s2, i4];
    const r2 = bs(Object.keys(this.namespaces)[0]), a2 = this.rpcProviders[r2].getDefaultChain();
    return [r2, a2];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  async onChainChanged({ currentCaipChainId: e, previousCaipChainId: s2, internal: i4 = false }) {
    if (!this.namespaces) return;
    const [r2, a2] = this.validateChain(e);
    a2 && (this.updateNamespaceChain(r2, a2), i4 ? (this.events.emit("chainChanged", a2), this.emitAccountsChangedOnChainChange({ namespace: r2, currentCaipChainId: e, previousCaipChainId: s2 })) : this.getProvider(r2).setDefaultChain(a2), await this.persist("namespaces", this.namespaces));
  }
  emitAccountsChangedOnChainChange({ namespace: e, currentCaipChainId: s2, previousCaipChainId: i4 }) {
    var r2, a2;
    try {
      if (i4 === s2) return;
      const n3 = (a2 = (r2 = this.session) == null ? void 0 : r2.namespaces[e]) == null ? void 0 : a2.accounts;
      if (!n3) return;
      const c5 = n3.filter((o2) => o2.includes(`${s2}:`)).map(ge2);
      if (!Ee(c5)) return;
      this.events.emit("accountsChanged", c5);
    } catch (n3) {
      this.logger.warn("Failed to emit accountsChanged on chain change", n3);
    }
  }
  updateNamespaceChain(e, s2) {
    if (!this.namespaces) return;
    const i4 = this.namespaces[e] ? e : `${e}:${s2}`, r2 = { chains: [], methods: [], events: [], defaultChain: s2 };
    this.namespaces[i4] ? this.namespaces[i4] && (this.namespaces[i4].defaultChain = s2) : this.namespaces[i4] = r2;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(e, s2) {
    var i4;
    const r2 = ((i4 = this.session) == null ? void 0 : i4.topic) || "";
    await this.client.core.storage.setItem(`${$2}/${e}${r2}`, s2);
  }
  async getFromStore(e) {
    var s2;
    const i4 = ((s2 = this.session) == null ? void 0 : s2.topic) || "";
    return await this.client.core.storage.getItem(`${$2}/${e}${i4}`);
  }
  async deleteFromStore(e) {
    var s2;
    const i4 = ((s2 = this.session) == null ? void 0 : s2.topic) || "";
    await this.client.core.storage.removeItem(`${$2}/${e}${i4}`);
  }
  async cleanupStorage() {
    var e;
    try {
      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
      const s2 = await this.client.core.storage.getKeys();
      for (const i4 of s2) i4.startsWith($2) && await this.client.core.storage.removeItem(i4);
    } catch (s2) {
      this.logger.warn("Failed to cleanup storage", s2);
    }
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string = value.startsWith("0x") ? value.slice(2) : value;
    const number = parseInt(string, 16);
    return number;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    var _a2, _b;
    const rpcUrls = ((_a2 = caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _a2.http) || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [(_b = caipNetwork.blockExplorers) == null ? void 0 : _b.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/bitcoin/BitcoinConstantsUtil.js
var BitcoinConstantsUtil = {
  ACCOUNT_INDEXES: {
    PAYMENT: 0,
    ORDINAL: 1
  }
};

// node_modules/viem/_esm/chains/definitions/0g.js
var zeroG = defineChain({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/0gGalileoTestnet.js
var zeroGGalileoTestnet = defineChain({
  id: 16601,
  name: "0G Galileo Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-galileo.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/0gMainnet.js
var zeroGMainnet = defineChain({
  id: 16661,
  name: "0G Mainnet",
  nativeCurrency: { name: "0G", symbol: "0G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan.0g.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/0gTestnet.js
var zeroGTestnet = defineChain({
  id: 16602,
  name: "0G Galileo Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-galileo.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/5ireChain.js
var fireChain = defineChain({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/abey.js
var abey = defineChain({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/zksync/constants/number.js
var gasPerPubdataDefault = 50000n;
var maxBytecodeSize = maxUint16 * 32n;

// node_modules/viem/_esm/zksync/formatters.js
var formatters = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        var _a3;
        if (typeof transaction === "string")
          return transaction;
        const formatted = (_a3 = formatters.transaction) == null ? void 0 : _a3.format(transaction);
        if (formatted.typeHex === "0x71")
          formatted.type = "eip712";
        else if (formatted.typeHex === "0xff")
          formatted.type = "priority";
        return formatted;
      });
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt(args.l1BatchTimestamp) : null,
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x71")
        transaction.type = "eip712";
      else if (args.type === "0xff")
        transaction.type = "priority";
      return {
        ...transaction,
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null,
        logs: args.logs.map((log) => {
          return {
            ...formatLog(log),
            l1BatchNumber: log.l1BatchNumber ? hexToBigInt(log.l1BatchNumber) : null,
            transactionLogIndex: hexToNumber(log.transactionLogIndex),
            logType: log.logType
          };
        }),
        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
          return {
            blockNumber: hexToBigInt(l2ToL1Log.blockHash),
            blockHash: l2ToL1Log.blockHash,
            l1BatchNumber: l2ToL1Log.l1BatchNumber ? hexToBigInt(l2ToL1Log.l1BatchNumber) : null,
            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),
            shardId: hexToBigInt(l2ToL1Log.shardId),
            isService: l2ToL1Log.isService,
            sender: l2ToL1Log.sender,
            key: l2ToL1Log.key,
            value: l2ToL1Log.value,
            transactionHash: l2ToL1Log.transactionHash,
            logIndex: hexToBigInt(l2ToL1Log.logIndex)
          };
        })
      };
    }
  }),
  transactionRequest: defineTransactionRequest({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(args) {
      if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
        return {
          eip712Meta: {
            ...args.gasPerPubdata ? { gasPerPubdata: toHex(args.gasPerPubdata) } : { gasPerPubdata: toHex(gasPerPubdataDefault) },
            ...args.paymaster && args.paymasterInput ? {
              paymasterParams: {
                paymaster: args.paymaster,
                paymasterInput: Array.from(hexToBytes(args.paymasterInput))
              }
            } : {},
            ...args.factoryDeps ? {
              factoryDeps: args.factoryDeps.map((dep) => Array.from(hexToBytes(dep)))
            } : {},
            ...args.customSignature ? {
              customSignature: Array.from(hexToBytes(args.customSignature))
            } : {}
          },
          type: "0x71"
        };
      return {};
    }
  })
};

// node_modules/viem/_esm/zksync/errors/transaction.js
var InvalidEip712TransactionError = class extends BaseError {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join("\n"), { name: "InvalidEip712TransactionError" });
  }
};

// node_modules/viem/_esm/zksync/utils/isEip712Transaction.js
function isEIP712Transaction(transaction) {
  if (transaction.type === "eip712")
    return true;
  if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
    return true;
  return false;
}

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
function assertEip712Transaction(transaction) {
  const { chainId, to: to3, from: from6, paymaster, paymasterInput } = transaction;
  if (!isEIP712Transaction(transaction))
    throw new InvalidEip712TransactionError();
  if (!chainId || chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
  if (from6 && !isAddress(from6))
    throw new InvalidAddressError({ address: from6 });
  if (paymaster && !isAddress(paymaster))
    throw new InvalidAddressError({ address: paymaster });
  if (paymaster && !paymasterInput) {
    throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
  }
  if (!paymaster && paymasterInput) {
    throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
  }
}

// node_modules/viem/_esm/zksync/serializers.js
function serializeTransaction3(transaction, signature) {
  if (isEIP712Transaction(transaction))
    return serializeTransactionEIP712(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction3
};
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to: to3, from: from6, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  assertEip712Transaction(transaction);
  const serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to3 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    toHex(chainId),
    toHex(""),
    toHex(""),
    toHex(chainId),
    from6 ?? "0x",
    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex([
    "0x71",
    toRlp(serializedTransaction)
  ]);
}

// node_modules/viem/_esm/zksync/errors/bytecode.js
var BytecodeLengthExceedsMaxSizeError = class extends BaseError {
  constructor({ givenLength, maxBytecodeSize: maxBytecodeSize2 }) {
    super(`Bytecode cannot be longer than ${maxBytecodeSize2} bytes. Given length: ${givenLength}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
};
var BytecodeLengthInWordsMustBeOddError = class extends BaseError {
  constructor({ givenLengthInWords }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
};
var BytecodeLengthMustBeDivisibleBy32Error = class extends BaseError {
  constructor({ givenLength }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
};

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
function hashBytecode(bytecode) {
  const bytecodeBytes = toBytes(bytecode);
  if (bytecodeBytes.length % 32 !== 0)
    throw new BytecodeLengthMustBeDivisibleBy32Error({
      givenLength: bytecodeBytes.length
    });
  if (bytecodeBytes.length > maxBytecodeSize)
    throw new BytecodeLengthExceedsMaxSizeError({
      givenLength: bytecodeBytes.length,
      maxBytecodeSize
    });
  const hashStr = sha256(bytecodeBytes);
  const hash = toBytes(hashStr);
  const bytecodeLengthInWords = bytecodeBytes.length / 32;
  if (bytecodeLengthInWords % 2 === 0) {
    throw new BytecodeLengthInWordsMustBeOddError({
      givenLengthInWords: bytecodeLengthInWords
    });
  }
  const bytecodeLength = toBytes(bytecodeLengthInWords);
  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });
  const codeHashVersion = new Uint8Array([1, 0]);
  hash.set(codeHashVersion, 0);
  hash.set(bytecodeLengthPadded, 2);
  return hash;
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
var getEip712Domain2 = (transaction) => {
  assertEip712Transaction(transaction);
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to: to3, from: from6, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from6),
    to: to3 ? BigInt(to3) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ?? "0x",
    factoryDeps: (factoryDeps == null ? void 0 : factoryDeps.map((dep) => toHex(hashBytecode(dep)))) ?? [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/viem/_esm/zksync/chainConfig.js
var chainConfig = {
  blockTime: 1e3,
  formatters,
  serializers,
  custom: {
    getEip712Domain: getEip712Domain2
  }
};

// node_modules/viem/_esm/chains/definitions/abstract.js
var abstract = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
});

// node_modules/viem/_esm/chains/definitions/abstractTestnet.js
var abstractTestnet = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
});

// node_modules/viem/_esm/chains/definitions/acala.js
var acala = defineChain({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/acria.js
var acria = defineChain({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/adf.js
var adf = defineChain({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/agungTestnet.js
var agungTestnet = defineChain({
  id: 9990,
  name: "Agung Network",
  nativeCurrency: {
    decimals: 18,
    name: "Agung",
    symbol: "AGNG"
  },
  rpcUrls: {
    default: {
      http: ["https://wss-async.agung.peaq.network"],
      webSocket: ["wss://wss-async.agung.peaq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://agung-testnet.subscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aioz.js
var aioz = defineChain({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alephZero.js
var alephZero = defineChain({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
});

// node_modules/viem/_esm/chains/definitions/alephZeroTestnet.js
var alephZeroTestnet = defineChain({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/alienX.js
var alienx = defineChain({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alienXHalTestnet.js
var alienxHalTestnet = defineChain({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
var formatters2 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
function serializeTransaction4(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers2 = {
  transaction: serializeTransaction4
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from: from6, gas, isSystemTx, mint: mint2, to: to3, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from6,
    to3 ?? "0x",
    mint2 ? toHex(mint2) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from: from6, to: to3 } = transaction;
  if (from6 && !isAddress(from6))
    throw new InvalidAddressError({ address: from6 });
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig2 = {
  blockTime: 2e3,
  contracts,
  formatters: formatters2,
  serializers: serializers2
};

// node_modules/viem/_esm/chains/definitions/ancient8.js
var sourceId = 1;
var ancient8 = defineChain({
  ...chainConfig2,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [sourceId]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId
});

// node_modules/viem/_esm/chains/definitions/ancient8Sepolia.js
var sourceId2 = 11155111;
var ancient8Sepolia = defineChain({
  ...chainConfig2,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: sourceId2
});

// node_modules/viem/_esm/chains/definitions/anvil.js
var anvil = defineChain({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/apeChain.js
var sourceId3 = 42161;
var apeChain = defineChain({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: sourceId3
});

// node_modules/viem/_esm/chains/definitions/apexTestnet.js
var apexTestnet = defineChain({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 250,
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
var arbitrumGoerli = defineChain({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrumNova.js
var arbitrumNova = defineChain({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  blockTime: 250,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arcTestnet.js
var arcTestnet = defineChain({
  id: 5042002,
  name: "Arc Testnet",
  nativeCurrency: {
    name: "USDC",
    symbol: "USDC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.testnet.arc.network",
        "https://rpc.quicknode.testnet.arc.network",
        "https://rpc.blockdaemon.testnet.arc.network"
      ],
      webSocket: [
        "wss://rpc.testnet.arc.network",
        "wss://rpc.quicknode.testnet.arc.network"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "ArcScan",
      url: "https://testnet.arcscan.app",
      apiUrl: "https://testnet.arcscan.app/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arenaz.js
var arenaz = defineChain({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/areonNetwork.js
var areonNetwork = defineChain({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/areonNetworkTestnet.js
var areonNetworkTestnet = defineChain({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/areum.js
var areum = defineChain({
  id: 463,
  name: "Areum",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areum.network"],
      webSocket: ["wss://mainnet-ws.areum.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areum Explorer",
      url: "https://explorer.areum.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/artelaTestnet.js
var artelaTestnet = defineChain({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arthera.js
var arthera = defineChain({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
});

// node_modules/viem/_esm/chains/definitions/artheraTestnet.js
var artheraTestnet = defineChain({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
});

// node_modules/viem/_esm/chains/definitions/assetChain.js
var assetChain = defineChain({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: false,
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/assetChainTestnet.js
var assetChainTestnet = defineChain({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
});

// node_modules/viem/_esm/chains/definitions/astar.js
var astar = defineChain({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkEVM.js
var astarZkEVM = defineChain({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkyoto.js
var astarZkyoto = defineChain({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/atletaOlympia.js
var atletaOlympia = defineChain({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aurora.js
var aurora = defineChain({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
});

// node_modules/viem/_esm/chains/definitions/auroraTestnet.js
var auroraTestnet = defineChain({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/auroria.js
var auroria = defineChain({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/autheoTestnet.js
var autheoTestnet = defineChain({
  id: 785,
  name: "Autheo Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Autheo",
    symbol: "THEO"
  },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc1.autheo.com",
        "https://testnet-rpc2.autheo.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Autheo Testnet Block Explorer",
      url: "https://testnet-explorer.autheo.com/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = defineChain({
  id: 43114,
  name: "Avalanche",
  blockTime: 1700,
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/b3.js
var sourceId4 = 8453;
var b32 = defineChain({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: sourceId4
});

// node_modules/viem/_esm/chains/definitions/b3Sepolia.js
var sourceId5 = 168587773;
var b3Sepolia = defineChain({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: true,
  sourceId: sourceId5
});

// node_modules/viem/_esm/chains/definitions/bahamut.js
var bahamut = defineChain({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/base.js
var sourceId6 = 1;
var base = defineChain({
  ...chainConfig2,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId6]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId6]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId6]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId6]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: sourceId6
});
var basePreconf = defineChain({
  ...base,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://mainnet-preconf.base.org"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/basecampTestnet.js
var basecampTestnet = defineChain({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/baseGoerli.js
var sourceId7 = 5;
var baseGoerli = defineChain({
  ...chainConfig2,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId7]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [sourceId7]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [sourceId7]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: true,
  sourceId: sourceId7
});

// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId8 = 11155111;
var baseSepolia = defineChain({
  ...chainConfig2,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId8]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId8]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId8]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId8]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId8
});
var baseSepoliaPreconf = defineChain({
  ...baseSepolia,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://sepolia-preconf.base.org"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beam.js
var beam = defineChain({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beamTestnet.js
var beamTestnet = defineChain({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainMainnet.js
var bearNetworkChainMainnet = defineChain({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainTestnet.js
var bearNetworkChainTestnet = defineChain({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachain.js
var berachain = defineChain({
  id: 80094,
  name: "Berachain",
  blockTime: 2e3,
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 9310021
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/berachainBepolia.js
var berachainBepolia = defineChain({
  id: 80069,
  blockTime: 2e3,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnet.js
var berachainTestnet = defineChain({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnetbArtio.js
var berachainTestnetbArtio = defineChain({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bevmMainnet.js
var bevmMainnet = defineChain({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bifrost.js
var bifrost = defineChain({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/birdlayer.js
var birdlayer = defineChain({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitgert.js
var bitgert = defineChain({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitkub.js
var bitkub = defineChain({
  id: 96,
  name: "KUB Mainnet",
  nativeCurrency: { name: "KUB Coin", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KUB Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitkubTestnet.js
var bitkubTestnet = defineChain({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitlayer.js
var bitlayer = defineChain({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitlayerTestnet.js
var bitlayerTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitrock.js
var bitrock = defineChain({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitTorrent.js
var bitTorrent = defineChain({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitTorrentTestnet.js
var bitTorrentTestnet = defineChain({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/blast.js
var sourceId9 = 1;
var blast = defineChain({
  ...chainConfig2,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    },
    l2OutputOracle: {
      [sourceId9]: {
        address: "0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76",
        blockCreated: 19300358
      }
    },
    portal: {
      [sourceId9]: {
        address: "0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb",
        blockCreated: 19300357
      }
    },
    l1StandardBridge: {
      [sourceId9]: {
        address: "0x697402166Fbf2F22E970df8a6486Ef171dbfc524",
        blockCreated: 19300360
      }
    }
  },
  sourceId: sourceId9
});

// node_modules/viem/_esm/chains/definitions/blastSepolia.js
var sourceId10 = 11155111;
var blastSepolia = defineChain({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: true,
  sourceId: sourceId10
});

// node_modules/viem/_esm/chains/definitions/bob.js
var sourceId11 = 1;
var bob = defineChain({
  ...chainConfig2,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [sourceId11]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId11]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: sourceId11
});

// node_modules/viem/_esm/chains/definitions/boba.js
var boba = defineChain({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bobaSepolia.js
var bobaSepolia = defineChain({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bobSepolia.js
var sourceId12 = 11155111;
var bobSepolia = defineChain({
  ...chainConfig2,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [sourceId12]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId12]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: true,
  sourceId: sourceId12
});

// node_modules/viem/_esm/chains/definitions/boolBetaMainnet.js
var boolBetaMainnet = defineChain({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/botanix.js
var botanix = defineChain({
  id: 3637,
  name: "Botanix",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.botanixlabs.com"],
      webSocket: ["wss://rpc.botanixlabs.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanixscan",
      url: "https://botanixscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/botanixTestnet.js
var botanixTestnet = defineChain({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bounceBit.js
var bounceBit = defineChain({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bounceBitTestnet.js
var bounceBitTestnet = defineChain({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bronos.js
var bronos = defineChain({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bronosTestnet.js
var bronosTestnet = defineChain({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsc.js
var bsc = defineChain({
  id: 56,
  name: "BNB Smart Chain",
  blockTime: 750,
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bscGreenfield.js
var bscGreenfield = defineChain({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bscTestnet.js
var bscTestnet = defineChain({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsquared.js
var bsquared = defineChain({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bsquaredTestnet.js
var bsquaredTestnet = defineChain({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/btr.js
var btr = defineChain({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/btrTestnet.js
var btrTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bxn.js
var bxn = defineChain({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bxnTestnet.js
var bxnTestnet = defineChain({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cannon.js
var cannon = defineChain({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/canto.js
var canto = defineChain({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
});

// node_modules/viem/_esm/celo/fees.js
var fees = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (params) => {
    var _a2;
    if (!((_a2 = params.request) == null ? void 0 : _a2.feeCurrency))
      return null;
    const [gasPrice, maxPriorityFeePerGas] = await Promise.all([
      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency)
    ]);
    const maxFeePerGas = params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
};
async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
  const fee = await client.request({
    method: "eth_gasPrice",
    params: [feeCurrency]
  });
  return BigInt(fee);
}
async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
  const feesPerGas = await client.request({
    method: "eth_maxPriorityFeePerGas",
    params: [feeCurrency]
  });
  return BigInt(feesPerGas);
}

// node_modules/viem/_esm/celo/utils.js
function isEmpty(value) {
  return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction) {
  return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
}
function isCIP64(transaction) {
  if (transaction.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction) && isPresent(transaction.feeCurrency);
}

// node_modules/viem/_esm/celo/formatters.js
var formatters3 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        return {
          ...formatted,
          ...transaction.gatewayFee ? {
            gatewayFee: hexToBigInt(transaction.gatewayFee),
            gatewayFeeRecipient: transaction.gatewayFeeRecipient
          } : {},
          feeCurrency: transaction.feeCurrency
        };
      });
      return {
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      if (args.type === "0x7e")
        return {
          isSystemTx: args.isSystemTx,
          mint: args.mint ? hexToBigInt(args.mint) : void 0,
          sourceHash: args.sourceHash,
          type: "deposit"
        };
      const transaction = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction.type = "cip42";
        transaction.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction;
    }
  }),
  transactionRequest: defineTransactionRequest({
    format(args) {
      const request = {};
      if (args.feeCurrency)
        request.feeCurrency = args.feeCurrency;
      if (isCIP64(args))
        request.type = "0x7b";
      return request;
    }
  })
};

// node_modules/viem/_esm/celo/serializers.js
function serializeTransaction5(transaction, signature) {
  if (isCIP64(transaction))
    return serializeTransactionCIP64(transaction, signature);
  return serializeTransaction4(transaction, signature);
}
var serializers3 = {
  transaction: serializeTransaction5
};
function serializeTransactionCIP64(transaction, signature) {
  assertTransactionCIP64(transaction);
  const { chainId, gas, nonce, to: to3, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to3 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList),
    feeCurrency,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
}
var MAX_MAX_FEE_PER_GAS = maxUint256;
function assertTransactionCIP64(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to3, feeCurrency } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}

// node_modules/viem/_esm/celo/chainConfig.js
var chainConfig3 = {
  blockTime: 1e3,
  contracts,
  formatters: formatters3,
  serializers: serializers3,
  fees
};

// node_modules/viem/_esm/chains/definitions/celo.js
var celo = defineChain({
  ...chainConfig3,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/celoAlfajores.js
var sourceId13 = 17e3;
var celoAlfajores = defineChain({
  ...chainConfig3,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [sourceId13]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [sourceId13]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [sourceId13]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [sourceId13]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/celoSepolia.js
var sourceId14 = 11155111;
var celoSepolia = defineChain({
  ...chainConfig3,
  id: 11142220,
  name: "Celo Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "S-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://forno.celo-sepolia.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Sepolia Explorer",
      url: "https://celo-sepolia.blockscout.com/",
      apiUrl: "https://celo-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    },
    portal: {
      [sourceId14]: {
        address: "0x44ae3d41a335a7d05eb533029917aad35662dcc2",
        blockCreated: 8825790
      }
    },
    disputeGameFactory: {
      [sourceId14]: {
        address: "0x57c45d82d1a995f1e135b8d7edc0a6bb5211cfaa",
        blockCreated: 8825790
      }
    },
    l1StandardBridge: {
      [sourceId14]: {
        address: "0xec18a3c30131a0db4246e785355fbc16e2eaf408",
        blockCreated: 8825790
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/chang.js
var chang = defineChain({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chiliz.js
var chiliz = defineChain({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiliz.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8080847
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chips.js
var chips = defineChain({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/citreaTestnet.js
var citreaTestnet = defineChain({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/classic.js
var classic = defineChain({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coinbit.js
var coinbit = defineChain({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coinex.js
var coinex = defineChain({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/confluxESpace.js
var confluxESpace = defineChain({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
});

// node_modules/viem/_esm/chains/definitions/confluxESpaceTestnet.js
var confluxESpaceTestnet = defineChain({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: true,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coreDao.js
var coreDao = defineChain({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coreTestnet1.js
var coreTestnet1 = defineChain({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/coreTestnet2.js
var coreTestnet2 = defineChain({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/corn.js
var sourceId15 = 1;
var corn = defineChain({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: sourceId15
});

// node_modules/viem/_esm/chains/definitions/cornTestnet.js
var sourceId16 = 11155111;
var cornTestnet = defineChain({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: true,
  sourceId: sourceId16
});

// node_modules/viem/_esm/chains/definitions/crab.js
var crab = defineChain({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
});

// node_modules/viem/_esm/chains/definitions/creatorTestnet.js
var creatorTestnet = defineChain({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Devnet.js
var creditCoin3Devnet = defineChain({
  id: 102032,
  name: "Creditcoin Devnet",
  nativeCurrency: { name: "Devnet CTC", symbol: "devCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-devnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-devnet.creditcoin.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-devnet.blockscout.com",
      apiUrl: "https://creditcoin3-dev.subscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Mainnet.js
var creditCoin3Mainnet = defineChain({
  id: 102030,
  name: "Creditcoin",
  nativeCurrency: { name: "Creditcoin", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Testnet.js
var creditCoin3Testnet = defineChain({
  id: 102031,
  name: "Creditcoin Testnet",
  nativeCurrency: { name: "Creditcoin Testnet", symbol: "tCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronos.js
var cronos = defineChain({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronosTestnet.js
var cronosTestnet = defineChain({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer (Testnet)",
      url: "https://explorer.cronos.org/testnet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVM.js
var cronoszkEVM = defineChain({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVMTestnet.js
var cronoszkEVMTestnet = defineChain({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/crossbell.js
var crossbell = defineChain({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/crossfi.js
var crossfi = defineChain({
  id: 4158,
  name: "CrossFi Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CrossFi",
    symbol: "XFI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.ms"] }
  },
  blockExplorers: {
    default: {
      name: "CrossFi Blockchain Explorer",
      url: "https://xfiscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/curtis.js
var curtis = defineChain({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cyber.js
var cyber = defineChain({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cyberTestnet.js
var cyberTestnet = defineChain({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dailyNetwork.js
var dailyNetwork = defineChain({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dailyNetworkTestnet.js
var dailyNetworkTestnet = defineChain({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/darwinia.js
var darwinia = defineChain({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dbkchain.js
var dbkchain = defineChain({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dchain.js
var dchain = defineChain({
  ...chainConfig2,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/dchainTestnet.js
var dchainTestnet = defineChain({
  ...chainConfig2,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvm.js
var defichainEvm = defineChain({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvmTestnet.js
var defichainEvmTestnet = defineChain({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/degen.js
var degen = defineChain({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dfk.js
var dfk = defineChain({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
});

// node_modules/viem/_esm/chains/definitions/diode.js
var diode = defineChain({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/disChain.js
var disChain = defineChain({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dodochainTestnet.js
var dodochainTestnet = defineChain({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dogechain.js
var dogechain = defineChain({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/domaTestnet.js
var domaTestnet = defineChain({
  id: 97476,
  name: "Doma Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.doma.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Doma Testnet Explorer",
      url: "https://explorer-testnet.doma.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/donatuz.js
var donatuz = defineChain({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChain.js
var dosChain = defineChain({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChainTestnet.js
var dosChainTestnet = defineChain({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dreyerxMainnet.js
var dreyerxMainnet = defineChain({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dreyerxTestnet.js
var dreyerxTestnet = defineChain({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dustboyIoT.js
var dustboyIoT = defineChain({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dymension.js
var dymension = defineChain({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/edexa.js
var edexa = defineChain({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edexaTestnet.js
var edexaTestnet = defineChain({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/edgeless.js
var edgeless = defineChain({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgelessTestnet.js
var edgelessTestnet = defineChain({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeware.js
var edgeware = defineChain({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgewareTestnet.js
var edgewareTestnet = defineChain({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eduChain.js
var eduChain = defineChain({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eduChainTestnet.js
var eduChainTestnet = defineChain({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ekta.js
var ekta = defineChain({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ektaTestnet.js
var ektaTestnet = defineChain({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elastos.js
var elastos = defineChain({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/elastosTestnet.js
var elastosTestnet = defineChain({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/electroneum.js
var electroneum = defineChain({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/electroneumTestnet.js
var electroneumTestnet = defineChain({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elysiumTestnet.js
var elysiumTestnet = defineChain({
  ...chainConfig2,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/energy.js
var energy = defineChain({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eni.js
var eni = defineChain({
  id: 173,
  name: "ENI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ENI",
    symbol: "ENI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.eniac.network"] }
  },
  blockExplorers: {
    default: {
      name: "ENI Explorer",
      url: "https://scan.eniac.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eniTestnet.js
var eniTestnet = defineChain({
  id: 6912115,
  name: "ENI Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ENI Testnet Token",
    symbol: "ENI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.eniac.network"] }
  },
  blockExplorers: {
    default: {
      name: "ENI Testnet Explorer",
      url: "https://scan-testnet.eniac.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/enuls.js
var enuls = defineChain({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eon.js
var eon = defineChain({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/eos.js
var eos = defineChain({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eosTestnet.js
var eosTestnet = defineChain({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/eteria.js
var eteria = defineChain({
  id: 140,
  name: "Eteria",
  nativeCurrency: { name: "Eteria", symbol: "ERA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.eteria.io/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "Eteria Explorer",
      url: "https://explorer.eteria.io",
      apiUrl: "https://explorer.eteria.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlink.js
var etherlink = defineChain({
  id: 42793,
  name: "Etherlink",
  blockTime: 4830,
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlinkTestnet.js
var etherlinkTestnet = defineChain({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ethernity.js
var ethernity = defineChain({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/etp.js
var etp = defineChain({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmos.js
var evmos = defineChain({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmosTestnet.js
var evmosTestnet = defineChain({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/excelonMainnet.js
var excelonMainnet = defineChain({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/expanse.js
var expanse = defineChain({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/exSat.js
var exsat = defineChain({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/exSatTestnet.js
var exsatTestnet = defineChain({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantom.js
var fantom = defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantomSonicTestnet.js
var fantomSonicTestnet = defineChain({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fantomTestnet.js
var fantomTestnet = defineChain({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fibo.js
var fibo = defineChain({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoin.js
var filecoin = defineChain({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoinCalibration.js
var filecoinCalibration = defineChain({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/filecoinHyperspace.js
var filecoinHyperspace = defineChain({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flame.js
var flame = defineChain({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flare.js
var flare = defineChain({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flareTestnet.js
var flareTestnet = defineChain({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flowMainnet.js
var flowMainnet = defineChain({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  },
  blockTime: 800
});

// node_modules/viem/_esm/chains/definitions/flowPreviewnet.js
var flowPreviewnet = defineChain({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowTestnet.js
var flowTestnet = defineChain({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: true,
  blockTime: 800
});

// node_modules/viem/_esm/chains/definitions/fluence.js
var fluence = defineChain({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fluenceStage.js
var fluenceStage = defineChain({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluenceTestnet.js
var fluenceTestnet = defineChain({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluentTestnet.js
var fluentTestnet = defineChain({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/form.js
var sourceId17 = 1;
var form = defineChain({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId17]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId17]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [sourceId17]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [sourceId17]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [sourceId17]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId17
});

// node_modules/viem/_esm/chains/definitions/forma.js
var forma = defineChain({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
});

// node_modules/viem/_esm/chains/definitions/formTestnet.js
var sourceId18 = 11155111;
var formTestnet = defineChain({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId18]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId18]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [sourceId18]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [sourceId18]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [sourceId18]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true,
  sourceId: sourceId18
});

// node_modules/viem/_esm/chains/definitions/forta.js
var forta = defineChain({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/foundry.js
var foundry = defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fraxtal.js
var sourceId19 = 1;
var fraxtal = defineChain({
  ...chainConfig2,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId19]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId19]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [sourceId19]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: sourceId19
});

// node_modules/viem/_esm/chains/definitions/fraxtalTestnet.js
var sourceId20 = 17e3;
var fraxtalTestnet = defineChain({
  ...chainConfig2,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId20]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId20]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [sourceId20]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: sourceId20
});

// node_modules/viem/_esm/chains/definitions/funkiMainnet.js
var sourceId21 = 1;
var funkiMainnet = defineChain({
  ...chainConfig2,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  },
  sourceId: sourceId21
});

// node_modules/viem/_esm/chains/definitions/funkiSepolia.js
var sourceId22 = 11155111;
var funkiSepolia = defineChain({
  ...chainConfig2,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: true,
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: sourceId22
});

// node_modules/viem/_esm/chains/definitions/fuse.js
var fuse = defineChain({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fuseSparknet.js
var fuseSparknet = defineChain({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fusion.js
var fusion = defineChain({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/fusionTestnet.js
var fusionTestnet = defineChain({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/garnet.js
var sourceId23 = 17e3;
var garnet = defineChain({
  ...chainConfig2,
  name: "Garnet Testnet",
  testnet: true,
  id: 17069,
  sourceId: sourceId23,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId23]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [sourceId23]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [sourceId23]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gatechain.js
var gatechain = defineChain({
  id: 86,
  name: "GateChain Mainnet",
  nativeCurrency: { name: "GateChainToken", symbol: "GT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.nodeinfo.cc"],
      webSocket: ["wss://evm-ws.gatenode.cc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gate Scan",
      url: "https://www.gatescan.org",
      apiUrl: "https://gatescan.org/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/geist.js
var geist = defineChain({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
});

// node_modules/viem/_esm/chains/definitions/genesys.js
var genesys = defineChain({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/giwaSepolia.js
var sourceId24 = 11155111;
var giwaSepolia = defineChain({
  ...chainConfig2,
  id: 91342,
  network: "giwa-sepolia",
  name: "GIWA Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.giwa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-explorer.giwa.io",
      apiUrl: "https://sepolia-explorer.giwa.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId24]: {
        address: "0x37347caB2afaa49B776372279143D71ad1f354F6"
      }
    },
    portal: {
      [sourceId24]: {
        address: "0x956962C34687A954e611A83619ABaA37Ce6bC78A"
      }
    },
    l1StandardBridge: {
      [sourceId24]: {
        address: "0x77b2ffc0F57598cAe1DB76cb398059cF5d10A7E7"
      }
    }
  },
  testnet: true,
  sourceId: sourceId24
});

// node_modules/viem/_esm/chains/definitions/glideL1Protocol.js
var glideL1Protocol = defineChain({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL2Protocol.js
var glideL2Protocol = defineChain({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/gnosis.js
var gnosis = defineChain({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  blockTime: 5e3,
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gnosisChiado.js
var gnosisChiado = defineChain({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  blockTime: 5e3,
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goat.js
var goat = defineChain({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gobi.js
var gobi = defineChain({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goChain.js
var goChain = defineChain({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/godwoken.js
var godwoken = defineChain({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/goerli.js
var goerli = defineChain({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/graphite.js
var graphite = defineChain({
  id: 440017,
  name: "Graphite Network",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Spectre",
      url: "https://main.atgraphite.com",
      apiUrl: "https://api.main.atgraphite.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/graphiteTestnet.js
var graphiteTestnet = defineChain({
  id: 54170,
  name: "Graphite Network Testnet",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-test-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-test-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Testnet Spectre",
      url: "https://test.atgraphite.com",
      apiUrl: "https://api.test.atgraphite.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/gravity.js
var gravity = defineChain({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gunz.js
var gunz = defineChain({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
});

// node_modules/viem/_esm/chains/definitions/guruNetwork.js
var guruNetwork = defineChain({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/guruTestnet.js
var guruTestnet = defineChain({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ham.js
var ham = defineChain({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/happychainTestnet.js
var happychainTestnet = defineChain({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haqqMainnet.js
var haqqMainnet = defineChain({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/haqqTestedge2.js
var haqqTestedge2 = defineChain({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hardhat.js
var hardhat = defineChain({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/harmonyOne.js
var harmonyOne = defineChain({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashKeyChain.js
var hashkey = defineChain({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashkeyChainTestnet.js
var hashkeyTestnet = defineChain({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Testnet explorer",
      url: "https://testnet-explorer.hsk.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haustTestnet.js
var haustTestnet = defineChain({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hedera.js
var hedera = defineChain({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hederaPreviewnet.js
var hederaPreviewnet = defineChain({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hederaTestnet.js
var hederaTestnet = defineChain({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hela.js
var hela = defineChain({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemi.js
var hemi = defineChain({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  blockTime: 12e3,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemiSepolia.js
var hemiSepolia = defineChain({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/holesky.js
var holesky = defineChain({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 4295055
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hoodi.js
var hoodi = defineChain({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hpb.js
var hpb = defineChain({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/huddle01Mainnet.js
var sourceId25 = 42161;
var huddle01Mainnet = defineChain({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: sourceId25
});

// node_modules/viem/_esm/chains/definitions/huddle01Testnet.js
var sourceId26 = 421614;
var huddle01Testnet = defineChain({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: sourceId26
});

// node_modules/viem/_esm/chains/definitions/humanity.js
var humanity = defineChain({
  id: 6985385,
  name: "Humanity",
  nativeCurrency: {
    name: "H",
    symbol: "H",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://humanity-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Humanity Mainnet Explorer",
      url: "https://humanity-mainnet.explorer.alchemy.com",
      apiUrl: "https://humanity-mainnet.explorer.alchemy.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/humanityTestnet.js
var humanityTestnet = defineChain({
  id: 7080969,
  name: "Humanity Testnet",
  nativeCurrency: {
    name: "tHP",
    symbol: "tHP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.humanity.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Humanity Testnet Explorer",
      url: "https://humanity-testnet.explorer.alchemy.com",
      apiUrl: "https://humanity-testnet.explorer.alchemy.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/humanode.js
var humanode = defineChain({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
});

// node_modules/viem/_esm/chains/definitions/humanodeTestnet5.js
var humanodeTestnet5 = defineChain({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hychain.js
var hychain = defineChain({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hychainTestnet.js
var hychainTestnet = defineChain({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hyperliquidEvmTestnet.js
var hyperliquidEvmTestnet = defineChain({
  id: 998,
  name: "Hyperliquid EVM Testnet",
  nativeCurrency: { name: "HYPE", symbol: "HYPE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hyperliquid-testnet.xyz/evm"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/icbNetwork.js
var icbNetwork = defineChain({
  id: 73115,
  name: "ICB Network",
  nativeCurrency: {
    decimals: 18,
    name: "ICB Native Token",
    symbol: "ICBX"
  },
  rpcUrls: {
    default: { http: ["https://rpc1-mainnet.icbnetwork.info"] }
  },
  blockExplorers: {
    default: {
      name: "ICB Explorer",
      url: "https://icbscan.io",
      apiUrl: "https://icbscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/idchain.js
var idchain = defineChain({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvm.js
var immutableZkEvm = defineChain({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvmTestnet.js
var immutableZkEvmTestnet = defineChain({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/inEVM.js
var inEVM = defineChain({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerse.js
var initVerse = defineChain({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerseGenesis.js
var initVerseGenesis = defineChain({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/injective.js
var injective = defineChain({
  id: 1776,
  name: "Injective",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: {
      http: ["https://sentry.evm-rpc.injective.network"],
      webSocket: ["wss://sentry.evm-ws.injective.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Injective Explorer",
      url: "https://blockscout.injective.network",
      apiUrl: "https://blockscout.injective.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/injectiveTestnet.js
var injectiveTestnet = defineChain({
  id: 1439,
  name: "Injective Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: {
      http: ["https://k8s.testnet.json-rpc.injective.network"],
      webSocket: ["wss://k8s.testnet.ws.injective.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Injective Explorer",
      url: "https://testnet.blockscout.injective.network",
      apiUrl: "https://testnet.blockscout.injective.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ink.js
var sourceId27 = 1;
var ink = defineChain({
  ...chainConfig2,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId27]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [sourceId27]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [sourceId27]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: false,
  sourceId: sourceId27
});

// node_modules/viem/_esm/chains/definitions/inkSepolia.js
var sourceId28 = 11155111;
var inkSepolia = defineChain({
  ...chainConfig2,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId28]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [sourceId28]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [sourceId28]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: true,
  sourceId: sourceId28
});

// node_modules/viem/_esm/chains/definitions/iota.js
var iota = defineChain({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotaTestnet.js
var iotaTestnet = defineChain({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iotex.js
var iotex = defineChain({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotexTestnet.js
var iotexTestnet = defineChain({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iSunCoin.js
var iSunCoin = defineChain({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/jbc.js
var jbc = defineChain({
  id: 8899,
  name: "JB Chain",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jbcTestnet.js
var jbcTestnet = defineChain({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/jocMainnet.js
var jocMainnet = defineChain({
  id: 81,
  name: "Japan Open Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Token",
    symbol: "JOC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.japanopenchain.org:8545",
        "https://rpc-2.japanopenchain.org:8545",
        "https://rpc-3.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.japanopenchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jocTestnet.js
var jocTestnet = defineChain({
  id: 10081,
  name: "Japan Open Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Testnet Token",
    symbol: "JOCT"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.testnet.japanopenchain.org:8545",
        "https://rpc-2.testnet.japanopenchain.org:8545",
        "https://rpc-3.testnet.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Testnet Block Explorer",
      url: "https://explorer.testnet.japanopenchain.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/jovay.js
var jovay = defineChain({
  id: 5734951,
  name: "Jovay Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.jovay.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Jovay Explorer",
      url: "https://explorer.jovay.io/l2"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jovaySepolia.js
var jovaySepolia = defineChain({
  id: 2019775,
  name: "Jovay Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.zan.top/public/jovay-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Jovay Testnet Explorer",
      url: "https://sepolia-explorer.jovay.io/l2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneo.js
var juneo = defineChain({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoBCH1Chain.js
var juneoBCH1Chain = defineChain({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDAI1Chain.js
var juneoDAI1Chain = defineChain({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDOGE1Chain.js
var juneoDOGE1Chain = defineChain({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoEUR1Chain.js
var juneoEUR1Chain = defineChain({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoGLD1Chain.js
var juneoGLD1Chain = defineChain({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLINK1Chain.js
var juneoLINK1Chain = defineChain({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLTC1Chain.js
var juneoLTC1Chain = defineChain({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneomBTC1Chain.js
var juneomBTC1Chain = defineChain({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSGD1Chain.js
var juneoSGD1Chain = defineChain({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSocotraTestnet.js
var juneoSocotraTestnet = defineChain({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneoUSD1Chain.js
var juneoUSD1Chain = defineChain({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoUSDT1Chain.js
var juneoUSDT1Chain = defineChain({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kaia.js
var kaia = defineChain({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kairos.js
var kairos = defineChain({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotSepolia.js
var kakarotSepolia = defineChain({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotStarknetSepolia.js
var kakarotStarknetSepolia = defineChain({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kardiaChain.js
var kardiaChain = defineChain({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/karura.js
var karura = defineChain({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/katana.js
var katana = defineChain({
  id: 747474,
  name: "Katana",
  network: "katana",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.katana.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "katana explorer",
      url: "https://explorer.katanarpc.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kava.js
var kava = defineChain({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kavaTestnet.js
var kavaTestnet = defineChain({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kcc.js
var kcc = defineChain({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kiiTestnet.js
var kiiTestnetOro = defineChain({
  id: 1336,
  name: "Kii Testnet Oro",
  network: "kii-testnet-oro",
  nativeCurrency: {
    name: "Kii",
    symbol: "KII",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.uno.sentry.testnet.v3.kiivalidator.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "KiiExplorer",
      url: "https://explorer.kiichain.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kinto.js
var kinto = defineChain({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/klaytn.js
var klaytn = defineChain({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/klaytnBaobab.js
var klaytnBaobab = defineChain({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/koi.js
var koi = defineChain({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kroma.js
var kroma = defineChain({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kromaSepolia.js
var kromaSepolia = defineChain({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/l3x.js
var l3x = defineChain({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/l3xTestnet.js
var l3xTestnet = defineChain({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lavita.js
var lavita = defineChain({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lens.js
var lens = defineChain({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lensTestnet.js
var lensTestnet = defineChain({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lestnet.js
var lestnet = defineChain({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPegasus.js
var lightlinkPegasus = defineChain({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPhoenix.js
var lightlinkPhoenix = defineChain({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: false
});

// node_modules/viem/_esm/linea/actions/estimateGas.js
async function estimateGas2(client, args) {
  var _a2, _b, _c2;
  const { account: account_ = client.account } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value, ...rest } = args;
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = (_c2 = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionRequest) == null ? void 0 : _c2.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      account,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to3,
      value
    }, "estimateGas");
    const { baseFeePerGas, gasLimit, priorityFeePerGas } = await client.request({
      method: "linea_estimateGas",
      params: block ? [request, block] : [request]
    });
    return {
      baseFeePerGas: BigInt(baseFeePerGas),
      gasLimit: BigInt(gasLimit),
      priorityFeePerGas: BigInt(priorityFeePerGas)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/linea/chainConfig.js
var chainConfig4 = {
  fees: {
    estimateFeesPerGas: estimateFeesPerGas2,
    async maxPriorityFeePerGas({ block, client, request }) {
      const response = await estimateFeesPerGas2({
        block,
        client,
        multiply: (x5) => x5,
        request,
        type: "eip1559"
      });
      if (!(response == null ? void 0 : response.maxPriorityFeePerGas))
        return null;
      return response.maxPriorityFeePerGas;
    }
  }
};
async function estimateFeesPerGas2({ client, multiply, request, type }) {
  try {
    const response = await estimateGas2(client, {
      ...request,
      account: request == null ? void 0 : request.account
    });
    const { priorityFeePerGas: maxPriorityFeePerGas } = response;
    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas));
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    if (type === "legacy")
      return { gasPrice: maxFeePerGas };
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/chains/definitions/linea.js
var linea = defineChain({
  ...chainConfig4,
  id: 59144,
  name: "Linea Mainnet",
  blockTime: 2e3,
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 22222151
    }
  },
  ensTlds: [".linea.eth"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lineaGoerli.js
var lineaGoerli = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaSepolia.js
var lineaSepolia = defineChain({
  ...chainConfig4,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 17168484
    }
  },
  ensTlds: [".linea.eth"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaTestnet.js
var lineaTestnet = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lisk.js
var sourceId29 = 1;
var lisk = defineChain({
  ...chainConfig2,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [sourceId29]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [sourceId29]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [sourceId29]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: sourceId29
});

// node_modules/viem/_esm/chains/definitions/liskSepolia.js
var sourceId30 = 11155111;
var liskSepolia = defineChain({
  ...chainConfig2,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId30]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId30]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [sourceId30]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: true,
  sourceId: sourceId30
});

// node_modules/viem/_esm/chains/definitions/loadAlphanet.js
var loadAlphanet = defineChain({
  id: 9496,
  name: "Load Alphanet",
  nativeCurrency: { name: "Testnet LOAD", symbol: "tLOAD", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://alphanet.load.network"] }
  },
  blockExplorers: {
    default: {
      name: "Load Alphanet Explorer",
      url: "https://explorer.load.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/localhost.js
var localhost = defineChain({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/loop.js
var loop = defineChain({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lukso.js
var lukso = defineChain({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
});

// node_modules/viem/_esm/chains/definitions/luksoTestnet.js
var luksoTestnet = defineChain({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumiaMainnet.js
var lumiaMainnet = defineChain({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumiaTestnet.js
var lumiaTestnet = defineChain({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumoz.js
var lumoz = defineChain({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumozTestnet.js
var lumozTestnet = defineChain({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lycan.js
var lycan = defineChain({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lyra.js
var lyra = defineChain({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 12e3,
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 23085558
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mandala.js
var mandala = defineChain({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/manta.js
var manta = defineChain({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantaSepoliaTestnet.js
var mantaSepoliaTestnet = defineChain({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantaTestnet.js
var mantaTestnet = defineChain({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = defineChain({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantleSepoliaTestnet.js
var mantleSepoliaTestnet = defineChain({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantleTestnet.js
var mantleTestnet = defineChain({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantraDuKongEVMTestnet.js
var mantraDuKongEVMTestnet = defineChain({
  id: 5887,
  name: "MANTRA DuKong EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OM",
    symbol: "OM"
  },
  rpcUrls: {
    default: { http: ["https://evm.dukong.mantrachain.io"] }
  },
  blockExplorers: {
    default: {
      name: "MANTRAScan",
      url: "https://mantrascan.io/dukong"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantraEVM.js
var mantraEVM = defineChain({
  id: 5888,
  name: "MANTRA EVM",
  nativeCurrency: {
    decimals: 18,
    name: "OM",
    symbol: "OM"
  },
  rpcUrls: {
    default: {
      http: ["https://evm.mantrachain.io"],
      webSocket: ["https://evm.mantrachain.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MANTRA Scan",
      url: "https://mantrascan.io/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mapProtocol.js
var mapProtocol = defineChain({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/matchain.js
var matchain = defineChain({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/matchainTestnet.js
var matchainTestnet = defineChain({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mchVerse.js
var mchVerse = defineChain({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/megaethTestnet.js
var megaethTestnet = defineChain({
  id: 6342,
  blockTime: 1e3,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mekong.js
var mekong = defineChain({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/meld.js
var meld = defineChain({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecore.js
var memecore = defineChain({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecoreFormicariumTestnet.js
var formicarium = defineChain({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/merlin.js
var merlin = defineChain({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlinErigonTestnet.js
var merlinErigonTestnet = defineChain({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metachain.js
var metachain = defineChain({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metachainIstanbul.js
var metachainIstanbul = defineChain({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metadium.js
var metadium = defineChain({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/metalL2.js
var sourceId31 = 1;
var metalL2 = defineChain({
  ...chainConfig2,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId31]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [sourceId31]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [sourceId31]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: sourceId31
});

// node_modules/viem/_esm/chains/definitions/meter.js
var meter = defineChain({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/meterTestnet.js
var meterTestnet = defineChain({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metis.js
var metis = defineChain({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisGoerli.js
var metisGoerli = defineChain({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisSepolia.js
var metisSepolia = defineChain({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mev.js
var mev = defineChain({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mevTestnet.js
var mevTestnet = defineChain({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mint.js
var mint = defineChain({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/mintSepoliaTestnet.js
var mintSepoliaTestnet = defineChain({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mitosisTestnet.js
var mitosisTestnet = defineChain({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mode.js
var sourceId32 = 1;
var mode = defineChain({
  ...chainConfig2,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [sourceId32]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [sourceId32]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [sourceId32]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: sourceId32
});

// node_modules/viem/_esm/chains/definitions/modeTestnet.js
var sourceId33 = 11155111;
var modeTestnet = defineChain({
  ...chainConfig2,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId33]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [sourceId33]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [sourceId33]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: true,
  sourceId: sourceId33
});

// node_modules/viem/_esm/chains/definitions/monadTestnet.js
var monadTestnet = defineChain({
  id: 10143,
  name: "Monad Testnet",
  blockTime: 400,
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbaseAlpha.js
var moonbaseAlpha = defineChain({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbeam.js
var moonbeam = defineChain({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/moonbeamDev.js
var moonbeamDev = defineChain({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/moonriver.js
var moonriver = defineChain({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morph.js
var morph = defineChain({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3654913
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morphHolesky.js
var morphHolesky = defineChain({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/morphSepolia.js
var morphSepolia = defineChain({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/nahmii.js
var nahmii = defineChain({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nautilus.js
var nautilus = defineChain({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/near.js
var near = defineChain({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nearTestnet.js
var nearTestnet = defineChain({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonDevnet.js
var neonDevnet = defineChain({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonMainnet.js
var neonMainnet = defineChain({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxMainnet.js
var neoxMainnet = defineChain({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxT4.js
var neoxT4 = defineChain({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/newton.js
var newton = defineChain({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nexi.js
var nexi = defineChain({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nexilix.js
var nexilix = defineChain({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nibiru.js
var nibiru = defineChain({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nitrographTestnet.js
var nitrographTestnet = defineChain({
  id: 200024,
  name: "Nitrograph Testnet",
  testnet: true,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.nitrograph.foundation"]
    }
  },
  nativeCurrency: {
    name: "Nitro",
    symbol: "NOS",
    decimals: 18
  },
  blockExplorers: {
    default: {
      url: "https://explorer-testnet.nitrograph.foundation",
      name: "Nitrograph Explorer"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nomina.js
var nomina = defineChain({
  id: 166,
  name: "Nomina",
  nativeCurrency: {
    name: "Nomina",
    symbol: "NOM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.nomina.io"],
      webSocket: ["wss://mainnet.nomina.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Nomina Explorer",
      url: "https://nomscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oasisTestnet.js
var oasisTestnet = defineChain({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oasys.js
var oasys = defineChain({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/odysseyTestnet.js
var odysseyTestnet = defineChain({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/okc.js
var okc = defineChain({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
});

// node_modules/viem/_esm/chains/definitions/omax.js
var omax = defineChain({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/omni.js
var omni = defineChain({
  id: 166,
  name: "Omni",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.omni.network"],
      webSocket: ["wss://mainnet.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "OmniScan",
      url: "https://omniscan.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/omniOmega.js
var omniOmega = defineChain({
  id: 164,
  name: "Omni Omega",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://omega.omni.network"],
      webSocket: ["wss://omega.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Omega OmniScan",
      url: "https://omega.omniscan.network/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oneWorld.js
var oneWorld = defineChain({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oortmainnetDev.js
var oortMainnetDev = defineChain({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/opBNB.js
var sourceId34 = 56;
var opBNB = defineChain({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [sourceId34]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [sourceId34]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [sourceId34]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: sourceId34
});

// node_modules/viem/_esm/chains/definitions/opBNBTestnet.js
var sourceId35 = 97;
var opBNBTestnet = defineChain({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [sourceId35]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [sourceId35]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [sourceId35]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: true,
  sourceId: sourceId35
});

// node_modules/viem/_esm/chains/definitions/openledger.js
var openledger = defineChain({
  id: 1612,
  name: "OpenLedger",
  nativeCurrency: { name: "Open", symbol: "OPEN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.openledger.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "OpenLedger Explorer",
      url: "https://scan.openledger.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId36 = 1;
var optimism = defineChain({
  ...chainConfig2,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId36]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId36]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId36]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId36]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId36
});

// node_modules/viem/_esm/chains/definitions/optimismGoerli.js
var sourceId37 = 5;
var optimismGoerli = defineChain({
  ...chainConfig2,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId37]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [sourceId37]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [sourceId37]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: true,
  sourceId: sourceId37
});

// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId38 = 11155111;
var optimismSepolia = defineChain({
  ...chainConfig2,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId38]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId38]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId38]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId38]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId38
});

// node_modules/viem/_esm/chains/definitions/optopia.js
var optopia = defineChain({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optopiaTestnet.js
var optopiaTestnet = defineChain({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/orderly.js
var orderly = defineChain({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/orderlySepolia.js
var orderlySepolia = defineChain({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/otimDevnet.js
var otimDevnet = defineChain({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palm.js
var palm = defineChain({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palmTestnet.js
var palmTestnet = defineChain({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/peaq.js
var peaq = defineChain({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://quicknode1.peaq.xyz",
        "https://quicknode2.peaq.xyz",
        "https://quicknode3.peaq.xyz"
      ],
      webSocket: [
        "wss://quicknode1.peaq.xyz",
        "wss://quicknode2.peaq.xyz",
        "wss://quicknode3.peaq.xyz"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pgn.js
var sourceId39 = 1;
var pgn = defineChain({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId39]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [sourceId39]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [sourceId39]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: formatters2,
  sourceId: sourceId39
});

// node_modules/viem/_esm/chains/definitions/pgnTestnet.js
var sourceId40 = 11155111;
var pgnTestnet = defineChain({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId40]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [sourceId40]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [sourceId40]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: formatters2,
  sourceId: sourceId40,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/phoenix.js
var phoenix = defineChain({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
});

// node_modules/viem/_esm/chains/definitions/planq.js
var planq = defineChain({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/plasma.js
var plasma = defineChain({
  id: 9745,
  name: "Plasma",
  blockTime: 1e3,
  nativeCurrency: {
    name: "Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlasmaScan",
      url: "https://plasmascan.to"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plasmaDevnet.js
var plasmaDevnet = defineChain({
  id: 9747,
  name: "Plasma Devnet",
  nativeCurrency: {
    name: "Devnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://devnet-rpc.plasma.to"]
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plasmaTestnet.js
var plasmaTestnet = defineChain({
  id: 9746,
  name: "Plasma Testnet",
  nativeCurrency: {
    name: "Testnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "RouteScan",
      url: "https://testnet.plasmascan.to"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/playfiAlbireo.js
var playfiAlbireo = defineChain({
  ...chainConfig,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/plinga.js
var plinga = defineChain({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plume.js
var sourceId41 = 1;
var plume = defineChain({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: sourceId41
});

// node_modules/viem/_esm/chains/definitions/plumeDevnet.js
var sourceId42 = 11155111;
var plumeDevnet = defineChain({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: true,
  sourceId: sourceId42
});

// node_modules/viem/_esm/chains/definitions/plumeMainnet.js
var sourceId43 = 1;
var plumeMainnet = defineChain({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: sourceId43
});

// node_modules/viem/_esm/chains/definitions/plumeSepolia.js
var sourceId44 = 11155111;
var plumeSepolia = defineChain({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: true,
  sourceId: sourceId44
});

// node_modules/viem/_esm/chains/definitions/plumeTestnet.js
var sourceId45 = 11155111;
var plumeTestnet = defineChain({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: true,
  sourceId: sourceId45
});

// node_modules/viem/_esm/chains/definitions/polterTestnet.js
var polterTestnet = defineChain({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  blockTime: 2e3,
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonMumbai.js
var polygonMumbai = defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
var polygonZkEvm = defineChain({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmCardona.js
var polygonZkEvmCardona = defineChain({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmTestnet.js
var polygonZkEvmTestnet = defineChain({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomial.js
var polynomial = defineChain({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: false,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomialSepolia.js
var polynomialSepolia = defineChain({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/premiumBlock.js
var premiumBlockTestnet = defineChain({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pulsechain.js
var pulsechain = defineChain({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: false,
  blockTime: 1e4,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://ipfs.scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pulsechainV4.js
var pulsechainV4 = defineChain({
  id: 943,
  name: "PulseChain V4",
  testnet: true,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  blockTime: 1e4,
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pumpfiTestnet.js
var pumpfiTestnet = defineChain({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pyrope.js
var sourceId46 = 11155111;
var pyrope = defineChain({
  ...chainConfig2,
  name: "Pyrope Testnet",
  testnet: true,
  id: 695569,
  sourceId: sourceId46,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l1StandardBridge: {
      [sourceId46]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ql1.js
var ql1 = defineChain({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/qMainnet.js
var qMainnet = defineChain({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/qTestnet.js
var qTestnet = defineChain({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/quai.js
var quai = defineChain({
  id: 9,
  name: "Quai Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Quai",
    symbol: "QUAI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.quai.network/cyprus1"] }
  },
  blockExplorers: {
    default: {
      name: "Quaiscan",
      url: "https://quaiscan.io",
      apiUrl: "https://quaiscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/quaiTestnet.js
var quaiTestnet = defineChain({
  id: 15e3,
  name: "Quai Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Quai",
    symbol: "QUAI"
  },
  rpcUrls: {
    default: { http: ["https://orchard.rpc.quai.network/cyprus1"] }
  },
  blockExplorers: {
    default: {
      name: "Orchard Quaiscan",
      url: "https://orchard.quaiscan.io",
      apiUrl: "https://orchard.quaiscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/real.js
var real = defineChain({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
});

// node_modules/viem/_esm/chains/definitions/redbellyMainnet.js
var redbellyMainnet = defineChain({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/redbellyTestnet.js
var redbellyTestnet = defineChain({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/reddio.js
var reddio = defineChain({
  id: 50342,
  name: "Reddio",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.reddio.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://reddio.cloud.blockscout.com",
      apiUrl: "https://reddio.cloud.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 848849
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reddioSepolia.js
var reddioSepolia = defineChain({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/redstone.js
var sourceId47 = 1;
var redstone = defineChain({
  ...chainConfig2,
  name: "Redstone",
  id: 690,
  sourceId: sourceId47,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId47]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [sourceId47]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [sourceId47]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rei.js
var rei = defineChain({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reyaNetwork.js
var reyaNetwork = defineChain({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/riseTestnet.js
var riseTestnet = defineChain({
  id: 11155931,
  name: "RISE Testnet",
  nativeCurrency: { name: "RISE Testnet Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.riselabs.xyz"],
      webSocket: ["wss://testnet.riselabs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.testnet.riselabs.xyz/",
      apiUrl: "https://explorer.testnet.riselabs.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rivalz.js
var rivalz = defineChain({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/rollux.js
var rollux = defineChain({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rolluxTestnet.js
var rolluxTestnet = defineChain({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ronin.js
var ronin = defineChain({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
});

// node_modules/viem/_esm/chains/definitions/root.js
var root = defineChain({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootPorcini.js
var rootPorcini = defineChain({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rootstock.js
var rootstock = defineChain({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootstockTestnet.js
var rootstockTestnet = defineChain({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rss3.js
var sourceId48 = 1;
var rss3 = defineChain({
  ...chainConfig2,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId48]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [sourceId48]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [sourceId48]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: sourceId48
});

// node_modules/viem/_esm/chains/definitions/rss3Sepolia.js
var sourceId49 = 11155111;
var rss3Sepolia = defineChain({
  ...chainConfig2,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId49]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [sourceId49]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [sourceId49]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: true,
  sourceId: sourceId49
});

// node_modules/viem/_esm/chains/definitions/saakuru.js
var saakuru = defineChain({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/saga.js
var saga = defineChain({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
});

// node_modules/viem/_esm/chains/definitions/saigon.js
var saigon = defineChain({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sanko.js
var sanko = defineChain({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sapphire.js
var sapphire = defineChain({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
});

// node_modules/viem/_esm/chains/definitions/sapphireTestnet.js
var sapphireTestnet = defineChain({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/satoshivm.js
var satoshiVM = defineChain({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/satoshivmTestnet.js
var satoshiVMTestnet = defineChain({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = defineChain({
  id: 534352,
  name: "Scroll",
  blockTime: 3e3,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sei.js
var sei = defineChain({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/seiDevnet.js
var seiDevnet = defineChain({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seismicDevnet.js
var seismicDevnet = defineChain({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seiTestnet.js
var seiTestnet = defineChain({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 98697651
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://11155111.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 8928790
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shape.js
var sourceId50 = 1;
var shape = defineChain({
  ...chainConfig2,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId50]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [sourceId50]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [sourceId50]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: sourceId50
});

// node_modules/viem/_esm/chains/definitions/shapeSepolia.js
var sourceId51 = 11155111;
var shapeSepolia = defineChain({
  ...chainConfig2,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId51
});

// node_modules/viem/_esm/chains/definitions/shardeum.js
var shardeum = defineChain({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shardeumSphinx.js
var shardeumSphinx = defineChain({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shibarium.js
var shibarium = defineChain({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shibariumTestnet.js
var shibariumTestnet = defineChain({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shiden.js
var shiden = defineChain({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shimmer.js
var shimmer = defineChain({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shimmerTestnet.js
var shimmerTestnet = defineChain({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sidra.js
var sidraChain = defineChain({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/silicon.js
var silicon = defineChain({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/siliconSepolia.js
var siliconSepolia = defineChain({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sixProtocol.js
var sixProtocol = defineChain({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/skale/brawl.js
var skaleBlockBrawlers = defineChain({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/calypso.js
var skaleCalypso = defineChain({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/calypsoTestnet.js
var skaleCalypsoTestnet = defineChain({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoBlades.js
var skaleCryptoBlades = defineChain({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoColosseum.js
var skaleCryptoColosseum = defineChain({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/europa.js
var skaleEuropa = defineChain({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/europaTestnet.js
var skaleEuropaTestnet = defineChain({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/exorde.js
var skaleExorde = defineChain({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/humanProtocol.js
var skaleHumanProtocol = defineChain({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/nebula.js
var skaleNebula = defineChain({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/nebulaTestnet.js
var skaleNebulaTestnet = defineChain({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/razor.js
var skaleRazor = defineChain({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/titan.js
var skaleTitan = defineChain({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/titanTestnet.js
var skaleTitanTestnet = defineChain({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sketchpad.js
var sketchpad = defineChain({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/snax.js
var sourceId52 = 1;
var snax = defineChain({
  ...chainConfig2,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId52]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [sourceId52]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId52]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [sourceId52]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: sourceId52
});

// node_modules/viem/_esm/chains/definitions/snaxTestnet.js
var sourceId53 = 11155111;
var snaxTestnet = defineChain({
  ...chainConfig2,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId53]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [sourceId53]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId53]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [sourceId53]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: true,
  sourceId: sourceId53
});

// node_modules/viem/_esm/chains/definitions/somniaTestnet.js
var somniaTestnet = defineChain({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://shannon-explorer.somnia.network/",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x841b8199E6d3Db3C6f264f6C2bd8848b3cA64223",
      blockCreated: 71314235
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/soneium.js
var sourceId54 = 1;
var soneium = defineChain({
  ...chainConfig2,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId54]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [sourceId54]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [sourceId54]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [sourceId54]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: sourceId54
});

// node_modules/viem/_esm/chains/definitions/soneiumMinato.js
var sourceId55 = 11155111;
var soneiumMinato = defineChain({
  ...chainConfig2,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId55]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [sourceId55]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [sourceId55]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [sourceId55]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId55
});

// node_modules/viem/_esm/chains/definitions/songbird.js
var songbird = defineChain({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
});

// node_modules/viem/_esm/chains/definitions/songbirdTestnet.js
var songbirdTestnet = defineChain({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonic.js
var sonic = defineChain({
  id: 146,
  name: "Sonic",
  blockTime: 630,
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sonicBlazeTestnet.js
var sonicBlazeTestnet = defineChain({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonicTestnet.js
var sonicTestnet = defineChain({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sophon.js
var sophon = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sophonTestnet.js
var sophonTestnet = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sova.js
var sova = defineChain({
  id: 100021,
  name: "Sova",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sova.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sova Block Explorer",
      url: "hhttps://explorer.sova.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sovaSepolia.js
var sovaSepolia = defineChain({
  id: 120893,
  name: "Sova Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Sepolia Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sova.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sova Sepolia Explorer",
      url: "https://explorer.testnet.sova.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/spicy.js
var spicy = defineChain({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/statusNetworkSepolia.js
var statusSepolia = defineChain({
  ...chainConfig4,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/step.js
var step = defineChain({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/story.js
var story = defineChain({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.io",
      apiUrl: "https://storyscan.io/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/storyAeneid.js
var storyAeneid = defineChain({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.io",
      apiUrl: "https://aeneid.storyscan.io/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyOdyssey.js
var storyOdyssey = defineChain({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyTestnet.js
var storyTestnet = defineChain({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/stratis.js
var stratis = defineChain({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/superlumio.js
var superlumio = defineChain({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superposition.js
var superposition = defineChain({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superseed.js
var sourceId56 = 1;
var superseed = defineChain({
  ...chainConfig2,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId56]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [sourceId56]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [sourceId56]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [sourceId56]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId56
});

// node_modules/viem/_esm/chains/definitions/superseedSepolia.js
var sourceId57 = 11155111;
var superseedSepolia = defineChain({
  ...chainConfig2,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [sourceId57]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [sourceId57]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: true,
  sourceId: sourceId57
});

// node_modules/viem/_esm/chains/definitions/surgeTestnet.js
var surgeTestnet = defineChain({
  id: 763375,
  name: "Surge Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-rpc.hoodi.surge.wtf"],
      webSocket: ["wss://l2-ws.hoodi.surge.wtf"]
    }
  },
  blockExplorers: {
    default: {
      name: "Surge Testnet Blockscout",
      url: "https://explorer.hoodi.surge.wtf"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swan.js
var swan = defineChain({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/swanProximaTestnet.js
var swanProximaTestnet = defineChain({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swanSaturnTestnet.js
var swanSaturnTestnet = defineChain({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swellchain.js
var swellchain = defineChain({
  ...chainConfig2,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swellchainTestnet.js
var swellchainTestnet = defineChain({
  ...chainConfig2,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swissdlt.js
var swissdlt = defineChain({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/syscoin.js
var syscoin = defineChain({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
});

// node_modules/viem/_esm/chains/definitions/syscoinTestnet.js
var syscoinTestnet = defineChain({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tac.js
var tac = defineChain({
  id: 239,
  name: "TAC",
  nativeCurrency: { name: "TAC", symbol: "TAC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/tac"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://tac.blockscout.com",
      apiUrl: "https://tac.blockscout.com/api"
    },
    native: {
      name: "TAC Explorer",
      url: "https://explorer.tac.build",
      apiUrl: "https://explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tacSPB.js
var tacSPB = defineChain({
  id: 2391,
  name: "TAC SPB Testnet",
  nativeCurrency: {
    name: "TAC",
    symbol: "TAC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://spb.rpc.tac.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "TAC",
      url: "https://spb.explorer.tac.build",
      apiUrl: "https://spb.explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 471429
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taiko.js
var taiko = defineChain({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoHekla.js
var taikoHekla = defineChain({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoJolnir.js
var taikoJolnir = defineChain({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoKatla.js
var taikoKatla = defineChain({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoTestnetSepolia.js
var taikoTestnetSepolia = defineChain({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxa.js
var taraxa = defineChain({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxaTestnet.js
var taraxaTestnet = defineChain({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/teaSepolia.js
var teaSepolia = defineChain({
  id: 10218,
  name: "Tea Sepolia",
  nativeCurrency: { name: "Sepolia Tea", symbol: "TEA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tea-sepolia.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tea Sepolia Explorer",
      url: "https://sepolia.tea.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telcoinTestnet.js
var telcoinTestnet = defineChain({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telos.js
var telos = defineChain({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
});

// node_modules/viem/_esm/chains/definitions/telosTestnet.js
var telosTestnet = defineChain({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tenet.js
var tenet = defineChain({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ternoa.js
var ternoa = defineChain({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thaiChain.js
var thaiChain = defineChain({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/that.js
var that = defineChain({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/theta.js
var theta = defineChain({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thetaTestnet.js
var thetaTestnet = defineChain({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/thunderCore.js
var thunderCore = defineChain({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thunderTestnet.js
var thunderTestnet = defineChain({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tiktrixTestnet.js
var tiktrixTestnet = defineChain({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tomb.js
var tomb = defineChain({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasure.js
var treasure = defineChain({
  ...chainConfig,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasureTopaz.js
var treasureTopaz = defineChain({
  ...chainConfig,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tron.js
var tron = defineChain({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tronNile.js
var tronNile = defineChain({
  id: 3448148188,
  name: "Tron Nile",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://nile.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://nile.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tronShasta.js
var tronShasta = defineChain({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ubiq.js
var ubiq = defineChain({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultra.js
var ultra = defineChain({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ultraTestnet.js
var ultraTestnet = defineChain({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ultron.js
var ultron = defineChain({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultronTestnet.js
var ultronTestnet = defineChain({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/unichain.js
var sourceId58 = 1;
var unichain = defineChain({
  ...chainConfig2,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId58]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [sourceId58]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [sourceId58]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: sourceId58
});

// node_modules/viem/_esm/chains/definitions/unichainSepolia.js
var sourceId59 = 11155111;
var unichainSepolia = defineChain({
  ...chainConfig2,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [sourceId59]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [sourceId59]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [sourceId59]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: true,
  sourceId: sourceId59
});

// node_modules/viem/_esm/chains/definitions/unique.js
var unique = defineChain({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/uniqueOpal.js
var uniqueOpal = defineChain({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/uniqueQuartz.js
var uniqueQuartz = defineChain({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/unreal.js
var unreal = defineChain({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vana.js
var vana = defineChain({
  id: 1480,
  name: "Vana",
  blockTime: 6e3,
  nativeCurrency: {
    decimals: 18,
    name: "Vana",
    symbol: "VANA"
  },
  rpcUrls: {
    default: { http: ["https://rpc.vana.org/"] }
  },
  blockExplorers: {
    default: {
      name: "Vana Block Explorer",
      url: "https://vanascan.io",
      apiUrl: "https://vanascan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xD8d2dFca27E8797fd779F8547166A2d3B29d360E",
      blockCreated: 716763
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vanaMoksha.js
var vanaMoksha = defineChain({
  id: 14800,
  name: "Vana Moksha Testnet",
  blockTime: 6e3,
  nativeCurrency: {
    decimals: 18,
    name: "Vana",
    symbol: "VANA"
  },
  rpcUrls: {
    default: { http: ["https://rpc.moksha.vana.org"] }
  },
  blockExplorers: {
    default: {
      name: "Vana Moksha Testnet",
      url: "https://moksha.vanascan.io",
      apiUrl: "https://moksha.vanascan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xD8d2dFca27E8797fd779F8547166A2d3B29d360E",
      blockCreated: 732283
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vanar.js
var vanar = defineChain({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/vechain.js
var vechain = defineChain({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/velas.js
var velas = defineChain({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/viction.js
var viction = defineChain({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/victionTestnet.js
var victionTestnet = defineChain({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vision.js
var vision = defineChain({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/visionTestnet.js
var visionTestnet = defineChain({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wanchain.js
var wanchain = defineChain({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wanchainTestnet.js
var wanchainTestnet = defineChain({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/weavevmAlphanet.js
var weaveVMAlphanet = defineChain({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wemix.js
var wemix = defineChain({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wemixTestnet.js
var wemixTestnet = defineChain({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/westendAssetHub.js
var westendAssetHub = defineChain({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/whitechain.js
var whitechain = defineChain({
  testnet: false,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
});

// node_modules/viem/_esm/chains/definitions/whitechainTestnet.js
var whitechainTestnet = defineChain({
  testnet: true,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
});

// node_modules/viem/_esm/chains/definitions/wmcTestnet.js
var wmcTestnet = defineChain({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/worldchain.js
var sourceId60 = 1;
var worldchain = defineChain({
  ...chainConfig2,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId60]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [sourceId60]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [sourceId60]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [sourceId60]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: false,
  sourceId: sourceId60
});

// node_modules/viem/_esm/chains/definitions/worldchainSepolia.js
var sourceId61 = 11155111;
var worldchainSepolia = defineChain({
  ...chainConfig2,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId61]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [sourceId61]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [sourceId61]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [sourceId61]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: true,
  sourceId: sourceId61
});

// node_modules/viem/_esm/chains/definitions/worldLand.js
var worldLand = defineChain({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xai.js
var xai = defineChain({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xaiTestnet.js
var xaiTestnet = defineChain({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xdc.js
var xdc = defineChain({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xdcTestnet.js
var xdcTestnet = defineChain({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayer.js
var xLayer = defineChain({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayerTestnet.js
var xLayerTestnet = defineChain({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xphereMainnet.js
var xphereMainnet = defineChain({
  id: 20250217,
  name: "Xphere Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "XP",
    symbol: "XP"
  },
  rpcUrls: {
    default: {
      http: ["https://en-bkk.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xp.tamsa.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xphereTestnet.js
var xphereTestnet = defineChain({
  id: 1998991,
  name: "Xphere Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "XPT",
    symbol: "XPT"
  },
  rpcUrls: {
    default: {
      http: ["http://testnet.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xpt.tamsa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrOne.js
var xrOne = defineChain({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xrplevmDevnet.js
var xrplevmDevnet = defineChain({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrplevmTestnet.js
var xrplevmTestnet = defineChain({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrSepolia.js
var xrSepolia = defineChain({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/yooldoVerse.js
var yooldoVerse = defineChain({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/yooldoVerseTestnet.js
var yooldoVerseTestnet = defineChain({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zenchainTestnet.js
var zenchainTestnet = defineChain({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeniq.js
var zeniq = defineChain({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zeroNetwork.js
var zeroNetwork = defineChain({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachain.js
var zetachain = defineChain({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://zetascan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachainAthensTestnet.js
var zetachainAthensTestnet = defineChain({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://testnet.zetascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zhejiang.js
var zhejiang = defineChain({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zilliqa.js
var zilliqa = defineChain({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zilliqaTestnet.js
var zilliqaTestnet = defineChain({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuit.js
var sourceId62 = 1;
var zircuit = defineChain({
  ...chainConfig2,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId62]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [sourceId62]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [sourceId62]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zircuitGarfieldTestnet.js
var sourceId63 = 11155111;
var zircuitGarfieldTestnet = defineChain({
  ...chainConfig2,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId63]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [sourceId63]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [sourceId63]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuitTestnet.js
var sourceId64 = 11155111;
var zircuitTestnet = defineChain({
  ...chainConfig2,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [sourceId64]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [sourceId64]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [sourceId64]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkFair.js
var zkFair = defineChain({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zkFairTestnet.js
var zkFairTestnet = defineChain({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkLinkNova.js
var zkLinkNova = defineChain({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zkLinkNovaSepoliaTestnet.js
var zkLinkNovaSepoliaTestnet = defineChain({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksync.js
var zksync = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksyncInMemoryNode.js
var zksyncInMemoryNode = defineChain({
  ...chainConfig,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalCustomHyperchain.js
var zksyncLocalCustomHyperchain = defineChain({
  ...chainConfig,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchain.js
var zksyncLocalHyperchain = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchainL1.js
var zksyncLocalHyperchainL1 = defineChain({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalNode.js
var zksyncLocalNode = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncSepoliaTestnet.js
var zksyncSepoliaTestnet = defineChain({
  ...chainConfig,
  blockTime: 200,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zora.js
var sourceId65 = 1;
var zora = defineChain({
  ...chainConfig2,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId65]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [sourceId65]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [sourceId65]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: sourceId65
});

// node_modules/viem/_esm/chains/definitions/zoraSepolia.js
var sourceId66 = 11155111;
var zoraSepolia = defineChain({
  ...chainConfig2,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId66]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [sourceId66]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [sourceId66]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: sourceId66,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zoraTestnet.js
var sourceId67 = 5;
var zoraTestnet = defineChain({
  ...chainConfig2,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [sourceId67]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: sourceId67,
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain3(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain3({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain3({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain3({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain3({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain3({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});
var bitcoinSignet = defineChain3({
  id: "00000008819873e925422c1ff0f99f7c",
  caipNetworkId: "bip122:00000008819873e925422c1ff0f99f7c",
  chainNamespace: "bip122",
  name: "Bitcoin Signet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  RPC_ERROR_CODE: {
    USER_REJECTED: 5e3,
    USER_REJECTED_METHODS: 5002
  },
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns3] = chainId.split(":");
        if (ns3) {
          namespacesToOverride.add(ns3);
        }
      });
    }
    namespacesToOverride.forEach((ns3) => {
      if (!result[ns3]) {
        result[ns3] = this.createDefaultNamespace(ns3);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns3, methods]) => {
        if (result[ns3]) {
          result[ns3].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns3, chains]) => {
        if (result[ns3]) {
          result[ns3].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns3, events]) => {
        if (result[ns3]) {
          result[ns3].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns3, id] = chainId.split(":");
        if (!ns3 || !id || !result[ns3]) {
          return;
        }
        if (!result[ns3].rpcMap) {
          result[ns3].rpcMap = {};
        }
        if (!processedNamespaces.has(ns3)) {
          result[ns3].rpcMap = {};
          processedNamespaces.add(ns3);
        }
        result[ns3].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain) => {
      const { id, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name) => {
    var _a2;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a2 = networkNameAddresses[0]) == null ? void 0 : _a2.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isUserRejectedRequestError(error) {
    try {
      if (typeof error === "object" && error !== null) {
        const objErr = error;
        const hasCode = typeof objErr["code"] === "number";
        const hasUserRejectedMethods = hasCode && objErr["code"] === WcHelpersUtil.RPC_ERROR_CODE.USER_REJECTED_METHODS;
        const hasUserRejected = hasCode && objErr["code"] === WcHelpersUtil.RPC_ERROR_CODE.USER_REJECTED;
        return hasUserRejectedMethods || hasUserRejected;
      }
      return false;
    } catch {
      return false;
    }
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex = new RegExp(regexString, "u");
        if (regex.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  },
  listenWcProvider({ universalProvider, namespace, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onDisplayUri }) {
    if (onConnect) {
      universalProvider.on("connect", () => {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, namespace);
        onConnect(accounts);
      });
    }
    if (onDisconnect) {
      universalProvider.on("disconnect", () => {
        onDisconnect();
      });
    }
    if (onAccountsChanged) {
      universalProvider.on("accountsChanged", (accounts) => {
        var _a2, _b, _c2, _d, _e3;
        try {
          const allAccounts = ((_c2 = (_b = (_a2 = universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) || [];
          const defaultChain = (_e3 = (_d = universalProvider.rpcProviders) == null ? void 0 : _d[namespace]) == null ? void 0 : _e3.getDefaultChain();
          const parsedAccounts = accounts.map((account) => {
            const caipAccount = allAccounts.find((acc) => acc.includes(`${namespace}:${defaultChain}:${account}`));
            if (!caipAccount) {
              return void 0;
            }
            const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(caipAccount);
            return {
              address: account,
              chainId,
              chainNamespace
            };
          }).filter((account) => account !== void 0);
          if (parsedAccounts.length > 0) {
            onAccountsChanged(parsedAccounts);
          }
        } catch (error) {
          console.warn("Failed to parse accounts for namespace on accountsChanged event", namespace, accounts, error);
        }
      });
    }
    if (onChainChanged) {
      universalProvider.on("chainChanged", (chainId) => {
        onChainChanged(chainId);
      });
    }
    if (onDisplayUri) {
      universalProvider.on("display_uri", (uri) => {
        onDisplayUri(uri);
      });
    }
  },
  getWalletConnectAccounts(universalProvider, namespace) {
    var _a2, _b, _c2, _d;
    const accountsAdded = /* @__PURE__ */ new Set();
    const accounts = (_d = (_c2 = (_b = (_a2 = universalProvider == null ? void 0 : universalProvider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) == null ? void 0 : _d.map((account) => ParseUtil.parseCaipAddress(account)).filter(({ address }) => {
      if (accountsAdded.has(address.toLowerCase())) {
        return false;
      }
      accountsAdded.add(address.toLowerCase());
      return true;
    });
    if (accounts && accounts.length > 0) {
      return accounts;
    }
    return [];
  }
};

// node_modules/@reown/appkit/dist/esm/src/connections/ConnectionManager.js
var ConnectionManager = class {
  constructor(params) {
    this.namespace = params.namespace;
  }
  async syncConnections(params) {
    switch (this.namespace) {
      case ConstantsUtil.CHAIN.EVM:
        await this.syncEVMConnections(params);
        break;
      case ConstantsUtil.CHAIN.SOLANA:
        await this.syncSolanaConnections(params);
        break;
      case ConstantsUtil.CHAIN.BITCOIN:
        await this.syncBitcoinConnections(params);
        break;
      default:
        throw new Error(`Unsupported chain namespace: ${this.namespace}`);
    }
  }
  async syncEVMConnections({ connectors, caipNetworks, universalProvider, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c5) => {
      const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c5.id, this.namespace);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        const caipNetwork = caipNetworks.find((n3) => {
          var _a2, _b;
          return n3.chainNamespace === this.namespace && n3.id.toString() === ((_b = (_a2 = accounts[0]) == null ? void 0 : _a2.chainId) == null ? void 0 : _b.toString());
        });
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const { accounts, chainId } = await ConnectorUtil.fetchProviderData(connector);
        if (accounts.length > 0 && chainId) {
          const caipNetwork = caipNetworks.find((n3) => n3.chainNamespace === this.namespace && n3.id.toString() === chainId.toString());
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((address) => ({ address })),
            caipNetwork
          });
          if (connector.provider && connector.id !== ConstantsUtil.CONNECTOR_ID.AUTH && connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            onListenProvider(connector.id, connector.provider);
          }
        }
      }
    }));
  }
  async syncSolanaConnections({ connectors, caipNetwork, universalProvider, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c5) => {
      const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c5.id, this.namespace);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const address = await connector.connect({
          chainId: caipNetwork == null ? void 0 : caipNetwork.id
        });
        if (address) {
          onConnection({
            connectorId: connector.id,
            accounts: [{ address }],
            caipNetwork
          });
          onListenProvider(connector.id, connector.provider);
        }
      }
    }));
  }
  async syncBitcoinConnections({ connectors, caipNetwork, universalProvider, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c5) => {
      const { hasDisconnected, hasConnected } = HelpersUtil.getConnectorStorageInfo(c5.id, this.namespace);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      var _a2, _b, _c2, _d, _e3, _f2;
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts2 = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts2.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts2.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
        return;
      }
      const address = await connector.connect();
      const addresses = await connector.getAccountAddresses();
      let accounts = addresses == null ? void 0 : addresses.map((a2) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.BITCOIN, a2.address, a2.purpose || "payment", a2.publicKey, a2.path));
      if (accounts && accounts.length > 1) {
        accounts = [
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_a2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _a2.publicKey) ?? "",
            path: ((_b = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _b.path) ?? "",
            address: ((_c2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]) == null ? void 0 : _c2.address) ?? "",
            type: "payment"
          },
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: ((_d = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _d.publicKey) ?? "",
            path: ((_e3 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _e3.path) ?? "",
            address: ((_f2 = accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]) == null ? void 0 : _f2.address) ?? "",
            type: "ordinal"
          }
        ];
      }
      const chain = connector.chains.find((c5) => c5.id === (caipNetwork == null ? void 0 : caipNetwork.id)) || connector.chains[0];
      if (!chain) {
        throw new Error("The connector does not support any of the requested chains");
      }
      if (address) {
        onListenProvider(connector.id, connector.provider);
        onConnection({
          connectorId: connector.id,
          accounts: accounts.map((a2) => ({
            address: a2.address,
            type: a2.type,
            publicKey: a2.publicKey,
            path: a2.path
          })),
          caipNetwork
        });
      }
    }));
  }
  /**
   * Gets a connection based on provided parameters.
   * If connectorId is provided, returns connection for that specific connector.
   * Otherwise, returns the first available valid connection.
   *
   * @param params - Connection parameters
   * @param params.address - Optional address to filter by
   * @param params.connectorId - Optional connector ID to filter by
   * @param params.connections - List of available connections
   * @param params.connectors - List of available connectors
   * @returns Connection or null if none found
   */
  getConnection({ address, connectorId, connections, connectors }) {
    if (connectorId) {
      const connection = connections.find((c5) => HelpersUtil.isLowerCaseMatch(c5.connectorId, connectorId));
      if (!connection) {
        return null;
      }
      const connector = connectors.find((c5) => HelpersUtil.isLowerCaseMatch(c5.id, connection.connectorId));
      const account = address ? connection.accounts.find((a2) => HelpersUtil.isLowerCaseMatch(a2.address, address)) : connection.accounts[0];
      return { ...connection, account, connector };
    }
    const validConnection = connections.find((c5) => c5.accounts.length > 0 && connectors.some((conn) => HelpersUtil.isLowerCaseMatch(conn.id, c5.connectorId)));
    if (validConnection) {
      const [account] = validConnection.accounts;
      const connector = connectors.find((c5) => HelpersUtil.isLowerCaseMatch(c5.id, validConnection.connectorId));
      return {
        ...validConnection,
        account,
        connector
      };
    }
    return null;
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://localhost:*",
    "http://127.0.0.1:*",
    "https://127.0.0.1:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var IGNORED_CONNECTOR_IDS_FOR_LISTENER = [
  ConstantsUtil.CONNECTOR_ID.AUTH,
  ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT
];
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.availableConnections = [];
    this.providerHandlers = {};
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getConnectorId = (namespace) => ConnectorController.getConnectorId(namespace);
    if (params) {
      this.construct(params);
    }
    if (params == null ? void 0 : params.namespace) {
      this.connectionManager = new ConnectionManager({
        namespace: params.namespace
      });
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the available connections.
   * @returns {Connection[]} An array of available connections
   */
  get connections() {
    return this.availableConnections;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Handles the auth connected event.
   * @param {W3mFrameTypes.Responses['FrameGetUserResponse']} user - The user response
   */
  onAuthConnected({ accounts, chainId }) {
    const caipNetwork = this.getCaipNetworks().filter((n3) => n3.chainNamespace === this.namespace).find((n3) => n3.id.toString() === (chainId == null ? void 0 : chainId.toString()));
    if (accounts && caipNetwork) {
      this.addConnection({
        connectorId: ConstantsUtil.CONNECTOR_ID.AUTH,
        accounts,
        caipNetwork
      });
    }
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    authProvider.onConnect(this.onAuthConnected.bind(this));
    authProvider.onSocialConnected(this.onAuthConnected.bind(this));
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  /**
   * Adds connections to the available connections list
   * @param {...Connection} connections - The connections to add
   */
  addConnection(...connections) {
    const connectionsAdded = /* @__PURE__ */ new Set();
    this.availableConnections = [...connections, ...this.availableConnections].filter((connection) => {
      if (connectionsAdded.has(connection.connectorId.toLowerCase())) {
        return false;
      }
      connectionsAdded.add(connection.connectorId.toLowerCase());
      return true;
    });
    this.emit("connections", this.availableConnections);
  }
  /**
   * Deletes a connection from the available connections list
   * @param {string} connectorId - The connector ID of the connection to delete
   */
  deleteConnection(connectorId) {
    this.availableConnections = this.availableConnections.filter((c5) => !HelpersUtil.isLowerCaseMatch(c5.connectorId, connectorId));
    this.emit("connections", this.availableConnections);
  }
  /**
   * Clears all connections from the available connections list
   * @param {boolean} emit - Whether to emit the connections event
   */
  clearConnections(emit = false) {
    this.availableConnections = [];
    if (emit) {
      this.emit("connections", this.availableConnections);
    }
  }
  setStatus(status, chainNamespace) {
    ChainController.setAccountProp("status", status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a2;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a2 = this.eventListeners.get(eventName)) == null ? void 0 : _a2.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    try {
      const connector = this.getWalletConnectConnector();
      const result = await connector.connectWalletConnect();
      return { clientId: result.clientId };
    } catch (err) {
      if (WcHelpersUtil.isUserRejectedRequestError(err)) {
        throw new UserRejectedRequestError(err);
      }
      throw err;
    }
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = getPreferredAccountType(caipNetwork.chainNamespace);
      await authProvider.switchNetwork({ chainId: caipNetwork.caipNetworkId });
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c5) => c5 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  /**
   * Handles connect event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onConnect(accounts, connectorId) {
    if (accounts.length > 0) {
      const { address, chainId } = CoreHelperUtil.getAccount(accounts[0]);
      const caipNetwork = this.getCaipNetworks().filter((n3) => n3.chainNamespace === this.namespace).find((n3) => n3.id.toString() === (chainId == null ? void 0 : chainId.toString()));
      const connector = this.connectors.find((c5) => c5.id === connectorId);
      if (address) {
        this.emit("accountChanged", {
          address,
          chainId,
          connector
        });
        this.addConnection({
          connectorId,
          accounts: accounts.map((_account) => {
            const { address: address2 } = CoreHelperUtil.getAccount(_account);
            return { address: address2 };
          }),
          caipNetwork
        });
      }
    }
  }
  /**
   * Handles accounts changed event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onAccountsChanged(accounts, connectorId, disconnectIfNoAccounts = true) {
    var _a2, _b;
    if (accounts.length > 0) {
      const { address } = CoreHelperUtil.getAccount(accounts[0]);
      const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
        connectorId,
        connections: this.connections,
        connectors: this.connectors
      });
      if (address && HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
        this.emit("accountChanged", {
          address,
          chainId: (_b = connection == null ? void 0 : connection.caipNetwork) == null ? void 0 : _b.id,
          connector: connection == null ? void 0 : connection.connector
        });
      }
      this.addConnection({
        connectorId,
        accounts: accounts.map((_account) => {
          const { address: address2 } = CoreHelperUtil.getAccount(_account);
          return { address: address2 };
        }),
        caipNetwork: connection == null ? void 0 : connection.caipNetwork
      });
    } else if (disconnectIfNoAccounts) {
      this.onDisconnect(connectorId);
    }
  }
  /**
   * Handles disconnect event for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  onDisconnect(connectorId) {
    this.removeProviderListeners(connectorId);
    this.deleteConnection(connectorId);
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emitFirstAvailableConnection();
    }
    if (this.connections.length === 0) {
      this.emit("disconnect");
    }
  }
  /**
   * Handles chain changed event for a specific connector.
   * @param {string} chainId - The ID of the chain that changed
   * @param {string} connectorId - The ID of the connector
   */
  onChainChanged(chainId, connectorId) {
    var _a2;
    const formattedChainId = typeof chainId === "string" && chainId.startsWith("0x") ? EthersHelpersUtil.hexStringToNumber(chainId).toString() : chainId.toString();
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connectorId,
      connections: this.connections,
      connectors: this.connectors
    });
    const caipNetwork = this.getCaipNetworks().filter((n3) => n3.chainNamespace === this.namespace).find((n3) => n3.id.toString() === formattedChainId);
    if (connection) {
      this.addConnection({
        connectorId,
        accounts: connection.accounts,
        caipNetwork
      });
    }
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emit("switchNetwork", { chainId: formattedChainId });
    }
  }
  /**
   * Listens to provider events for a specific connector.
   * @param {string} connectorId - The ID of the connector
   * @param {Provider | CombinedProvider} provider - The provider to listen to
   */
  listenProviderEvents(connectorId, provider) {
    if (IGNORED_CONNECTOR_IDS_FOR_LISTENER.includes(connectorId)) {
      return;
    }
    const accountsChangedHandler = (accounts) => this.onAccountsChanged(accounts, connectorId);
    const chainChangedHandler = (chainId) => this.onChainChanged(chainId, connectorId);
    const disconnectHandler = () => this.onDisconnect(connectorId);
    if (!this.providerHandlers[connectorId]) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChangedHandler);
      this.providerHandlers[connectorId] = {
        provider,
        disconnect: disconnectHandler,
        accountsChanged: accountsChangedHandler,
        chainChanged: chainChangedHandler
      };
    }
  }
  /**
   * Removes provider listeners for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  removeProviderListeners(connectorId) {
    if (this.providerHandlers[connectorId]) {
      const { provider, disconnect, accountsChanged, chainChanged } = this.providerHandlers[connectorId];
      provider.removeListener("disconnect", disconnect);
      provider.removeListener("accountsChanged", accountsChanged);
      provider.removeListener("chainChanged", chainChanged);
      this.providerHandlers[connectorId] = null;
    }
  }
  /**
   * Emits the first available connection.
   */
  emitFirstAvailableConnection() {
    var _a2, _b;
    const connection = (_a2 = this.connectionManager) == null ? void 0 : _a2.getConnection({
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      const [account] = connection.accounts;
      this.emit("accountChanged", {
        address: account == null ? void 0 : account.address,
        chainId: (_b = connection.caipNetwork) == null ? void 0 : _b.id,
        connector: connection.connector
      });
    }
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  async setUniversalProvider(universalProvider) {
    if (!this.namespace) {
      throw new Error("UniversalAdapter:setUniversalProvider - namespace is required");
    }
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
    return Promise.resolve();
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
      this.emit("disconnect");
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
    return { connections: [] };
  }
  syncConnections() {
    return Promise.resolve();
  }
  async getAccounts({ namespace }) {
    var _a2, _b, _c2, _d;
    const provider = this.provider;
    const addresses = ((_d = (_c2 = (_b = (_a2 = provider == null ? void 0 : provider.session) == null ? void 0 : _a2.namespaces) == null ? void 0 : _b[namespace]) == null ? void 0 : _c2.accounts) == null ? void 0 : _d.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index, self2) => self2.indexOf(address) === index)) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    var _a2, _b, _c2, _d, _e3;
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes((_a2 = params.caipNetwork) == null ? void 0 : _a2.chainNamespace);
    if (!isBalanceSupported || ((_b = params.caipNetwork) == null ? void 0 : _b.testnet)) {
      return {
        balance: "0.00",
        symbol: ((_c2 = params.caipNetwork) == null ? void 0 : _c2.nativeCurrency.symbol) || ""
      };
    }
    const accountData = ChainController.getAccountData();
    if ((accountData == null ? void 0 : accountData.balanceLoading) && params.chainId === ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.id)) {
      return {
        balance: (accountData == null ? void 0 : accountData.balance) || "0.00",
        symbol: (accountData == null ? void 0 : accountData.balanceSymbol) || ""
      };
    }
    const balances = await ChainController.fetchTokenBalance();
    const balance = balances.find((b4) => {
      var _a3, _b2;
      return b4.chainId === `${(_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace}:${params.chainId}` && b4.symbol === ((_b2 = params.caipNetwork) == null ? void 0 : _b2.nativeCurrency.symbol);
    });
    return {
      balance: (balance == null ? void 0 : balance.quantity.numeric) || "0.00",
      symbol: (balance == null ? void 0 : balance.symbol) || ((_e3 = params.caipNetwork) == null ? void 0 : _e3.nativeCurrency.symbol) || ""
    };
  }
  async signMessage(params) {
    var _a2, _b, _c2;
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.chainNamespace) === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, (_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address]
      }, (_c2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _c2.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  emitFirstAvailableConnection() {
    return void 0;
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    var _a2, _b, _c2, _d, _e3, _f2;
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await ((_a2 = connector.provider) == null ? void 0 : _a2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex(caipNetwork.id) }]
        }));
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_c2 = (_b = switchError == null ? void 0 : switchError.data) == null ? void 0 : _b.originalError) == null ? void 0 : _c2.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await ((_f2 = connector.provider) == null ? void 0 : _f2.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex(caipNetwork.id),
                  rpcUrls: [(_d = caipNetwork == null ? void 0 : caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _d.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [(_e3 = caipNetwork.blockExplorers) == null ? void 0 : _e3.default.url]
                }
              ]
            }));
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding",
  "multiWallet",
  "emailCapture",
  "payWithExchange",
  "payments",
  "reownAuthentication"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s2) => s2 !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  },
  emailCapture: {
    apiFeatureName: "email_capture",
    localFeatureName: "emailCapture",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => apiConfig.isEnabled && (apiConfig.config ?? []),
    processFallback: (_localValue) => false
  },
  multiWallet: {
    apiFeatureName: "multi_wallet",
    localFeatureName: "multiWallet",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.multiWallet
  },
  payWithExchange: {
    apiFeatureName: "fund_from_exchange",
    localFeatureName: "payWithExchange",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payWithExchange
  },
  payments: {
    apiFeatureName: "payments",
    localFeatureName: "payments",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.payments
  },
  reownAuthentication: {
    apiFeatureName: "reown_authentication",
    localFeatureName: "reownAuthentication",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (typeof localValue === "undefined") {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownAuthentication;
      }
      return Boolean(localValue);
    }
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig == null ? void 0 : apiProjectConfig.find((f7) => f7.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if ((apiConfig == null ? void 0 : apiConfig.config) === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!(apiConfig == null ? void 0 : apiConfig.config)) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let shouldUseApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      shouldUseApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e);
    }
    const remoteFeaturesConfig = shouldUseApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, shouldUseApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (shouldUseApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        debugMessage: ErrorUtil.ALERT_WARNINGS.LOCAL_CONFIGURATION_IGNORED.debugMessage(warningMessage)
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.features = {};
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      var _a2, _b, _c2;
      if (chainNamespace) {
        const caipNetworkWithId = (_a2 = ChainController.getCaipNetworks(chainNamespace)) == null ? void 0 : _a2.find((c5) => c5.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = (_b = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _b.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return (_c2 = requestedCaipNetworks.filter((c5) => c5.chainNamespace === chainNamespace)) == null ? void 0 : _c2[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      var _a2, _b;
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderController.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderController.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => getPreferredAccountType(namespace);
    this.setCaipAddress = (caipAddress, chain, shouldRefresh = false) => {
      ChainController.setAccountProp("caipAddress", caipAddress, chain, shouldRefresh);
      ChainController.setAccountProp("address", CoreHelperUtil.getPlainAddress(caipAddress), chain, shouldRefresh);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      ChainController.setAccountProp("balance", balance, chain);
      ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      ChainController.setAccountProp("profileName", profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      ChainController.setAccountProp("profileImage", profileImage, chain);
    };
    this.setUser = (user, chain) => {
      ChainController.setAccountProp("user", user, chain);
    };
    this.resetAccount = (chain) => {
      ChainController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setStatus = (status, chain) => {
      ChainController.setAccountProp("status", status, chain);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => {
      var _a2;
      return (_a2 = ChainController.getAccountData(chainNamespace)) == null ? void 0 : _a2.address;
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      StorageUtil.setConnections(connections, chainNamespace);
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.getConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).connections;
    };
    this.getRecentConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).recentConnections;
    };
    this.switchConnection = async (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      await ConnectionController.switchConnection(params);
    };
    this.deleteConnection = (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      StorageUtil.deleteAddressFromConnection(params);
      ConnectionController.syncStorageConnections();
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      const type = ProviderController.getProviderId(chain);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      ChainController.setAccountProp("connectedWalletInfo", walletInfo, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address, label, chain) => {
      var _a2;
      const addressLabels = ((_a2 = ChainController.getAccountData(chain)) == null ? void 0 : _a2.addressLabels) || {};
      ChainController.setAccountProp("addressLabels", { ...addressLabels, [address]: label }, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      var _a2;
      const addressLabels = ((_a2 = ChainController.getAccountData(chain)) == null ? void 0 : _a2.addressLabels) || {};
      ChainController.setAccountProp("addressLabels", { ...addressLabels, [address]: void 0 }, chain);
    };
    this.getAddress = (chainNamespace) => {
      var _a2;
      const namespace = chainNamespace || ChainController.state.activeChain;
      return (_a2 = ChainController.getAccountData(namespace)) == null ? void 0 : _a2.address;
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      ChainController.setAccountProp("addressExplorerUrl", addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
    SemVerUtils.checkSDKVersion(options.sdkVersion);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters == null ? void 0 : adapters.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces == null ? void 0 : adapterNamespaces.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks == null ? void 0 : caipNetworks.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    var _a2, _b, _c2, _d, _e3;
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    if (OptionsController.state.enableReconnect) {
      await this.syncExistingConnection();
      await this.syncAdapterConnections();
    } else {
      await this.unSyncExistingConnection();
    }
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (((_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.email) || Array.isArray((_b = OptionsController.state.remoteFeatures) == null ? void 0 : _b.socials) && ((_c2 = OptionsController.state.remoteFeatures) == null ? void 0 : _c2.socials.length) > 0) {
      await this.checkAllowedOrigins();
    }
    if (((_d = OptionsController.state.features) == null ? void 0 : _d.reownAuthentication) || ((_e3 = OptionsController.state.remoteFeatures) == null ? void 0 : _e3.reownAuthentication)) {
      const { ReownAuthentication } = await import("./features-TT3V2ARA.js");
      const currentSIWX = OptionsController.state.siwx;
      if (!(currentSIWX instanceof ReownAuthentication)) {
        if (currentSIWX) {
          console.warn("ReownAuthentication option is enabled, SIWX configuration will be overridden.");
        }
        OptionsController.setSIWX(new ReownAuthentication());
      }
    }
  }
  async openSend(args) {
    var _a2;
    const namespaceToUse = args.namespace || ChainController.state.activeChain;
    const caipAddress = this.getCaipAddress(namespaceToUse);
    const chainId = (_a2 = this.getCaipNetwork(namespaceToUse)) == null ? void 0 : _a2.id;
    if (!caipAddress) {
      throw new Error("openSend: caipAddress not found");
    }
    if ((chainId == null ? void 0 : chainId.toString()) !== args.chainId.toString()) {
      const caipNetwork = ChainController.getCaipNetworkById(args.chainId, namespaceToUse);
      if (!caipNetwork) {
        throw new Error(`openSend: caipNetwork with chainId ${args.chainId} not found`);
      }
      await this.switchNetwork(caipNetwork, { throwOnFailure: true });
    }
    try {
      const symbol = TokenUtil.getTokenSymbolByAddress(args.assetAddress);
      if (symbol) {
        await ApiController.fetchTokenImages([symbol]);
      }
    } catch {
    }
    await ModalController.open({
      view: "WalletSend",
      data: { send: args }
    });
    return new Promise((resolve, reject) => {
      const unsubscribe = SendController.subscribeKey("hash", (hash) => {
        if (hash) {
          cleanup();
          resolve({ hash });
        }
      });
      const unsubscribeModal = ModalController.subscribe((modal) => {
        if (!modal.open) {
          cleanup();
          reject(new Error("Modal closed"));
        }
      });
      const cleanup = this.createCleanupHandler([unsubscribe, unsubscribeModal]);
    });
  }
  toModalOptions() {
    function isSwap(options) {
      return (options == null ? void 0 : options.view) === "Swap";
    }
    function isSend(options) {
      return (options == null ? void 0 : options.view) === "WalletSend";
    }
    return {
      isSwap,
      isSend
    };
  }
  async checkAllowedOrigins() {
    try {
      const allowedOrigins = await ApiController.fetchAllowedOrigins();
      if (!CoreHelperUtil.isClient()) {
        return;
      }
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.ORIGIN_NOT_ALLOWED, "error");
      }
    } catch (error) {
      if (!(error instanceof Error)) {
        return;
      }
      switch (error.message) {
        case "RATE_LIMITED":
          AlertController.open(ErrorUtil.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const originalError = error.cause instanceof Error ? error.cause : error;
          AlertController.open({
            displayMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.displayMessage,
            debugMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.debugMessage(originalError.message)
          }, "error");
          break;
        }
        default:
          break;
      }
    }
  }
  createCleanupHandler(unsubscribeFunctions) {
    return () => {
      unsubscribeFunctions.forEach((unsubscribe) => {
        try {
          unsubscribe();
        } catch {
        }
      });
    };
  }
  sendInitializeEvent(options) {
    var _a2;
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n3) => n3.id),
        siweConfig: {
          options: ((_a2 = options.siweConfig) == null ? void 0 : _a2.options) || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.initialize(options.adapters ?? []);
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    var _a2;
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableReconnect(options.enableReconnect !== false);
    OptionsController.setEnableMobileFullScreen(options.enableMobileFullScreen === true);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    this.features = OptionsController.state.features ?? {};
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = (_a2 = options.adapters) == null ? void 0 : _a2.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    var _a2, _b, _c2, _d;
    if (CoreHelperUtil.isClient()) {
      return {
        name: ((_b = (_a2 = document.getElementsByTagName("title")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.textContent) || "",
        description: ((_c2 = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _c2.content) || "",
        url: window.location.origin,
        icons: [((_d = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _d.href) || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n3) => {
      var _a2;
      return n3.id === ((_a2 = options.defaultNetwork) == null ? void 0 : _a2.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  /**
   * Disconnects a connector with the given namespace and id. If the connector id is not provided, disconnects the adapter (namespace).
   * @param namespace ChainNamespace
   * @param id string
   * @returns
   */
  async disconnectConnector(namespace, id) {
    var _a2, _b;
    try {
      this.setLoading(true, namespace);
      let disconnectResult = {
        connections: []
      };
      const adapter = this.getAdapter(namespace);
      const caipAddress = (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.caipAddress;
      if ((caipAddress || !OptionsController.state.enableReconnect) && (adapter == null ? void 0 : adapter.disconnect)) {
        disconnectResult = await adapter.disconnect({ id });
      }
      this.setLoading(false, namespace);
      return disconnectResult;
    } catch (error) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chains: ${error.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a2;
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = (_a2 = this.getCaipNetwork(activeChain)) == null ? void 0 : _a2.id;
        const connections = ConnectionController.getConnections(activeChain);
        const isMultiWallet = this.remoteFeatures.multiWallet;
        const hasConnections = connections.length > 0;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        const shouldClose = !hasConnections || !isMultiWallet;
        if (shouldClose) {
          this.close();
        }
        this.setClientId((result == null ? void 0 : result.clientId) || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        await this.syncWalletConnectAccount();
        await SIWXUtil.initializeIfEnabled();
      },
      connectExternal: async (params) => {
        const connectResult = await this.onConnectExternal(params);
        await this.connectInactiveNamespaces(params, connectResult);
        return connectResult ? { address: connectResult.address } : void 0;
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("reconnectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("reconnectExternal: adapter not found");
        }
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id, info, type, provider, chainId: (_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id }));
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnectConnector: async (params) => {
        await this.disconnectConnector(params.namespace, params.id);
      },
      disconnect: async (params) => {
        var _a2;
        const { id: connectorIdParam, chainNamespace, initialDisconnect } = params || {};
        const namespace = chainNamespace || ChainController.state.activeChain;
        const namespaceConnectorId = ConnectorController.getConnectorId(namespace);
        const isAuth = connectorIdParam === ConstantsUtil.CONNECTOR_ID.AUTH || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isWalletConnect = connectorIdParam === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        try {
          const namespaces = Array.from(ChainController.state.chains.keys());
          let namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
          if (isWalletConnect || isAuth) {
            namespacesToDisconnect = namespaces;
          }
          const disconnectPromises = namespacesToDisconnect.map(async (ns3) => {
            const currentConnectorId = ConnectorController.getConnectorId(ns3);
            const connectorIdToDisconnect = connectorIdParam || currentConnectorId;
            const disconnectData = await this.disconnectConnector(ns3, connectorIdToDisconnect);
            if (disconnectData) {
              if (isAuth) {
                StorageUtil.deleteConnectedSocialProvider();
              }
              disconnectData.connections.forEach((connection) => {
                StorageUtil.addDisconnectedConnectorId(connection.connectorId, ns3);
              });
            }
            if (initialDisconnect) {
              this.onDisconnectNamespace({ chainNamespace: ns3, closeModal: false });
            }
          });
          const disconnectResults = await Promise.allSettled(disconnectPromises);
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          if ((_a2 = SIWXUtil.getSIWX()) == null ? void 0 : _a2.signOutOnDisconnect) {
            await SIWXUtil.clearSessions();
          }
          ConnectorController.setFilterByNamespace(void 0);
          ConnectionController.syncStorageConnections();
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f7) => f7.reason.message).join(", "));
          }
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error) {
          throw new Error(`Failed to disconnect chains: ${error.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => {
          var _a2;
          return Boolean((_a2 = window.ethereum) == null ? void 0 : _a2[String(id)]);
        });
      },
      signMessage: async (message) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!namespace) {
          throw new Error("signMessage: namespace not found");
        }
        if (!adapter) {
          throw new Error("signMessage: adapter not found");
        }
        const address = this.getAddress(namespace);
        if (!address) {
          throw new Error("signMessage: address not found");
        }
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message,
          address,
          provider: ProviderController.getProvider(namespace)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (!namespace) {
          throw new Error("sendTransaction: namespace not found");
        }
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("sendTransaction: adapter not found");
          }
          const provider = ProviderController.getProvider(namespace);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          }));
          return (result == null ? void 0 : result.hash) || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        const namespace = args.chainNamespace;
        if (namespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("estimateGas: adapter is required but got undefined");
          }
          const provider = ProviderController.getProvider(namespace);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("estimateGas: caipNetwork is required but got undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({ ...args, provider, caipNetwork }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a2;
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("getEnsAvatar: namespace is required but got undefined");
        }
        const address = this.getAddress(namespace);
        if (!address) {
          throw new Error("getEnsAvatar: address not found");
        }
        await this.syncIdentity({
          address,
          chainId: Number((_a2 = this.getCaipNetwork()) == null ? void 0 : _a2.id),
          chainNamespace: namespace
        });
        const accountData = ChainController.getAccountData();
        return (accountData == null ? void 0 : accountData.profileImage) || false;
      },
      getEnsAddress: async (name) => await WcHelpersUtil.resolveReownName(name),
      writeContract: async (args) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("writeContract: namespace is required but got undefined");
        }
        if (!adapter) {
          throw new Error("writeContract: adapter is required but got undefined");
        }
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderController.getProvider(namespace);
        if (!caipNetwork || !caipAddress) {
          throw new Error("writeContract: caipNetwork or caipAddress is required but got undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result == null ? void 0 : result.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("parseUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("formatUnits: adapter is required but got undefined");
        }
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("getCapabilities: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("grantPermissions: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("revokePermissions: adapter is required but got undefined");
        }
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("walletGetAssets: adapter is required but got undefined");
        }
        return await (adapter == null ? void 0 : adapter.walletGetAssets(params)) ?? {};
      },
      updateBalance: (namespace) => {
        const address = this.getAddress(namespace);
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !address) {
          return;
        }
        this.updateNativeBalance(address, caipNetwork == null ? void 0 : caipNetwork.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  async onConnectExternal(params) {
    var _a2, _b, _c2, _d, _e3, _f2, _g, _h;
    const activeChain = ChainController.state.activeChain;
    const namespace = params.chain || activeChain;
    const adapter = this.getAdapter(namespace);
    let shouldUpdateNetwork = true;
    if (params.type === ConstantsUtil3.CONNECTOR_TYPE_AUTH) {
      const authNamespaces = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS;
      const hasConnectedAuthNamespace = authNamespaces.some((namespace2) => ConnectorController.getConnectorId(namespace2) === ConstantsUtil.CONNECTOR_ID.AUTH);
      if (hasConnectedAuthNamespace && params.chain !== activeChain) {
        shouldUpdateNetwork = false;
      }
    }
    if (params.chain && params.chain !== activeChain && !params.caipNetwork) {
      const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === params.chain);
      if (toConnectNetwork && shouldUpdateNetwork) {
        this.setCaipNetwork(toConnectNetwork);
      }
    }
    if (!namespace) {
      throw new Error("connectExternal: namespace not found");
    }
    if (!adapter) {
      throw new Error("connectExternal: adapter not found");
    }
    const fallbackCaipNetwork = this.getCaipNetwork(namespace);
    const caipNetworkToUse = params.caipNetwork || fallbackCaipNetwork;
    const res = await adapter.connect({
      id: params.id,
      address: params.address,
      info: params.info,
      type: params.type,
      provider: params.provider,
      socialUri: params.socialUri,
      chainId: ((_a2 = params.caipNetwork) == null ? void 0 : _a2.id) || (fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.id),
      rpcUrl: ((_e3 = (_d = (_c2 = (_b = params.caipNetwork) == null ? void 0 : _b.rpcUrls) == null ? void 0 : _c2.default) == null ? void 0 : _d.http) == null ? void 0 : _e3[0]) || ((_h = (_g = (_f2 = fallbackCaipNetwork == null ? void 0 : fallbackCaipNetwork.rpcUrls) == null ? void 0 : _f2.default) == null ? void 0 : _g.http) == null ? void 0 : _h[0])
    });
    if (!res) {
      return void 0;
    }
    StorageUtil.addConnectedNamespace(namespace);
    this.syncProvider({ ...res, chainNamespace: namespace });
    this.setStatus("connected", namespace);
    this.syncConnectedWalletInfo(namespace);
    StorageUtil.removeDisconnectedConnectorId(params.id, namespace);
    return { address: res.address, connectedCaipNetwork: caipNetworkToUse };
  }
  async connectInactiveNamespaces(params, connectResult) {
    var _a2;
    const isConnectingToAuth = params.type === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
    const otherAuthNamespaces = HelpersUtil.getOtherAuthNamespaces((_a2 = connectResult == null ? void 0 : connectResult.connectedCaipNetwork) == null ? void 0 : _a2.chainNamespace);
    const activeCaipNetwork = ChainController.state.activeCaipNetwork;
    const activeAdapter = this.getAdapter(activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace);
    const activeProvider = ProviderController.getProvider(activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace);
    if (isConnectingToAuth) {
      await Promise.all(otherAuthNamespaces.map(async (ns3) => {
        var _a3, _b, _c2;
        try {
          const provider = ProviderController.getProvider(ns3);
          const caipNetworkToUse = this.getCaipNetwork(ns3);
          const adapter = this.getAdapter(ns3);
          const res = await (adapter == null ? void 0 : adapter.connect({
            ...params,
            provider,
            socialUri: void 0,
            chainId: caipNetworkToUse == null ? void 0 : caipNetworkToUse.id,
            rpcUrl: (_c2 = (_b = (_a3 = caipNetworkToUse == null ? void 0 : caipNetworkToUse.rpcUrls) == null ? void 0 : _a3.default) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]
          }));
          if (res) {
            StorageUtil.addConnectedNamespace(ns3);
            StorageUtil.removeDisconnectedConnectorId(params.id, ns3);
            this.setStatus("connected", ns3);
            this.syncConnectedWalletInfo(ns3);
          }
        } catch (error) {
          AlertController.warn(ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.displayMessage, ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.debugMessage(ns3, error instanceof Error ? error.message : void 0), ErrorUtil.ALERT_WARNINGS.INACTIVE_NAMESPACE_NOT_CONNECTED.code);
        }
      }));
      if (activeCaipNetwork) {
        await (activeAdapter == null ? void 0 : activeAdapter.switchNetwork({
          caipNetwork: activeCaipNetwork,
          provider: activeProvider,
          providerType: params.type
        }));
      }
    }
  }
  getApprovedCaipNetworksData() {
    var _a2, _b, _c2, _d, _e3;
    const providerType = ProviderController.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = (_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: ((_e3 = (_d = (_c2 = this.universalProvider) == null ? void 0 : _c2.session) == null ? void 0 : _d.peer) == null ? void 0 : _e3.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderController.getProvider(networkNamespace);
      const providerType = ProviderController.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address = this.getAddressByChainNamespace(networkNamespace);
          if (address) {
            this.syncAccount({
              address,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a2, _b;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b4) => b4.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
          networks: (_b = this.caipNetworks) == null ? void 0 : _b.filter(({ chainNamespace }) => chainNamespace === namespace)
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    var _a2;
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await ((_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace].syncConnectors(this.options, this));
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (OptionsController.state.enableReconnect === false) {
      this.setStatus("disconnected", chainNamespace);
    } else if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a2, _b;
      const caipNetwork = this.getCaipNetworks().find((n3) => n3.id.toString() === chainId.toString() || n3.caipNetworkId.toString() === chainId.toString());
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = (_b = (_a2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.address;
      if (caipNetwork) {
        const account = isSameNamespace && address ? address : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", () => {
      const isMultiWallet = this.remoteFeatures.multiWallet;
      const allConnections = Array.from(ConnectionController.state.connections.values()).flat();
      this.onDisconnectNamespace({
        chainNamespace,
        closeModal: !isMultiWallet || allConnections.length === 0
      });
    });
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address = this.getAddress(chainNamespace);
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id)) {
        return;
      }
      this.updateNativeBalance(address, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address, chainId, connector }) => {
      var _a2, _b;
      this.handlePreviousConnectorConnection(connector);
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (connector == null ? void 0 : connector.provider) {
        this.syncProvider({
          id: connector.id,
          type: connector.type,
          provider: connector == null ? void 0 : connector.provider,
          chainNamespace
        });
        this.syncConnectedWalletInfo(chainNamespace);
      }
      const namespaceNetworkId = (_b = (_a2 = ChainController.getNetworkData(chainNamespace)) == null ? void 0 : _a2.caipNetwork) == null ? void 0 : _b.id;
      const syncAccountChainId = chainId || namespaceNetworkId;
      if (isActiveChain && syncAccountChainId) {
        this.syncAccount({
          address,
          chainId: syncAccountChainId,
          chainNamespace
        });
      } else if (!isActiveChain && syncAccountChainId) {
        this.syncAccountInfo(address, syncAccountChainId, chainNamespace);
        this.syncBalance({ address, chainId: syncAccountChainId, chainNamespace });
      } else {
        this.syncAccountInfo(address, chainId, chainNamespace);
      }
      StorageUtil.addConnectedNamespace(chainNamespace);
    });
  }
  /**
   * Checks the incoming connector and handles the previous connection in the connector's namespace, and if necessary (i.e multi-wallet is disabled) disconnects the previous connector
   * @param connector
   */
  async handlePreviousConnectorConnection(connector) {
    var _a2;
    const namespace = connector == null ? void 0 : connector.chain;
    const newConnectorId = connector == null ? void 0 : connector.id;
    const currentConnectorId = ConnectorController.getConnectorId(namespace);
    const isMultiWalletEnabled = (_a2 = OptionsController.state.remoteFeatures) == null ? void 0 : _a2.multiWallet;
    const hasNewConnectorConnected = currentConnectorId !== newConnectorId;
    const shouldDisconnectPreviousConnector = namespace && newConnectorId && currentConnectorId && hasNewConnectorConnected && !isMultiWalletEnabled;
    try {
      if (shouldDisconnectPreviousConnector) {
        await ConnectionController.disconnect({ id: currentConnectorId, namespace });
      }
    } catch (error) {
      console.warn("Error disconnecting previous connector", error);
    }
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    var _a2, _b, _c2;
    await this.getUniversalProvider();
    if (this.universalProvider) {
      await ((_c2 = (_b = (_a2 = this.chainAdapters) == null ? void 0 : _a2[chainNamespace]) == null ? void 0 : _b.setUniversalProvider) == null ? void 0 : _c2.call(_b, this.universalProvider));
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async unSyncExistingConnection() {
    try {
      await Promise.allSettled(this.chainNamespaces.map((namespace) => ConnectionController.disconnect({ namespace, initialDisconnect: true })));
    } catch (error) {
      console.error("Error disconnecting existing connections:", error);
    }
  }
  async reconnectWalletConnect() {
    await this.syncWalletConnectAccount();
    const address = this.getAddress();
    if (!this.getCaipAddress()) {
      StorageUtil.deleteRecentWallet();
    }
    const recentWallet = StorageUtil.getRecentWallet();
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      address,
      properties: {
        method: CoreHelperUtil.isMobile() ? "mobile" : "qrcode",
        name: (recentWallet == null ? void 0 : recentWallet.name) || "Unknown",
        reconnect: true,
        view: RouterController.state.view,
        walletRank: recentWallet == null ? void 0 : recentWallet.order
      }
    });
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.reconnectWalletConnect();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      this.setStatus("disconnected", namespace);
    }
  }
  onDisconnectNamespace(options) {
    const { chainNamespace, closeModal } = options || {};
    ChainController.resetAccount(chainNamespace);
    ChainController.resetNetwork(chainNamespace);
    StorageUtil.removeConnectedNamespace(chainNamespace);
    const namespaces = Array.from(ChainController.state.chains.keys());
    const namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
    namespacesToDisconnect.forEach((ns3) => StorageUtil.addDisconnectedConnectorId(ConnectorController.getConnectorId(ns3) || "", ns3));
    ConnectorController.removeConnectorId(chainNamespace);
    ProviderController.resetChain(chainNamespace);
    this.setUser(null, chainNamespace);
    this.setStatus("disconnected", chainNamespace);
    this.setConnectedWalletInfo(null, chainNamespace);
    if (closeModal !== false) {
      ModalController.close();
    }
  }
  async syncAdapterConnections() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => {
      const adapter = this.getAdapter(namespace);
      const caipAddress = this.getCaipAddress(namespace);
      const caipNetwork = this.getCaipNetwork(namespace);
      return adapter == null ? void 0 : adapter.syncConnections({
        connectToFirstConnector: !caipAddress,
        caipNetwork
      });
    }));
  }
  async syncAdapterConnection(namespace) {
    var _a2, _b, _c2, _d;
    const adapter = this.getAdapter(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c5) => c5.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!(caipNetwork == null ? void 0 : caipNetwork.id)) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await (adapter == null ? void 0 : adapter.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: (_c2 = (_b = (_a2 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a2.default) == null ? void 0 : _b.http) == null ? void 0 : _c2[0]
      }));
      if (connection) {
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          address: connection.address,
          properties: {
            method: "browser",
            name: ((_d = connector.info) == null ? void 0 : _d.name) || connector.name || "Unknown",
            reconnect: true,
            view: RouterController.state.view,
            walletRank: void 0
          }
        });
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e) {
      this.onDisconnectNamespace({ chainNamespace: namespace, closeModal: false });
    }
  }
  async syncWalletConnectAccount() {
    var _a2, _b;
    const sessionNamespaces = Object.keys(((_b = (_a2 = this.universalProvider) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces) || {});
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      var _a3, _b2, _c2, _d, _e3;
      const adapter = this.getAdapter(chainNamespace);
      if (!adapter) {
        return;
      }
      const namespaceAccounts = ((_d = (_c2 = (_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces) == null ? void 0 : _c2[chainNamespace]) == null ? void 0 : _d.accounts) || [];
      const activeChainId = (_e3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e3.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === (activeChainId == null ? void 0 : activeChainId.toString());
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderController.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderController.setProvider(chainNamespace, provider);
        } else {
          ProviderController.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (sessionNamespaces.includes(chainNamespace)) {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderController.setProviderId(chainNamespace, type);
    ProviderController.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAccount(params) {
    var _a2, _b;
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n3) => n3.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n3) => n3.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainId) === chainIdToUse.toString();
        });
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => {
          var _a3;
          return ((_a3 = ParseUtil.parseCaipNetworkId(id)) == null ? void 0 : _a3.chainNamespace) === chainNamespace;
        });
        caipNetwork = this.getCaipNetworks().find((n3) => n3.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n3) => n3.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n3 && n3.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if ((network == null ? void 0 : network.chainNamespace) === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ((_b = ChainController.state.activeCaipNetwork) == null ? void 0 : _b.name) === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      const currentAddress = this.getAddress(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address, currentAddress)) {
        this.syncAccountInfo(address, network == null ? void 0 : network.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address, chainId: network == null ? void 0 : network.id, chainNamespace });
      } else {
        await this.syncBalance({ address, chainId: networkOfChain == null ? void 0 : networkOfChain.id, chainNamespace });
      }
      this.syncIdentity({
        address,
        chainId,
        chainNamespace
      });
    }
  }
  async syncAccountInfo(address, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || (caipAddress == null ? void 0 : caipAddress.split(":")[1]);
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address}`;
    this.setCaipAddress(newCaipAddress, chainNamespace, true);
    await this.syncIdentity({
      address,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a2;
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderController.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connectors = this.getConnectors();
        const connector = connectors.find((c5) => {
          var _a3, _b;
          const isConnectorId = c5.id === connectorId;
          const isRdns = ((_a3 = c5.info) == null ? void 0 : _a3.rdns) === connectorId;
          const hasMultiChainConnector = (_b = c5.connectors) == null ? void 0 : _b.some((_c2) => {
            var _a4;
            return _c2.id === connectorId || ((_a4 = _c2.info) == null ? void 0 : _a4.rdns) === connectorId;
          });
          return isConnectorId || isRdns || Boolean(hasMultiChainConnector);
        });
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderController.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a2 = provider.session.peer.metadata.icons) == null ? void 0 : _a2[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE_SDK || connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c5) => c5.id === connectorId);
        const name = (connector == null ? void 0 : connector.name) || "Coinbase Wallet";
        const icon = (connector == null ? void 0 : connector.imageUrl) || this.getConnectorImage(connector);
        const info = connector == null ? void 0 : connector.info;
        this.setConnectedWalletInfo({
          ...info,
          name,
          icon
        }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n3) => {
      var _a2;
      return n3.id.toString() === ((_a2 = params.chainId) == null ? void 0 : _a2.toString());
    });
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    var _a2, _b, _c2, _d, _e3, _f2, _g, _h, _i3, _j;
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      metadata: {
        name: ((_b = this.options) == null ? void 0 : _b.metadata) ? (_c2 = this.options) == null ? void 0 : _c2.metadata.name : "",
        description: ((_d = this.options) == null ? void 0 : _d.metadata) ? (_e3 = this.options) == null ? void 0 : _e3.metadata.description : "",
        url: ((_f2 = this.options) == null ? void 0 : _f2.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.url : "",
        icons: ((_h = this.options) == null ? void 0 : _h.metadata) ? (_i3 = this.options) == null ? void 0 : _i3.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean((_j = this.options) == null ? void 0 : _j.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await N3.init(universalProviderOptions);
    if (OptionsController.state.enableReconnect === false && this.universalProvider.session) {
      await this.universalProvider.disconnect();
    }
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.chainNamespaces.forEach((namespace) => {
        WcHelpersUtil.listenWcProvider({
          universalProvider: this.universalProvider,
          namespace,
          onDisplayUri: (uri) => {
            ConnectionController.setUri(uri);
          },
          onConnect: (accounts) => {
            const { address } = CoreHelperUtil.getAccount(accounts[0]);
            ConnectionController.finalizeWcConnection(address);
          },
          onDisconnect: () => {
            if (ChainController.state.noAdapters) {
              this.resetAccount(namespace);
            }
            ConnectionController.resetWcConnection();
          },
          onChainChanged: (chainId) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const caipNetwork = this.getCaipNetworks().find((n3) => n3.id.toString() === chainId.toString() || n3.caipNetworkId.toString() === chainId.toString());
              const currentCaipNetwork = this.getCaipNetwork();
              if (!caipNetwork) {
                this.setUnsupportedNetwork(chainId);
                return;
              }
              if ((currentCaipNetwork == null ? void 0 : currentCaipNetwork.id.toString()) !== (caipNetwork == null ? void 0 : caipNetwork.id.toString()) && (currentCaipNetwork == null ? void 0 : currentCaipNetwork.chainNamespace) === (caipNetwork == null ? void 0 : caipNetwork.chainNamespace)) {
                this.setCaipNetwork(caipNetwork);
              }
            }
          },
          onAccountsChanged: (accounts) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const account = accounts == null ? void 0 : accounts[0];
              if (account) {
                this.syncAccount({
                  address: account.address,
                  chainId: account.chainId,
                  chainNamespace: account.chainNamespace
                });
              }
            }
          }
        });
      });
    }
  }
  createUniversalProvider() {
    var _a2;
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && ((_a2 = this.options) == null ? void 0 : _a2.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err instanceof Error ? err.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err);
      }
    }
    return this.universalProvider;
  }
  getDisabledCaipNetworks() {
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    return sortedNetworks.filter((network) => ChainController.isCaipNetworkDisabled(network));
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    var _a2;
    if (!namespace) {
      return void 0;
    }
    return (_a2 = this.chainAdapters) == null ? void 0 : _a2[namespace];
  }
  createAdapter(blueprint) {
    var _a2, _b;
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: (_a2 = this.options) == null ? void 0 : _a2.projectId,
      networks: (_b = this.caipNetworks) == null ? void 0 : _b.filter(({ chainNamespace }) => chainNamespace === namespace)
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options == null ? void 0 : options.uri) {
      ConnectionController.setUri(options.uri);
    }
    const { isSwap, isSend } = this.toModalOptions();
    if (isSwap(options)) {
      return ModalController.open({
        ...options,
        data: { swap: options.arguments }
      });
    } else if (isSend(options)) {
      if (options.arguments) {
        return this.openSend(options.arguments);
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect({ namespace: chainNamespace });
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a2;
    return (_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id;
  }
  async switchNetwork(appKitNetwork, { throwOnFailure = false } = {}) {
    const network = this.getCaipNetworks().find((n3) => n3.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network, { throwOnFailure });
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderController.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderController.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderController.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  subscribeConnections(callback) {
    if (!this.remoteFeatures.multiWallet) {
      AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
      return () => void 0;
    }
    return ConnectionController.subscribe(callback);
  }
  getWalletInfo(namespace) {
    var _a2, _b;
    if (namespace) {
      return (_b = (_a2 = ChainController.state.chains.get(namespace)) == null ? void 0 : _a2.accountState) == null ? void 0 : _b.connectedWalletInfo;
    }
    const accountData = ChainController.getAccountData();
    return accountData == null ? void 0 : accountData.connectedWalletInfo;
  }
  getAccount(_namespace) {
    const namespace = _namespace || ChainController.state.activeChain;
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState = ChainController.getAccountData(namespace);
    const activeConnectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const connections = ConnectionController.getConnections(namespace);
    if (!namespace) {
      throw new Error("AppKit:getAccount - namespace is required");
    }
    const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address, type, publicKey }) => CoreHelperUtil.createAccount(namespace, address, type || "eoa", publicKey)));
    if (!accountState) {
      return void 0;
    }
    return {
      allAccounts,
      caipAddress: accountState.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState.caipAddress),
      isConnected: Boolean(accountState.caipAddress),
      status: accountState.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState.user ? {
          ...accountState.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState.socialProvider || "email",
        accountType: getPreferredAccountType(namespace),
        isSmartAccountDeployed: Boolean(accountState.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback, namespace) {
    if (namespace) {
      return ChainController.subscribeChainProp("accountState", (accountState) => callback(accountState == null ? void 0 : accountState.connectedWalletInfo), namespace);
    }
    return ChainController.subscribeChainProp("accountState", (accountState) => callback(accountState == null ? void 0 : accountState.connectedWalletInfo));
  }
  subscribeShouldUpdateToAddress(callback) {
    ChainController.subscribeChainProp("accountState", (accountState) => callback(accountState == null ? void 0 : accountState.shouldUpdateToAddress));
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  getRemoteFeatures() {
    return OptionsController.state.remoteFeatures;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  subscribeRemoteFeatures(callback) {
    return OptionsController.subscribeKey("remoteFeatures", callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n3) => n3.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n3) => n3.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Overrides --------------------------------------------------------------
  async open(options) {
    const isConnected = ConnectorController.isConnected();
    if (!isConnected) {
      await super.open(options);
    }
  }
  async close() {
    var _a2;
    await super.close();
    if (this.options.manualWCControl) {
      const address = (_a2 = ChainController.getAccountData(this.activeChainNamespace)) == null ? void 0 : _a2.address;
      ConnectionController.finalizeWcConnection(address);
    }
  }
  async syncIdentity(_request) {
    return Promise.resolve();
  }
  async syncBalance(_params) {
    return Promise.resolve();
  }
  async injectModalUi() {
    if (!isInitialized && CoreHelperUtil.isClient()) {
      await import("./basic-HRETVVA6.js");
      await import("./w3m-modal-B7BVWUE4.js");
      const isElementCreated = document.querySelector("w3m-modal");
      if (!isElementCreated) {
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
      }
      isInitialized = true;
    }
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.8.7";

// node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    basic: true,
    sdkVersion: `html-core-${PACKAGE_VERSION}`
  });
}
export {
  AppKit,
  createAppKit
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=core-RO6ZTZMM.js.map
